{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"","text":"方法主要是用了倍增的思想+位运算如果能用long，就用位运算，再判断溢出的特例。class Solution &#123; public: int divide(int dividend, int divisor) &#123; int flag; if((dividend&gt;0&amp;&amp;divisor&gt;0)||(divisor&lt;0&amp;&amp;dividend&lt;0)) flag=1; else flag=-1; if(dividend==0x80000000&amp;&amp;divisor==-1) return 0x7fffffff; long long div1=abs(long(dividend)),div2=abs(long(divisor)); long long res=0; while(div1&gt;=div2) &#123; int tmp=0; while((div1&gt;&gt;(tmp+1))&gt;=(div2)) &#123; tmp++; &#125; div1-=(div2&lt;&lt;(tmp)); res+=(1&lt;&lt;tmp); &#125; return res*flag; &#125; &#125;; 如果不能用long，就用倍增的方法+同时将数全部化为负数，然后要控制数小于INT_MIN/2的情况。 int divide(int dividend, int divisor) &#123; int flag; if((dividend&gt;0&amp;&amp;divisor&gt;0)||(divisor&lt;0&amp;&amp;dividend&lt;0)) flag=1; else flag=-1; if(dividend==0x80000000&amp;&amp;divisor==-1) return 0x7fffffff; int div1=dividend,div2=divisor; if(dividend&gt;0) div1=-dividend; if(divisor&gt;0) div2=-divisor; int res=0; while(div1&lt;=div2) &#123; int tmp=-1; int div2tmp=div2; while(div2tmp&gt;=INT_MIN/2&amp;&amp;((div1)&lt;=(div2tmp+div2tmp))) &#123; div2tmp+=div2tmp; tmp+=tmp; &#125; div1-=div2tmp; res+=tmp; &#125; return res*-flag; &#125;","path":"2021/12/19/29. 两数相除/"},{"title":"raft算法","text":"raft相比 paxos更容易理解。 raft leader 是一种强leader，日志只能从leader复制日志到其他服务器。 复制是用来解决分布式系统的容错的问题的。 复制状态机就是这种用来解决分布式系统的容错的问题的，在怎么做的呢？复制状态机是通过复制日志来实现的，每个服务器都有相同的日志 raft这种一致性算法就是为了实现分布式的容错性，通过保证复制日志的一致性来实现的。为了解决这个问题，实际上是通过raft实际上只有三个问题. 1 是如何选举出leader 2 如何复制日志 3 怎么保证安全 raft必须保证大部分机器可用。以下是一些raft的基础的内容，三种角色，leader，candidate，follower。 只有leader可以处理客户端的请求，如果其他角色接收到了请求，会重定向到leader。 任期，每个任期从选举开始，只会有一个leader，时间长度不确定。当出现选举分裂的情况下，将不会选取leader，然后新的任期开始，重新选举。 在服务器被孤立的情况下，可能服务器接收到请求时发现任期和自己不一样。如果请求的任期太旧了，拒绝请求。如果任期比自己新，那么如果自己是leader，转变成follower，然后更新任期，如果是其他角色，也更新任期。 raft通过RPC通信请求选举RPC追加日志RPC传送快照RPC 心跳机制，folloewr有计时器，如果超时就发起选举，leader会发送心跳授权延长自己的任期在一次选举开始时，folloewr转为候选者，然后任期增加当候选者接收到其他服务器请求投票的请求时 实现：对于每个raft的服务器同时启动follower和Leader的协程 follower协程sleep，每当超时就发起选举，对其他的每个服务器发送请求投票RPC。Leader的协程每当间隔一定时间就向其他的服务器发送心跳同时给出自己的日志相关信息，通过增加日志RPC发送给它们，同时如果对方的日志太旧就安装快照，发送安装快照RPC，针对结果进行。 6.824 内容Shard把所有数据按照Key Hash然后取模10,把数据切分成10片.每一片称为一个Shard, 其中包括一组键值对 ShardServer (Group)每个Group都是一个Raft集群, 通过Raft保证这组服务器上的数据一致性. 一组服务器负责几个Shard的读写请求.整个集群由N个Group组成 Client客户端, 发起读写请求. ShardMaster是集群中的协调者, 他负责调整Shard在集群间的分配, 以及集群路由的查询工作. 扩容: 新加入了一组服务器Group3, 需要将针对某个Shard的历史数据和后续的读写请求由Group1交给Group3负责以扩容集群. 缩容: 需要下线Group3, 需要将Group3负责的Shard历史数据和后续读写请求交给其他Group负责.扩缩容操作后需要保证Group间的负载均衡 路由查询: 假设Client 需要 Put(key:”name”, value: “L” ), “name”这个key存储在Shard1上. 需要Client根据从ShardMaster获取到的配置来确认向哪个Group发起写请求. Config由ShardMaster维护, 客户端和ShardServer拉取的配置, 其中包括的所有服务器分组地址以及集群路由信息. 每次集群动作的变更都会引起Config Version的更新. Recoverable快照和Raft中的状态要及时落盘,每一台服务器都要能够在故障后重启恢复 线性一致性需要能立刻读到之前完成的写请求 负载均衡Shard在Group间的分布要尽可能均衡, 可以通过一致性哈希或者其他方法来实现 multiRaft我们使用 Raft 一致性算法来确保在机器发生故障时数据也能保持一致。在大多数使用 Raft 的系统中，如 etcd 和 Consul，整个系统只有一个 Raft 共识组。然而，在 CockroachDB 中，数据被分成不同的范围，每个范围都有自己的共识组。这意味着每个节点都可能参与成千上万个共识组。这就提出了一些独特的挑战，我们通过在 Raft 之上引入一层 MultiRaft 来解决这些问题。 简单来说，MultiRaft 是在整个系统中，把所管理的数据按照一定的方式切片，每一个切片的数据都有自己的副本，这些副本之间的数据使用 Raft 来保证数据的一致性，在全局来看整个系统中同时存在多个 Raft-Group单个 Raft-Group 在 KV 的场景下存在一些弊端: (1) 系统的存储容量受制于单机的存储容量（使用分布式存储除外）。 (2) 系统的性能受制于单机的性能（读写请求都由Leader节点处理）。 MultiRaft 需要解决的一些核心问题： (1) 数据何如分片。 (2) 分片中的数据越来越大，需要分裂产生更多的分片，组成更多 Raft-Group。 (3) 分片的调度，让负载在系统中更平均（分片副本的迁移，补全，Leader 切换等等）。 (4) 一个节点上，所有的 Raft-Group 复用链接（否则 Raft 副本之间两两建链，链接爆炸了）。 (5) 如何处理 stale 的请求（例如 Proposal 和 Apply 的时候，当前的副本不是 Leader、分裂了、被销毁了等等）。 (6) Snapshot 如何管理（限制Snapshot，避免带宽、CPU、IO资源被过度占用）。 lab4b在实际的生产系统中，不同 raft 组的成员可能存在于一个物理节点上，而且一般情况下都是一个物理节点拥有一个状态机，不同 raft 组使用不同地命名空间或前缀来操作同一个状态机。系统的运行方式：一开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。 对于集群内部，我们需要保证所有分片能够较为均匀的分配在所有 raft 组上，还需要能够支持动态迁移和容错。 对于集群外部，我们需要向用户保证整个集群表现的像一个永远不会挂的单节点 KV 服务一样，即具有线性一致性。 所有涉及修改集群分片状态的操作都应该通过 raft 日志的方式去提交，这样才可以保证同一 raft 组内的所有分片数据和状态一致。在 6.824 的框架下，涉及状态的操作都需要 leader 去执行才能保持正确性，否则需要添加一些额外的同步措施，而这显然不是 6.824 所推荐的。因此配置更新，分片迁移，分片清理和空日志检测等逻辑都只能由 leader 去检测并执行。数据迁移的实现为 pull 还是 push？其实都可以，个人感觉难度差不多，这里实现成了 pull 的方式。 首先，每个 raft 组的 leader 需要有一个协程去向 shardctrler 定时拉取最新配置，一旦拉取到就需要提交到该 raft 组中以更新配置。此外，为了防止集群的分片状态被覆盖，从而使得某些任务永远被丢弃，因此一旦存在某一分片的状态不是默认状态，配置更新协程就会停止获取和提交新配置直至所有分片的状态都为默认状态为止。","path":"2021/05/25/raft 算法/"},{"title":"kmp算法，模板","text":"在求next数组和求相似数组很相似，只是i的起始点要为1，一个为0 可以参考leetcode链接 void getNext(List&lt;Integer&gt; next,String s1) &#123; int j=0; for(int i=1;i&lt;s1.length();i++) &#123; while(j&gt;0&amp;&amp;(s1.charAt(j)!=s1.charAt(i))) j=next.get(j-1); if(s1.charAt(j)==s1.charAt(i)) j++; next.set(i,j); &#125; &#125; public int strStr(String haystack, String needle) &#123; if(needle.length()==0) return 0; List&lt;Integer&gt; next=new ArrayList&lt;&gt;(Collections.nCopies(needle.length(),0)); getNext(next,needle); int i,j=0; for(i=0;i&lt;haystack.length();i++) &#123; while((j&gt;0)&amp;&amp;(haystack.charAt(i)!=needle.charAt(j))) j=next.get(j-1); if(haystack.charAt(i)==needle.charAt(j)) j++; if(j==needle.length()) return i-j+1; &#125; return -1; &#125;","path":"2021/04/27/kmp算法/"},{"title":"马拉车算法","text":"关键之处在于要利用镜像的信息，对于镜像已经知道的及时跳过。 然后还有一点就是扩充字符串#，然后两端加@！，这个时候我们如果得到最长回文串，那么怎么获得原始的最长回文串呢，是最右边的-中心得到最左边的位置，然后最左边的位置除2就是原始的起始值，这个很容易理解，因为是刚好扩充了两倍的，用#隔开的。 还有一点关键是更新的是每个点已经以他为中心扩充的字符串，dp数组记录的是长度 class Solution &#123; public String longestPalindrome(String s) &#123; StringBuilder sb=new StringBuilder(&quot;!#&quot;); for(int i=0;i&lt;s.length();i++) &#123; sb.append(s.charAt(i)); sb.append(&quot;#&quot;); &#125; sb.append(&quot;@&quot;); int dp[]=new int[sb.length()]; int C=0,R=0; int maxlen=0,center=0; for(int i=0;i&lt;sb.length();i++) &#123; int slen=1;//子串长度 if(i&lt;R)//如果包含在内 &#123; int mirror=2*C-i;//如果镜像没超过边界，那么直接赋值，否则还要验证 dp[i]=Math.min(dp[mirror],R-i);//直接取镜像的dp值和到边界距离的最小值 slen=dp[i]; &#125; while((i-slen)&gt;=0&amp;&amp;(i+slen)&lt;sb.length()&amp;&amp;(sb.charAt(i-slen)==sb.charAt(i+slen))) &#123; slen++; &#125; if(i+slen-1&gt;R) &#123; R=i+slen-1; C=i; &#125; dp[i]=slen-1; if(dp[i]&gt;maxlen) &#123; maxlen=dp[i]; center=i; &#125; &#125; // System.out.println(maxlen); return s.substring((center-maxlen)/2,(center-maxlen)/2+maxlen); &#125; &#125;","path":"2021/04/12/马拉车算法/"},{"title":"146. LRU 缓存机制","text":"HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供 有序，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照插入的顺序，一种是按照读取的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护&lt;!—hexoPostRenderEscape:class LRUCache &#123;&lt;/span&gt; private int cap; private Map&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(); // 保持插入顺序 &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LRUCache&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.cap = capacity; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;(key); &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key); &lt;span class=&quot;hljs-comment&quot;&gt;// 保证每次查询后，都在末尾&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;() == cap) &amp;#123; Iterator&amp;lt;Map.E***y&amp;lt;Integer, Integer&amp;gt;&amp;gt; iterator = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.e***ySet().iterator(); iterator.next(); iterator.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// int firstKey = map.e***ySet().iterator().next().getValue();&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// map.remove(firstKey);&lt;/span&gt; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value); &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 另外一个方法是采用双向链表，然后用hashmap存每个节点的key和地址。&lt;!—hexoPostRenderEscape:class LRUCache &#123; class myLinked &#123; int val; int key; myLinked next; myLinked prev; myLinked()&#123;&#125; myLinked(int _key,int _value)&#123;key=_key;val=_value;&#125; &#125; private HashMap&lt;Integer,myLinked&gt; m&lt;/span&gt;=new HashMap&lt;&gt;(); private int size; private int capacity; private myLinked head,tail; public LRUCache(int capacity&lt;/span&gt;) &lt;/span&gt;&lt;/span&gt; &#123; this.size=0; this.capacity=capacity; head=new myLinked(); tail=new myLinked(); head.next=tail; tail.next=head; &#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key&lt;/span&gt;)&lt;/span&gt; &amp;#123; myLinked l=m.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(key); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(l==&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; movetohead(l); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; l.val; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt; &lt;/span&gt; &#123; myLinked l=m.get(key); if(l!=null) &#123; l.val=value; movetohead(l); &#125; else &#123; myLinked tmp=new myLinked(key,value); m.put(key,tmp); addtohead(tmp); ++size; if(size&gt;capacity) &#123; myLinked tt=removetail(); m.remove(tt.key); size—; &#125; &#125; &#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addtohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; node.prev.next = node.next; node.next.prev = node.prev; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;movetohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; removeNode(node); addtohead(node); &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; myLinked &lt;span class=&quot;hljs-title&quot;&gt;removetail&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123; myLinked res = tail.prev; removeNode(res); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2021/03/29/146. LRU 缓存机制/"},{"title":"327. 区间和的个数（树状数组+前缀和+离散化）","text":"依然考虑前缀和数组 \\textit{preSum}preSum。 对于每个下标 jj，以 jj 为右端点的下标对的数量，就等于数组 \\textit{preSum}[0..j-1]preSum[0..j−1] 中的所有整数，出现在区间 [\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}][preSum[j]−upper,preSum[j]−lower] 的次数。 区间和的问题比较适合用线段树和树状数组 很多人都把constexpr和const相比较。 其实，const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定。 constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。 树状数组可以参考class Solution &#123; public: class BIT &#123; private: int n; vector&lt;int&gt; arr; public: int lowerbit(int i) &#123; return i&amp;(-i); &#125; int query(int i)//求A[1 - i]的和 &#123; int res=0; while(i) &#123; res+=arr[i]; i-=lowerbit(i); &#125; return res; &#125; void add(int i,int x)//在i位置加上k &#123; while(i&lt;=n)//树状数组是从1开始的，所以需要有等号 &#123; arr[i]+=x; i+=lowerbit(i); &#125; &#125; BIT(int _n): n(_n),arr(_n+1)&#123;&#125; &#125;; typedef long long ll; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int len=nums.size(); vector&lt;ll&gt; presum=&#123;0&#125;; ll sum=0; for(int i=0;i&lt;len;i++) &#123; sum+=nums[i]; presum.push_back(sum); &#125; set&lt;ll&gt; se; for(ll p: presum) &#123; se.insert(p); se.insert(p-upper); se.insert(p-lower); &#125; unordered_map&lt;ll,int&gt; m; int index=0; for(ll p: se) &#123; m[p]=index; index++; &#125; int result=0; BIT tree(m.size()); for(int i=0;i&lt;presum.size();i++) &#123; int left=m[presum[i]-upper]; int right=m[presum[i]-lower]; result+=tree.query(right+1)-tree.query(left);//这里有点迷惑，不懂为什么这样弄 tree.add(m[presum[i]]+1,1); &#125; return result; &#125; &#125;;","path":"2021/01/23/327. 区间和的个数/"},{"title":"1584. 连接所有点的最小费用（最小生成树Prime）","text":"朴素版Prim O(n^2) 适用于稠密图 稀疏图的 最小生成树 这个是prim的情况 学习STL，发现STL默认都是使用()比较的，默认比较使用less（即’&lt;’运算符），如sort(a,a+n)，默认将数组按照递增的顺序来排序（前面的元素&lt;后面的嘛），但是优先队列的源码比较奇特，虽然按道理使用less比较应该默认是小根堆（即堆顶元素最小），但是priority_queue&lt;&gt;默认是大根堆的，这是因为优先队列队首指向最后，队尾指向最前面的缘故！每次入队元素进去经排序调整后，优先级最大的元素排在最前面，也就是队尾指向的位置，这时候队首指向优先级最小的元素！所以虽然使用less但其实相当于greater，我们重载运算符的时候比较函数里面写&gt;就相当于&lt;排序方式，这点需要花点时间想想，再来说一说优先队列的这个类型，其实有三个参数：priority_queue，即类型，容器和比较器，后两个参数可以缺省，这样默认的容器就是vector，比较方法是less，也就是默认大根堆，可以自定义写比较方法，但此时若有比较方法参数，则容器参数不可省略！priority_queue&lt;&gt;的可支持的容器必须是用数组实现的容器，如vector，deque，但不能是list（推荐vector），比较方法可以写结构体重载()运算符，也可以用less，greater这些语言实现了的，但是灵活性不够，建议手写重载结构体，或者——如果不想写比较结构体的话，就将后面的两个参数缺省，直接重载类型的&lt;运算符，所以这里写的时候要注意优先队列和其他容器比较器的区别。 class Solution &#123; public: int a[1002][1002]; int sta[1002]; struct node &#123; int weight,p1,p2; &#125;; struct cmp &#123; bool operator()(node a,node b) &#123; return a.weight &gt; b.weight; &#125; &#125;; int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int INF=0x3f3f3f3f; int len=points.size(); vector&lt;vector&lt;int&gt;&gt; dist(len+1,vector&lt;int&gt;(len+1,INF)); for(int i=0;i&lt;points.size();i++) &#123; for(int j=0;j&lt;points.size();j++) &#123; dist[j][i]=dist[i][j]=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]); &#125; &#125; vector&lt;int&gt; po; po.push_back(0); sta[0]=1; int result=0; priority_queue &lt;node,vector&lt;node&gt;,cmp&gt; qu; for(int i=1;i&lt;len;i++) &#123; node tt = &#123;weight:dist[0][i], p1:0,p2:i&#125;; qu.push(tt); &#125; while(po.size()&lt;len) &#123; while(!qu.empty()) &#123; node tmp1=qu.top(); if(sta[tmp1.p2]==1&amp;&amp;sta[tmp1.p1]==1) &#123; qu.pop(); continue; &#125; else break; &#125; node tmp=qu.top(); // cout&lt;&lt;tmp.p1&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;endl; qu.pop(); sta[tmp.p2]=1; for(int i=0;i&lt;len;i++) &#123; if(sta[i]==1||i==tmp.p2) continue; // cout&lt;&lt;dist[tmp.p2][i]&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; node tt = &#123;weight:dist[tmp.p2][i], p1:tmp.p2,p2:i&#125;; qu.push(tt); &#125; result+=tmp.weight; po.push_back(1); &#125; return result; &#125; &#125;;","path":"2021/01/22/1584. 连接所有点的最小费用/"},{"title":"能谱CT物理原理","text":"CNR = contrast-to-noise ratio, EID = energy-integrating detector, PCD= photon-counting detector 相对于传统的能量集成探测器CT，光子计数CT将允许减少辐射剂量，提高空间分辨率，纠正光束硬化伪影，并使用替代对比剂，同时为定量成像创造机会。 EID CT， x光打到一个吸收层上，吸收层吸收x射线光子，然后转化为可见光光子，可见光光子被一个由半导体材料制成的光电二极管吸收，光电二极管测量入射光的数量，并产生一个电信号，该电信号与在测量期间沉积的总能量成比例，而不是单个x射线光子的能量。 光子计数探测器(PCDs)，另一方面，不需要一个单独的层来转换x射线到光，但由一个单一的厚层半导体二极管(1.6-30毫米取决于材料)，在上面施加一个大的电压。如果入射的x射线被半导体吸收，它就会产生一团正负电荷(6)，迅速地彼此分离。移动的电荷在连接在电极上的电线上产生一个电脉冲，并被电子读出电路记录下来。因此，pcd直接将单个x射线光子转换成电信号，不像当前CT中使用的EIDs，需要额外的步骤将光子转换成可见光。 每一个光子撞击探测器元件，都会产生一个电脉冲，其高度与光子储存的能量成正比。探测器的电子系统计算高度超过预设阈值水平的脉冲的数目。阈值设置在高于电子噪声水平但低于入射光子产生的脉冲水平。此外，通过将每个脉冲与几个阈值水平进行比较，探测器可以根据光子的能量将入射光子分类成若干个能量箱(通常为2到8个)(图3)。因此，电子噪声有效地排除在光子和/或脉冲计数之外，所以一次射线可以产生很多个能谱段。 PCD计数器暂时没有商业应用。使用特定能量测量和能量阈值来拒绝电子噪声。促进新的成像方法，如k-边缘减法原因：造成性能下降的影响取决于探测器中使用的传感器材料的类型。PCDs的研究主要集中在碲化镉、碲化镉锌和硅(6) 康普顿效应 在理想PCD中，光子只在它所撞击的探测器元件中产生信号。在现实中，有几个物理效应可能导致单个光子在多个探测器元素中被登记为计数事件。在硅探测器中，很大一部分光子在探测器材料中通过康普顿散射相互作用，将一小部分能量沉积在探测器元素中。然后，散射光子就会向一个新的、随机的方向移动，可能会把剩余的能量储存在另一个探测器元素中，对于碲化镉和碲化镉锌，康普顿散射概率较低。然而，在原始相互作用中沉积的部分能量可能会以荧光x射线的形式释放，它可以被邻近的探测器元素吸收，如图4,a(8,9)所示。尽管康普顿散射和x射线荧光是不同的物理效应，但它们都导致光子的能量范围不正确，并且可能被多次计算。 电荷共享效应 在硅和镉碲化或镉锌碲化探测器中，探测器元件之间的串扰也可以归因于一种称为电荷共享的效应。如图4,B所示，每个被吸收的x射线光子都会在传感器材料中产生大量的正负电荷。如果光子在两个探测器元件之间的边界附近被吸收，电荷云的一部分可能会延伸到相邻的探测器元件，这可以记录光子能量的一部分。结果是光子被计数两次。 各种各样的串扰在不同的方面降低了图像质量。首先，它们会降低空间分辨率(即模糊图像)，因为它们会导致光子被记录在错误的探测器元件中。其次，它们可能会导致光子被多次计数。这降低了图像的对比度-噪声比(CNR)，因为所有在计数光子数量中引入额外随机性的影响都会产生额外的图像噪声。第三，不同形式的串扰降低了探测器的能量分辨率，降低了能量信息的可靠性，并导致材料选择性图像中的图像噪声增加。 堆积效应 需要一个快速探测器来计数单个光子。每平方毫米每秒有几亿光子撞击探测器，因此传感器材料必须能够快速传输释放的电荷，读出电子必须能够足够快地计算产生的脉冲。对足够快速和稳定的探测器的需求是光子计数CT扫描仪最近才开始用于临床CT剂量水平的原因之一(13)。然而，PCDs广泛应用于PET、SPECT和双能量x线吸收仪，并已被引入一种商业乳房x线成像系统(微剂量;Philips Healthcare, Best，荷兰)，那里的计数率要低得多。如果光子到达得太快，一些由此产生的电脉冲会相互叠加，这种现象被称为脉冲堆积 如果两个连续脉冲几乎同时发生，它们将被记录为一个能量等于两个入射光子能量之和的单个脉冲。如果脉冲到达时间的差异稍微大一些，探测器可能会将它们记录为两个单独的计数，但部分重叠仍然会导致测量光子能量的误差(图5,B)。堆积对图像质量有两种影响。首先，计数损失增加了图像噪声，因为较少的光子有助于测量(14)。第二，能量分辨率下降，类似于相声(14-16)的效果。因为在高计数率下会发生堆积，所以它不会降低图像的所有部分这些影响可以通过设计更小的探测器元件和更快的计数器来最小化。然而，当探测器元件变得更小时，在堆积和电荷共享之间有一个折衷。 由于具有不同能量的光子的加权方式，理想PCD可以产生比理想EID更低的图像噪声。由于EID测量的是吸收的总x射线能量，高能光子对总信号的贡献相对于低能量光子。然而，这种加权并不能产生最佳的CNR，因为在高能量时组织对比度较低。为了优化图像的CNR，可以将最大的权重分配给能量较低、组织间对比度最高的光子，如图7所示。能量分解PCD能够为低能量箱分配更高的权重因子，从而提高CNR(4,18,19)。给予低能量光子更高重量的一个缺点是，由于x射线光谱中低能量部分的组织衰减更加非均匀，因此会导致光束硬化现象的增加(20) 在x射线计算机断层扫描(CT)中，具有不同元素组成的材料可以用CT图像上的相同像素值(即CT数)表示，这取决于材料的质量密度 在双能量CT中，以第二能量获得额外的衰减测量，允许两种材料的区分，这个双能CT，就是加两个能量kev，和能谱CT划分能量箱有所不同。 双能量CT的技术途径 Two Temporally Sequential Scans 两个时间顺序扫描,进行了两次时间顺序扫描，以获取两个管电位处的数据,由于数据不是同时获得的，患者在两次扫描之间发生的运动导致结果图像和材料组成信息的严重退化,后面有一种单轴旋转改进的方法，但是效果应该也不是很好，然后我也没太看懂，尴尬。这个方法可以在任何CT扫描仪上执行(不需要特殊硬件 Rapid Switching of X-Ray Tube Potential x射线管电位的快速切换，允许在低和高管电位下获得交替投影测量，应用主要是骨骼密度测量。然而，在低管电位测量中，管电流不能迅速增加到足够快的程度，从而在低管电位和高管电位数据集中都能达到相当的噪声水平。这种噪音上的差异限制了该技术在骨密度测量之外的应用在连续视图之间切换管电位要求从低到高管电位的转换时间小于一毫秒。此外，过渡必须尽可能突然，以最大限度地分离测量数据的能量，尽管快速调制x射线管电流的困难可能在低能量数据中造成高噪音水平或来自高能量投影的过量剂量。然而，这个问题可以通过对低和高能量投影使用不对称采样来解决。通过这种方式，在不迅速改变管电流的情况下，获得了低能量投影所需的增加管电流-时间积低能量和高能量数据集的近同时数据采集。允许通过使用投影数据或重建图像来实现双能量物质分解算法。减少计算出的“虚拟单能量”图像中的光束硬化现象，需要专门的硬件。能量谱的高重叠 Multilayer Detector 多层探测器就是探测头有两层，里层的获得低能量的信息，外层的获得高能量的信息。低能耗数据收集从前面或内层的探测器层和高能数据收集从后面或外层探测器层(图5)。这类似于多层探测器的使用双能x线摄影(6 - 8)。为了在低和高能量图像中获得相同的噪声，使用了不同的探测器厚度。低能量数据集和高能量数据集的同时数据采集。所有图像数据都以支持特定材料成像的方式获取，但是需要专门的硬件。能量谱的高重叠。低和高能量图像的噪声水平可能不同 Dual x-ray sources双x射线源双源CT是将两个x射线源和两个数据采集系统安装在同一架龙门上，相互垂直放置的CT系统因为两个管同时被激发，原始主光子来自一个管的散射辐射可能被另一个管的探测器探测到，反之亦然。这将降低光谱分离，并要求实现适当的散射校正算法(12)。双源方法的一个优点是能够独立优化每个管-探测器对的光谱过滤，从而增加在特定物质图像中光谱分离和增加信噪比管电流和管过滤可以分别优化每个管电位。相对较低的光谱重叠程度，这提高了材料特定图像的对比噪声比。光束硬化校正应用于图像重建之前，允许在图像域中创建特定材料的图像。需要专门的硬件。在低能和高能数据之间有90度的相移。同时使用这两种x射线源允许散射辐射，其原始的主光子来自一个管被另一个管的探测器检测到，需要专门的散射校正。","path":"2021/01/18/能谱CT物理原理/"},{"title":"匈牙利算法（二分图）","text":"匹配：在图论中，一个匹配（matching）是指一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突），但并非每个图都存在完美匹配。 交替路径：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径称为交替路径。 增广路径：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。 增广路径性质： （1）P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 （2）P经过取反操作可以得到一个更大的匹配M’。 （3）M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法：利用增广路径求二分图的最大匹配算法称作匈牙利算法。（匈牙利数学家Edmonds于1965年提出）。基本思想：通过寻找增广路径，把增广路径中的匹配边和非匹配边的相互交换，这样就会多出一条匹配边，直到找不到增广路径为止。 就是每次从一个未匹配点出发，然后依次经过非匹配边、匹配边、非匹配边，并且途径另一个未匹配点，然后匹配边和非匹配边的相互交换，这样就会多出一个匹配边，直到找不到增广路径。 这是leetcodeLCP 04. 覆盖你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为1 * 2的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。 输入：n, m代表棋盘的大小；broken是一个b * 2的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。 输出：一个整数，代表最多能在棋盘上放的骨牌数。 该题看上去与二分图匹配无关，但其实可以转化成二分图匹配。一个骨牌恰好覆盖两格，而这两格必须是相邻的。因此如果把相邻的两格看成分别属于X、Y两个集合的节点，相邻的节点之间认为有一条（黑色）边相连，放骨牌看做将被覆盖的两格之间的边染成红色；由于一格（一个节点）只能被一个骨牌覆盖（被一条红边连接），那么连接的方式整个就是二分图的一个匹配。如何构建这张图呢？由于相邻的点属于不同的集合，因此仿照国际象棋的棋盘“间隔地”染色就好了。于是，相邻格子之间对应的边连接的都是属于不同集合的节点，相同集合的节点因为对应的不是相邻格子都不直接相连，形成了二分图。最后，能放置骨牌的最大数量就是二分图最大匹配中的边数。 二分图最大匹配可以用匈牙利算法解决，也可以转化成最大流解决，本次使用前者。匈牙利算法的核心操作其实与后者还挺像，后者是寻找增流路径，而前者是寻找一个“交互道路”（节点颜色交替的道路），其实都可以理解为增广道路（augmentation path）。只不过，由于在二分图匹配中一条边要么就是选要么就是不选，相当于是特殊的“流”，0或者1，因此最大流的“退流”操作，被简化为了异或操作。无论是从算 示例 1： 输入：n = 2, m = 3, broken = [[1, 0], [1, 1]]输出：2解释：我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。（见下图）&lt;!—hexoPostRenderEscape:class Solution &#123;public: int row=0,col=0; int grid[10][10]; int erge[100][100]; int matchvi[100]; int belong[100]; int domino(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; broken) &#123; row=n,col=m; int a[4][2]=&#123;1,0,-1,0,0,-1,0,1&#125;; for(auto g: broken) &#123; grid[g[0]][g[1]]=1; &#125; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(grid[i][j]) continue; for(int k=0;k&lt;4;k++)//构造边 &#123; int arow=a[k][0]+i,acol=a[k][1]+j; if(arow&lt;0||arow&gt;=row||acol&lt;0||acol&gt;=col||grid[arow][acol]) continue; // cout&lt;&lt;1; erge[icol+j][arowcol+acol]=erge[arowcol+acol][icol+j]=1; &#125; &#125; &#125; return hug(); &#125; int hug() &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(grid[tmp1][tmp2]) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//为偶数格子跳过，对奇数找匹配&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; memset(matchvi, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, sizeof(matchvi)); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(match(i)) res++; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; match(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//如果是偶数跳过&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((erge[x][i]==&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(matchvi[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) &amp;#123; matchvi[i]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(belong[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;||match(belong[i])) &amp;#123;&lt;span class=&quot;hljs-comment&quot;&gt;//如果i没有确定，或者确定的人可以换&lt;/span&gt; belong[i]=x; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &amp;#125; &amp;#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2021/01/16/二分图_匈牙利算法/"},{"title":"785. 判断二分图（染色法）","text":"一个图是二分图，当且仅当图中不含有奇数环二分图的方法，染色法，就是通过对节点进行着色，算法就是深搜的方法 bool res=true; int sta[105]; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; for(int i=0;i&lt;graph.size();i++) &#123; if(sta[i]==0) paint(i,1,graph); &#125; return res; &#125; void paint(int t,int color,vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123; if(res==false) return ; for(int i=0;i&lt;g[t].size();i++) &#123; if(sta[g[t][i]]==0) &#123; sta[g[t][i]]=-color; paint(g[t][i],-color,g); &#125; else if(sta[g[t][i]]==-color) continue; else &#123; res=false; return ; &#125; &#125; &#125;","path":"2021/01/14/785. 判断二分图/"},{"title":"787. K 站中转内最便宜的航班（bellman-ford）","text":"循环n次遍历所有边u-&gt;v,权w (松弛操作)dist[v]=min(dist[v], dist[u]+w) 应用处理有负权边的图循环次数的含义：循环K次后，表示不超过K条边的最短距离有边数限制的最短路，只能用Bellman-Ford算法，不能用spfa算法如果有负权回路，最短路不一定存在 - Bellman-Ford算法可以求出是否有负环第n循环后，还有更新，说明路径上有n+1个点，也就是存在环，还有更新，说明环是负环循环n次后, 所有的边u-&gt;v,权w满足三角不等式:dist[v]&lt;=dist[u]+wint findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; res(n+1,INF); res[src]=0; for(int i=0;i&lt;=K;i++) &#123; vector&lt;int&gt; tmp(res); for(int j=0;j&lt;flights.size();j++) &#123; if(flights[j][2]+tmp[flights[j][0]]&lt;res[flights[j][1]]) res[flights[j][1]]=flights[j][2]+tmp[flights[j][0]]; &#125; &#125; if(res[dst]==INF) return -1; return res[dst]; &#125;","path":"2021/01/13/787. K 站中转内最便宜的航班/"},{"title":"743. 网络延迟时间（迪杰斯特拉+SPFA+floyd)","text":"有 N 个网络节点，标记为 1 到 N。 给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。 现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。 输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2输出：2 主要就是迪杰斯特拉的代码这个是没有优化的结果，每次选的是距离初始点最小距离的点。集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷for v: 1 ~ nt &lt;- 不在s中的距离最近的点s &lt;- t用t更新其他点的距离朴素的Dijkstra算法往往是稠密图，用邻接矩阵来存储class Solution &#123; public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; vector&lt;vector&lt;int&gt;&gt; mat(N+1,vector&lt;int&gt;(N+1,0x3f3f3f3f)); vector&lt;int&gt; res(N+1,0x3f3f3f3f); vector&lt;int&gt; sta(N+1,0);//值为1点被被选，为0没被选 int result=-1; sta[K]=1; res[K]=0; for(int i=0;i&lt;times.size();i++) &#123; mat[times[i][0]][times[i][1]]=times[i][2]; if(times[i][0]==K) &#123; res[times[i][1]]=times[i][2]; &#125; &#125; // cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; for(int i=0;i&lt;N-1;i++) &#123; int t=-1; for(int j=1;j&lt;=N;j++) &#123; if(sta[j]==0&amp;&amp;(t==-1||res[j]&lt;res[t])) &#123; t=j; &#125; &#125; sta[t]=1; for(int j=1;j&lt;=N;j++) &#123; if(res[t]+mat[t][j]&lt;res[j]) &#123; res[j]=res[t]+mat[t][j]; &#125; &#125; &#125; for(int i=1;i&lt;=N;i++) &#123; if(res[i]==0x3f3f3f3f) return -1; if(i==K) continue; result=max(result,res[i]); &#125; return result; &#125; &#125;; 集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷for v: 1 ~ nt &lt;- 不在s中的 与起始点距离最近的点 ；小顶堆维护 O(logN)s &lt;- t; O(1)用t更新其他点的距离 ; O(mlogN)稀疏图用堆优化版的Dijkstra算法这个是优化之后的，主要是用稀疏图替换邻接矩阵，同时用优先队列替换遍历搜寻最小的边。 int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; stat(N+1,0); vector&lt;int&gt; res(N+1,INF); vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; m(N+1); priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; queue; queue.push(&#123;0,K&#125;); res[K]=0; int result=0; for(int i=0;i&lt;times.size();i++) &#123; m[times[i][0]].push_back(&#123;times[i][2],times[i][1]&#125;); &#125; while(!queue.empty()) &#123; auto tmp=queue.top(); queue.pop(); if(stat[tmp.second]==1) continue; stat[tmp.second]=1; for(auto &amp;p: m[tmp.second]) &#123; if(p.first+tmp.first&lt;res[p.second])//tmp代表我们找到的下一个加入的点，然后找这个点的所有的边来更新 &#123; res[p.second]=p.first+tmp.first; queue.push(&#123;p.first+tmp.first,p.second&#125;); &#125; &#125; &#125; for(int i=1;i&lt;=N;i++) &#123; if(res[i]==INF) return -1; if(i==K) continue; result=max(result,res[i]); &#125; return result; &#125; SPFA算法 首先相比Dijkstra算法，SPFA可以处理带有负权变的图。（个人认为原因是SPFA在进行松弛操作时就是那个更新距离的地方可以对某一条边重复进行松弛，因为可能某一个点会被多次加入队列，这个可以这么理解，如果在没有负边的情况下松弛一次就是说一条最短路径最多只能经过松弛的这个点一次，这个在没有负边的情况下是显而易见的，当有负边的情况下，经过这个点多次就可能获得更小的最短路径。当我们松弛了某个点超过N次，就可以认为出现了负环，为什么是超过N次呢，极端情况下如果没有负环那么每次加入一次点我们都可以认为这个点与其他点连成的一条边加入最短路径中，如果加了N-1条边还不是最短路径，到第n次那肯定就是有负环了。（大家都写的大于N次），我个人交代码试了以下，好像到n就可以了，但是保险还是大于N更好） 实现方法： 建立一个队列，初始时队列里只有起始点，再建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点作为起始点去刷新到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。 判断有无负环： 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图，但是可以判断是否出现负权环）,这一点和ford算法是一样的，超过N次松弛就代表出现的最短路径长度是大于等于N的，这样的简单路径是不存在的。 我们可以看出代码上其实是和迪杰斯特拉算法很像的。&lt;!—hexoPostRenderEscape: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; stat(N+1,0); vector&lt;int&gt; res(N+1,INF); vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; m(N+1);//距离队列 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; queue;//刷新队列 queue.push(&#123;0,K&#125;); res[K]=0; stat[K]=1; int result=0; for(int i=0;i&lt;times.size();i++) &#123; m[times[i][0]].push_back(&#123;times[i][2],times[i][1]&#125;); &#125; while(!queue.empty()) &#123; auto tmp=queue.top(); queue.pop(); stat[K]=0; // if(stat[tmp.second]==1) // continue; // stat[tmp.second]=1; for(auto &amp;p: m[tmp.second]) &#123; if(p.first+tmp.first&lt;res[p.second])//first 距离，second 目的点 &#123; res[p.second]=p.first+tmp.first; if(stat[K]==0) &#123; queue.push(&#123;p.first+tmp.first,p.second&#125;); stat[p.second]=1; &#125; &amp;#125; &amp;#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=N;i++) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(res[i]==INF) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==K) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; result=max(result,res[i]); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; floyd算法 这个也是求最短路径的算法，是求任意两点之间的最短路径，可以有负边，时间复杂度为O(N^3),空间复杂度为O(N^2),算法主要是考虑的是从i到j经过的点的号不超过k的路径dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j]); 这个可以通过动态规划进行空间优化。//主要的代码如下 for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125; &#125;","path":"2021/01/13/743. 网络延迟时间/"},{"title":"177. 第N高的薪水","text":"编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 +——+————+| Id | Salary |+——+————+| 1 | 100 || 2 | 200 || 3 | 300 |+——+————+例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。 +————————————+| getNthHighestSalary(2) |+————————————+| 200 |+————————————+ SELECT e1.salary FROM employee e1 JOIN employee e2 ON e1.salary &lt;= e2.salary GROUP BY e1.salary HAVING count(DISTINCT e2.salary) = N","path":"2021/01/04/mysql177. 第N高的薪水/"},{"title":"601. 体育馆的人流量","text":"表：Stadium+———————-+————-+| Column Name | Type |+———————-+————-+| id | int || visit_date | date || people | int |+———————-+————-+visit_date 是表的主键每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)每天只有一行记录，日期随着 id 的增加而增加 编写一个 SQL 查询以找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录。 返回按 visit_date 升序排列的结果表。 查询结果格式如下所示。 Stadium table:+———+——————+—————-+| id | visit_date | people |+———+——————+—————-+| 1 | 2017-01-01 | 10 || 2 | 2017-01-02 | 109 || 3 | 2017-01-03 | 150 || 4 | 2017-01-04 | 99 || 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-09 | 188 |+———+——————+—————-+ Result table:+———+——————+—————-+| id | visit_date | people |+———+——————+—————-+| 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-09 | 188 |+———+——————+—————-+id 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。 select distinct t1.* from Stadium t1,Stadium t2, Stadium t3 where t1.people&gt;=100 and t2.people&gt;=100 and t3.people&gt;=100 and ( (t1.id=t2.id-1 and t2.id=t3.id-1) or (t1.id=t2.id+1 and t2.id=t3.id-2) or (t1.id=t2.id+1 and t2.id=t3.id+1)) order by id;","path":"2021/01/04/mysql601. 体育馆的人流量/"},{"title":"626. 换座位","text":"小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。 其中纵列的 id 是连续递增的 小美想改变相邻俩学生的座位。 你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ 示例： +————-+————-+| id | student |+————-+————-+| 1 | Abbot || 2 | Doris || 3 | Emerson || 4 | Green || 5 | Jeames |+————-+————-+假如数据输入的是上表，则输出结果如下： +————-+————-+| id | student |+————-+————-+| 1 | Doris || 2 | Abbot || 3 | Green || 4 | Emerson || 5 | Jeames |+————-+————-+注意： 如果学生人数是奇数，则不需要改变最后一个同学的座位。 我第一次发现mysql还能这样写判断，学习一个。select if(id%2=0, id-1, if(id=(select count(*) from seat), id, id+1 ))as id,student from seat order by id;","path":"2021/01/04/mysql626. 换座位/"},{"title":"886. 可能的二分法（二分图+染色法）","text":"染色，一个染色成-1，一个染色成1.，出现冲突就false,否则为true。 我之前只记录单向边，然后dfs中间也没判断，然后就有样例一直过不了，很奇怪。class Solution &#123; bool ans = true; public: bool possibleBipartition(int N, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) &#123; if(dislikes.size() &lt;= 2) return true; vector&lt;int&gt; color(N+1, 0); vector&lt;vector&lt;int&gt;&gt; link(N+1); for(auto&amp; d : dislikes)//建图 &#123; link[d[0]].push_back(d[1]); link[d[1]].push_back(d[0]);//这里反向的也要选择不然容易出错 &#125; for(int i = 1; i &lt;= N; i++) &#123; if(color[i] == 0&amp;&amp;link[i].size()!=0)//未着色的 &#123; color[i] = 1;//着色为1 dfs(link,i, 1, color); if(!ans) return false; &#125; &#125; return true; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; link,int id, int col, vector&lt;int&gt; &amp;color) &#123; if(!ans) return; int nextcol = -col;//跟我相连的(不喜欢的人)颜色相反 for(int i=0;i&lt;link[id].size();i++) &#123; if(color[link[id][i]] == col)//颜色相同，出错 ans = false; if(color[link[id][i]] == 0)//没有访问过的，继续着色 &#123; color[link[id][i]] = nextcol; dfs(link,link[id][i], nextcol, color); &#125; &#125; &#125; &#125;;","path":"2020/12/24/886. 可能的二分法/"},{"title":"127. 单词接龙","text":"我一开始用的dfs，然后超时了，剪支了还是超时，写普通的广度优先搜索还是超时，这个是双向的bfs. 具体地，可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 it、ht、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。 最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。 class Solution &#123; public: unordered_map&lt;string, int&gt; wordId; vector&lt;vector&lt;int&gt;&gt; link; int nodeNum = 0; void addword(string &amp; s) &#123; if(!wordId.count(s)) &#123; wordId[s]=nodeNum++; link.emplace_back(); &#125; &#125; void geneword(string &amp; s) &#123; addword(s); int n1=wordId[s]; int len=s.size(); for(char&amp; it : s) &#123; char a=it; it=&#x27;*&#x27;; addword(s); int n2=wordId[s]; it=a; // cout&lt;&lt;1; link[n1].push_back(n2); link[n2].push_back(n1); // cout&lt;&lt;2; &#125; &#125; int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; for(auto &amp; word : wordList) &#123; geneword(word); &#125; geneword(beginWord); if(!wordId.count(endWord)) return 0; int endnum=wordId[endWord]; int beginnum=wordId[beginWord]; queue&lt;int&gt; qbegin; queue&lt;int&gt; qend; qbegin.push(beginnum); qend.push(endnum); vector&lt;int&gt; disbegin(nodeNum+2,INT_MAX); vector&lt;int&gt; disend(nodeNum+2,INT_MAX); disbegin[beginnum]=0; disend[endnum]=0; while(!qbegin.empty()&amp;&amp;!qend.empty()) &#123; int beginlen=qbegin.size(); for(int i=0;i&lt;beginlen;i++) &#123; int w=qbegin.front(); qbegin.pop(); if(disend[w]!=INT_MAX) return (disend[w]+disend[w])/2+1; for(int j=0;j&lt;link[w].size();j++) &#123; if(disbegin[link[w][j]]==INT_MAX) &#123; qbegin.push(link[w][j]); disbegin[link[w][j]]=disbegin[w]+1; &#125; &#125; &#125; int endlen=qend.size(); for(int i=0;i&lt;endlen;i++) &#123; int w=qend.front(); qend.pop(); if(disbegin[w]!=INT_MAX) &#123; return (disend[w]+disend[w])/2+1; &#125; for(int j=0;j&lt;link[w].size();j++) &#123; if(disend[link[w][j]]==INT_MAX) &#123; qend.push(link[w][j]); disend[link[w][j]]=disend[w]+1; &#125; &#125; &#125; &#125; return 0; &#125; &#125;;","path":"2020/12/24/127. 单词接龙/"},{"title":"1293. 网格中的最短路径(状压dp+记忆化搜索）","text":"状态空间搜索解题模板class Solution &#123; public: struct State &#123; int x,y; int r; State(int x1,int y1,int r1) &#123; x=x1; y=y1; r=r1; &#125; &#125;; int dx[4]=&#123;1,0,-1,0&#125;; int dy[4]=&#123;0,1,0,-1&#125;; int shortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; g, int k) &#123; int m=g.size(); int n=g[0].size(); if(k&gt;=m+n-3) return m+n-2; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(m, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(k + 1, 0))); queue&lt;State&gt; Q; Q.emplace(0, 0, k); int step = 0; while(!Q.empty()) &#123; int s = Q.size(); while(s--) &#123; auto p = Q.front(); Q.pop(); int x = p.x, y = p.y; int r = p.r; if(x == m - 1 &amp;&amp; y == n - 1 &amp;&amp; r &gt;= 0) return step; if(visited[x][y][r] == 1) continue; visited[x][y][r] = 1; for(int k = 0; k &lt; 4; k++) &#123; if(x + dx[k] &gt;= 0 &amp;&amp; x + dx[k] &lt; m &amp;&amp; y + dy[k] &gt;= 0 &amp;&amp; y + dy[k] &lt; n) &#123; if(g[x + dx[k]][y + dy[k]] == 1 &amp;&amp; r &gt;= 1) Q.emplace(x + dx[k], y + dy[k], r - 1); else if(g[x + dx[k]][y + dy[k]] == 0) Q.emplace(x + dx[k], y + dy[k], r); &#125; &#125; &#125; step++; &#125; return -1; &#125; &#125;;","path":"2020/11/02/1293. 网格中的最短路径/"},{"title":"901. 股票价格跨度","text":"答案的题解用的是单调栈我用的不是，但是总体来说也是dp的方法，速度好像还快一点的，击败了99.8%。 class StockSpanner &#123; public: vector&lt;int&gt; num; vector&lt;int&gt; res; StockSpanner() &#123; num.clear(); res.clear(); num.push_back(-1); res.push_back(0); &#125; int next(int price) &#123; int len=num.size(); int top=num[len-1]; if(top&lt;=price) &#123; int tmp=0;//最后的结果 int p=len-1;//最后的位置 while(top&lt;=price&amp;&amp;p!=0) &#123; tmp+=res[p]; p=p-res[p]; top=num[p]; &#125; num.push_back(price); res.push_back(tmp+1); return tmp+1; &#125; else &#123; num.push_back(price); res.push_back(1); return 1; &#125; &#125; &#125;;","path":"2020/11/02/901. 股票价格跨度/"},{"title":"576. 出界的路径数（记忆化搜索）","text":"class Solution &#123; public: long res[55][55][55]; int findPaths(int m, int n, int N, int i, int j) &#123; res[0][i][j]=1; int mod = 1000000007; for(int num=1;num&lt;N;num++) &#123; for(int row=0;row&lt;m;row++) &#123; for(int col=0;col&lt;n;col++) &#123; if(row-1&gt;=0) res[num][row][col]=(res[num-1][row-1][col]+res[num][row][col])%(mod); if(row+1&lt;m) res[num][row][col]=(res[num-1][row+1][col]+res[num][row][col])%(mod); if(col-1&gt;=0) res[num][row][col]=(res[num-1][row][col-1]+res[num][row][col])%(mod); if(col+1&lt;n) res[num][row][col]=(res[num-1][row][col+1]+res[num][row][col])%(mod); &#125; &#125; &#125; long result=0; for(int num=0;num&lt;N;num++) &#123; for(int row=0;row&lt;m;row++) &#123; result+=res[num][row][0]; result%=mod; result+=res[num][row][n-1]; result%=mod; &#125; for(int col=0;col&lt;n;col++) &#123; result+=res[num][0][col]; result%=mod; result+=res[num][m-1][col]; result%=mod; &#125; // cout&lt;&lt;result&lt;&lt;endl; &#125; return int(result); &#125; &#125;;","path":"2020/11/02/576. 出界的路径数/"},{"title":"LeetCode 794. Valid Tic-Tac-Toe State (medium)（ 博弈dp）","text":"因为X先下，所以如果X和O的数目关系要么相等，要么X比O多1，只有这两种关系，其次再判断如果X已经赢了，O没法下，此时O的数目只能比X小1，或者O赢了，X的数目只能和O一样。bool check(vector&lt;string&gt;&amp; board,char key) &#123; if(board[0][0]==board[0][1]&amp;&amp;board[0][1]==board[0][2]&amp;&amp;board[0][2]==key)return true; if(board[2][0]==board[2][1]&amp;&amp;board[2][1]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][0]==board[1][0]&amp;&amp;board[1][0]==board[2][0]&amp;&amp;board[2][0]==key)return true; if(board[0][2]==board[1][2]&amp;&amp;board[1][2]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][0]==board[1][1]&amp;&amp;board[1][1]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][2]==board[1][1]&amp;&amp;board[1][1]==board[2][0]&amp;&amp;board[2][0]==key)return true; return false; &#125; bool validTicTacToe(vector&lt;string&gt;&amp; board) &#123; int ansX=0,ansO=0; for(int i=0;i&lt;3;i++) &#123; for(int j=0;j&lt;3;j++) &#123; if(board[i][j]==&#x27;X&#x27;) ansX++; else if(board[i][j]==&#x27;O&#x27;) ansO++; &#125; &#125; if(ansX&lt;ansO)return false; if(ansX-ansO&gt;1)return false; if(check(board,&#x27;X&#x27;)&amp;&amp;ansX==ansO)return false; if(check(board,&#x27;O&#x27;)&amp;&amp;ansX!=ansO)return false; return true; &#125;","path":"2020/11/02/LeetCode 794. 有效的井字游戏/"},{"title":"1349. 参加考试的最大学生数","text":"方法就是每次求前n排的人数和前n-1排的人数的关系，重点在于相邻两排斜着的人是否都有，一排是否有相邻的，是否坐在坏的座位上。一一排除。遍历，所有的状态，一排最多2^8个状态。 class Solution &#123; public: int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) &#123; int m=seats.size(); int n=seats[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(1&lt;&lt;n)); for(int i=1;i&lt;=m;i++) &#123; for(int j=0;j&lt;(1&lt;&lt;n);j++) &#123; bitset&lt;8&gt; bs(j); bool state=true; for(int k=0;k&lt;n;k++) &#123; if((seats[i-1][k]==&#x27;#&#x27;&amp;&amp;bs[k])||(k&lt;n-1&amp;&amp;bs[k]&amp;&amp;bs[k+1])) &#123; state=false; break; &#125; &#125; if(state==false) &#123; dp[i][j]=-1; continue; &#125; for(int k=0;k&lt;(1&lt;&lt;n);k++) &#123; if(dp[i-1][k]==-1) &#123; continue; &#125; bitset&lt;8&gt; lastbs(k); bool state1=true; for(int r=0;r&lt;n;r++) &#123; if(lastbs[r]&amp;&amp;(r&gt;0&amp;&amp;bs[r-1]||r&lt;n-1&amp;&amp;bs[r+1])) &#123; state1=false; break; &#125; &#125; if(state1==true) &#123; dp[i][j]=max(dp[i][j],dp[i-1][k]+int(bs.count())); &#125; &#125; &#125; &#125; int result=0; for(int i=0;i&lt;(1&lt;&lt;n);i++) &#123; result=max(result,dp[m][i]); &#125; return result; &#125; &#125;;","path":"2020/11/02/1349. 参加考试的最大学生数/"},{"title":"1125. 最小的必要团队","text":"这个题一开始不会做，做出来一直超时，看的别人的思路先把某些技能树是别人子集的人去掉，然后做dp。class Solution &#123; public: vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123; int bitmap=0;//代表技能，比如111这种 for(int i=0;i&lt;req_skills.size();i++) &#123; bitmap=bitmap|(1&lt;&lt;i); &#125; vector&lt;pair&lt;int,int&gt;&gt; peo2map; for(int i=0;i&lt;people.size();i++) &#123; int tmp=0; for(int j=0;j&lt;people[i].size();j++) &#123; for(int k=0;k&lt;req_skills.size();k++) &#123; if(people[i][j]==req_skills[k]) &#123; tmp=tmp|(1&lt;&lt;k); break; &#125; &#125; &#125; peo2map.push_back(&#123;i,tmp&#125;); &#125; vector&lt;bool&gt; issame(peo2map.size(),0); for(int i=0;i&lt;issame.size();i++) &#123; for(int j=i+1;j&lt;issame.size();j++) &#123; if((peo2map[i].second|peo2map[j].second)==peo2map[i].second) &#123; issame[j]=1; &#125; else if((peo2map[i].second|peo2map[j].second)==peo2map[j].second) &#123; issame[i]=1; &#125; &#125; &#125; decltype(peo2map) peo2map1; for(int i=0;i&lt;peo2map.size();i++) &#123; if(issame[i]==0) &#123; peo2map1.push_back(peo2map[i]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt;res(bitmap+1);//每一个数组代表一组技能 vector&lt;int&gt;skill(bitmap+1,-1);//记录每种技能组合对应的人数，最低位表示没有技能 skill[0]=0;//位图为00000..的技能被获得，某个技能树需要的人数 for(int i=0;i&lt;peo2map1.size();i++) &#123; for(int j=0;j&lt;=bitmap;j++) &#123; if(skill[j]==-1) continue; int newskill=(peo2map1[i].second)|j; if(skill[newskill]==-1||skill[newskill]&gt;skill[j]+1) &#123; skill[newskill]=skill[j]+1;//从j那边技能树走人数会更少 res[newskill]=res[j]; res[newskill].push_back(peo2map1[i].first); &#125; &#125; &#125; return res[bitmap]; &#125; &#125;;","path":"2020/11/02/1125. 最小的必要团队/"},{"title":"数据库的三级模式：外模式、模式和内模式","text":"一、模式（Schema） 定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 理解： ① 一个数据库只有一个模式； ② 是数据库数据在逻辑级上的视图； ③ 数据库模式以某一种数据模型为基础； ④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。 二、外模式（External Schema） 定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。 三、内模式（Internal Schema） 定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。 理解： ① 一个数据库只有一个内模式； ② 一个表可能由多个文件组成，如：数据文件、索引文件。 它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法 其目的有： ① 为了减少数据冗余，实现数据共享； ② 为了提高存取效率，改善性能。","path":"2020/10/13/数据库的三级模式：外模式、模式和内模式/"},{"title":"MySQL - ON & WHERE 条件区别和执行顺序","text":"MySQL - ON &amp; WHERE 条件区别和执行顺序on是在生成临时表的时候使用的条件，不管on的条件是否起到作用，都会返回左表 (table_name1) 的行。where则是在生成临时表之后使用的条件，此时已经不管是否使用了left join了，只要条件不为真的行，全部过滤掉。 内连接，外连接，笛卡尔积连接自然连接和等值连接1、自然连接(Naturaljoin)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。 2、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。 3、自然连接与等值连接 在连接运算当中，一种最常用的连接是自然连接。 所谓自然连接就是在等值连接的情况下，当连接属性X与Y具有相同属性组时，把在连接结果中重复的属性列去掉。 自然连接是在广义笛卡尔积R×S中选出同名属性上符合相等条件元组，再进行投影，去掉重复的同名属性，组成新的关系。 4、等值连接与自然连接的区别： 1）等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。 2）等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。 5、事实上，我们一般使用的都是自然连接。 select FirstName, LastName, City, State from Person left join Address on Person.PersonId =Address.PersonId; 很纠结的一点是为啥这个on不能是where，然后才发现其实因为是因为在address没有的情况下Address.PersonId;这个本身就是不对的，on因为是就算为空也会生成，所以是对的。","path":"2020/10/13/MySQL - ON & WHERE 条件区别和执行顺序/"},{"title":"486. 预测赢家","text":"我考虑的是在i，j区间中获胜的人的分数，题解考虑的是分数差值，更好一点。bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;vector&lt;int&gt; &gt; sum(len,vector&lt;int&gt;(len,0)); vector&lt;vector&lt;int&gt; &gt; res(len,vector&lt;int&gt;(len,0)); for(int i=0;i&lt;len;i++) &#123; sum[i][i]=nums[i]; res[i][i]=nums[i]; &#125; for(int i=2;i&lt;=len;i++)//长度 &#123; for(int j=0;i+j-1&lt;len;j++)//左边起始位置 &#123; sum[j][i+j-1]=sum[j+1][i+j-1]+nums[j]; &#125; &#125; for(int i=2;i&lt;=len;i++)//长度 &#123; for(int j=0;i+j-1&lt;len;j++)//左边起始位置 &#123; res[j][i+j-1]=max(sum[j+1][i+j-1]-res[j+1][i+j-1]+nums[j],sum[j][i+j-2]-res[j][i+j-2]+nums[i+j-1]); &#125; &#125; if(res[0][len-1]&gt;=(sum[0][len-1]/2.0)) return true; else return false; &#125;","path":"2020/10/07/486. 预测赢家/"},{"title":"837. 新21点","text":"我们以 N = 21，K = 17，W = 10 来思考。因为我们的结果是求手上点数为 0 时，赢得游戏的概率。 所以我们需要从后往前逆向求，比如在这里，我们就需要知道在手上点数为 16 时赢得游戏的概率，从而在往前求手上点数为 15 时的概率，最后求出手上点数为 0 时的赢得游戏的概率。 那我们怎么求点数为 16 时赢得游戏的概率呢？ 这里我们知道手上点数为 17 时赢得游戏的概率为 100%，所以 K ~ N 区间的赢得游戏的概率为 100%，超过 N 时赢得游戏概率为 0，那么手上点数为 16 时，赢得游戏的概率就是 手上点数为 17 ~ 17 + 10 - 1 的赢得游戏的概率和除以 W，即用一个表达式为 win[16] = sum(win[17] ~ win[26]) / W。 这里我们可以以 O(1) 的时间复杂度计算 sum(win[i + 1] ~ win[i + W - 1])。我们用一个sumProb = sum(win[17] ~ win[26])然后每次计算win[i] = sumProb / WsumProb = sumProb + win[i] - win[i + W] 这个题目如果用简单的dp会超时，需要从后向前dp，进行优化，考虑差分。double new21Game(int N, int K, int W) &#123; vector&lt;double&gt; res(K+W+1,0); res[0]=1; for(int i=K;i&lt;=N;i++) &#123; res[i]=1; &#125; double tmp=N-K+1; for(int i=K-1;i&gt;=0;i--) &#123; res[i]=tmp/W; tmp=tmp-res[i + W] + res[i]; &#125; return res[0]; &#125;","path":"2020/10/06/837. 新21点/"},{"title":"808. 分汤","text":"即使将 N 除以 25 之后，仍然没法在短时间内得到答案，因此我们需要尝试一些别的思路。可以发现，分配操作有 (4, 0)，(3, 1)，(2, 2) 和 (1, 3) 四种，那么在一次分配中，汤 A 平均会少 (4 + 3 + 2 + 1) / 4 = 2.5 份，汤 B 平均会少 (0 + 1 + 2 + 3) / 4 = 1.5 份。因此在 N 非常大的时候，A 会有很大的概率比 B 先分配完，所有概率应该非常接近 1。事实上，当 N &gt;= 500 25 时，所求概率已经大于 0.999999 了（可以通过上面的动态规划方法求出），它和 1 的误差（无论是绝对误差还是相对误差）都小于 10^-6。因此在 N &gt;= 500 25 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。 double soupServings(int N) &#123; N=N/25+(N%25&gt;0?1:0); if(N&gt;=500*25) return double(1); vector&lt;vector&lt;double&gt; &gt; res(N+1,vector&lt;double&gt;(N+1,0)); for(int i=1;i&lt;=N;i++) &#123; res[0][i]=1.0; &#125; res[0][0]=0.5; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=N;j++) &#123; double tmp=res[(i-4)&lt;0?0:(i-4)][j]+res[(i-3)&lt;0?0:(i-3)][(j-1)&lt;0?0:(j-1)]; double tmp1=res[(i-2)&lt;0?0:(i-2)][(j-2)&lt;0?0:(j-2)]+res[(i-1)&lt;0?0:(i-1)][(j-3)&lt;0?0:(j-3)]; res[i][j]=0.25*(tmp+tmp1); &#125; &#125; return res[N][N]; &#125;","path":"2020/10/06/808. 分汤/"},{"title":"auto和decltype之间的区别","text":"auto与decltype区别：1 auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。2 编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。3 decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。关于详细的顶层const和底层const可以参考 详细的例子参考 关于decltype和函数指针迷惑,函数指针参考","path":"2020/08/13/auto和decltype之间的区别/"},{"title":"拉东变换","text":"","path":"2020/08/04/test/"},{"title":"拉东变换","text":"x射线在穿过人体传播的时候，它的衰减是这样的 $I=I_0 e^{-ux}$","path":"2020/08/03/拉东变换/"},{"title":"医学图像相关内容","text":"ASTRA Toolbox一个python的库，包含很多的医学图像的算法，比如fbp，sart，生成投影数据等问题。 还可以进行gpu加速，可以学习学习。","path":"2020/07/29/医学图像相关内容/"},{"title":"memset赋值问题","text":"在memset的赋值问题中，是按字节赋值的，如果是menset(array,1,n*sizeof(int));结果不是每个int变成1，而是变成很大的数，它是将int的每一个字节赋值为1，因此最好只在赋值为0的时候使用。","path":"2020/07/29/memset赋值问题/"},{"title":"状压dp","text":"状压dp状态压缩动态规划，就是我们俗称的状压DP，是利用计算机二进制的性质来描述状态的一种DP方式。 很多棋盘问题都运用到了状压，同时，状压也很经常和BFS及DP连用。 状压dp其实就是将状态压缩成2进制来保存 其特征就是看起来有点像搜索，每个格子的状态只有1或0 ，是另一类非常典型的动态规划 举个例子：有一个大小为n*n的农田，我们可以在任意处种田，现在来描述一下某一行的某种状态： 设n = 9； 有二进制数 100011011（九位），每一位表示该农田是否被占用，1表示用了，0表示没用，这样一种状态就被我们表示出来了。这表示的是一中状态，表示的是在这个状态下每个东西的情况。如果要用数组来表示，必须用很多空间表示这一个状态的集合。而在现实因为每个东西状态只有01 所以我们用一个数来表示这种集合状态。 leetcode 464. 我能赢吗采用状压dp来压缩状态。对于每次回溯来说，如果本次(第一个人)选择数字i达到了desiredTotal，说明当前状态下能赢，即返回true，又或者下一次(另一个人)输了，那么说明本次选择必赢。 用dp数组索引表示所选整数的累加和减1，而这个累加和又能体现整数元素选取的情况。dp数组的索引对应整数累加和状态，该整数累加和状态对应组合状态；dp数组元素的值表示整数组合状态对应的结果，为true表示该组合状态已存在并且能赢，直接返回；为false表示该组合状态已存在并且输了，直接返回；为空表示还没出现这种整数组合状态，是一个新状态，需要进行递归计算。 class Solution &#123; public: bool canIWin(int maxChoosableInteger, int desiredTotal) &#123; if(maxChoosableInteger&gt;=desiredTotal) return true; if((maxChoosableInteger+1)*maxChoosableInteger/2&lt;desiredTotal) return false; int *dp=new int[1&lt;&lt;(maxChoosableInteger)];//减法优先级更高 for(int i=0;i&lt;1&lt;&lt;(maxChoosableInteger);i++) dp[i]=-1; bool res= dfs(maxChoosableInteger,desiredTotal,dp,0); return res; &#125; bool dfs(int maxChoosableInteger,int desiredTotal,int *p,int state) &#123; if(p[state]!=-1) return p[state]; for(int i=1;i&lt;=maxChoosableInteger;i++) &#123; int s=1&lt;&lt;i-1; if((s&amp;state)==0)//位运算的优先级很低 &#123; if(desiredTotal-i&lt;=0||!dfs(maxChoosableInteger,desiredTotal-i,p,s|state)) &#123; p[state]=1; return true; &#125; &#125; &#125; p[state]=0; return false; &#125; &#125;; 526. 优美的排列这个题目使用两个数字来记录。第一个是代表哪些数字已经被使用，状态压缩记录，另一个代表的是这是第几个数字。 int countArrangement(int N) &#123; int *dp=new int[1&lt;&lt;N]; int res=0; for(int i=0;i&lt;(1&lt;&lt;N);i++) dp[i]=-1; res=dfs(N,dp,0,1); delete []dp; return res; &#125; int dfs(int N,int *dp,int state,int p) &#123; if(dp[state]!=-1) return dp[state]; int tmp=0; for(int i=1;i&lt;=N;i++) &#123; int s=1&lt;&lt;i-1; if((s&amp;state)==0) &#123; if((i%p==0||p%i==0)) &#123; if(p==N) return 1; tmp+=dfs(N,dp,state|s,p+1); &#125; &#125; &#125; // cout&lt;&lt;tmp&lt;&lt;endl; return tmp; &#125; 935. 骑士拨号器这道题目看起来不像是状压dp，就是让上一个情况递推到下一个，然后同时记录中间的结果。class Solution &#123; public: int a[10][5005]; const int C=pow(10,9)+7; int knightDialer(int N) &#123; vector&lt;int&gt; t(3,-1); vector&lt;vector&lt;int&gt; &gt; b(10,t); b[0][0]=4;b[0][1]=6; b[1][0]=6;b[1][1]=8; b[2][0]=7;b[2][1]=9; b[3][0]=4;b[3][1]=8; b[4][0]=3;b[4][1]=9;b[4][2]=0; b[6][0]=1;b[6][1]=7;b[6][2]=0; b[7][0]=2;b[7][1]=6; b[8][0]=3;b[8][1]=1; b[9][0]=2;b[9][1]=4; int res=0; for(int i=0;i&lt;10;i++) &#123; res=(fun(i,N-1,b)+res)%C; &#125; return res; &#125; int fun(int i,int N,vector&lt;vector&lt;int&gt;&gt; &amp;b) &#123; if(a[i][N]!=0) return a[i][N]; if(N==0) return 1; int tmp1=0; for(int t=0;t&lt;3;t++) &#123; int tmp=b[i][t]; if(tmp!=-1) tmp1=(fun(tmp,N-1,b)%C+tmp1%C)%C; &#125; a[i][N]=tmp1; return tmp1%C; &#125; &#125;; class Solution &#123; public: int a[8][1&lt;&lt;8]; int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) &#123; int len=seats.size(); if(len&lt;=0||seats[0].size()&lt;=0) return 0; int len1=seats[0].size(); vector&lt;int&gt; t(len1,-1); vector&lt;vector&lt;int&gt; &gt; tt(len,t);//这一行，以及上一行的状态 dfs(0,dp,0，0)//第几行，这一行的状态，由于只会往上和左右扩散，所以可以从一个方向走。 return res; &#125; int dfs(int len,vector&lt;vector&lt;int&gt; &gt; dp,int state，int state1) &#123; if(dp[len][state][state1]!=-1) return dp[len][state][state1]; int tmp=0; int rr=0; for(int i=0;i&lt;n;i++) &#123; int s1=state; int s2=state1; tmp=1&lt;&lt;i; if((i&amp;state)==0) &#123; s1=s1|tmp; if(i-1&gt;=0) &#123; s1=s1|(1&lt;&lt;i-1); s2=s2|(1&lt;&lt;i-1); &#125; if(i&lt;=len1) &#123; s1=s1|(1&lt;&lt;i+1); s2=s2|(1&lt;&lt;i+1); &#125; rr=max(rr,dfs(len,dp,s1,s2)); &#125; &#125; dp[len][s1][s2]=rr; return rr; &#125; &#125;;","path":"2020/07/29/状压dp/"},{"title":"树形dp","text":"树形dp543. 二叉树的直径这里就是对于每棵树判断两种情况，是选择自己作为深度，祖宗节点作为根节点穿过最长，还是就是自己作为根节点穿过最长呢。于是只需要求子节点的最长的节点长度，然后最后把节点长度减一就可以了。 class Solution &#123; public: int res=0; int dfs(TreeNode* root) &#123; if(root==nullptr) return 0; int l=dfs(root-&gt;left); int r=dfs(root-&gt;right); res=max(res,l+r+1); return max(l,r)+1; &#125; int diameterOfBinaryTree(TreeNode* root) &#123; if(root==nullptr) return 0; int a=dfs(root); return res-1; &#125; &#125;; LeetCode 337. House Robber III (medium)这个在打家劫舍系列里面，动态规划里面，这里就不重复写了。 124. 二叉树中的最大路径和这个题目的思路主要是就是我们在每个经过的路径肯定有一个最高的节点。如果自己这个节点就是最高的节点。那么就是比较结果和左子树加右子树加节点的值。这个地方要注意 一个节点的情况实际上是已经包含的了。 接下来就是两个节点的情况。左子树或者右子树，取大于0 的最大值。然后加上节点值返回。 一开始我不理解三个节点的情况，两个节点的情况，一个节点的情况的区别，有可能还有负数，我比较混乱，所以就写得很繁琐，都列举出来了。 较繁琐代码，可以参考。击败97%&lt;!—hexoPostRenderEscape:class Solution &#123;public: int res=0; int maxval=-0x7fffffff-1; int dfs(TreeNode* root) &#123; if(root==nullptr) &#123; return 0; &#125; if(root-&gt;val&gt;maxval) maxval=root-&gt;val; int L=dfs(root-&gt;left); int R=dfs(root-&gt;right); if(L&lt;0) &#123; if(R&lt;0) &#123; res=max(res,root-&gt;val); return root-&gt;val&gt;0?root-&gt;val:0; &#125; else &#123; res= max(res,R+max(0,root-&gt;val)); return R+root-&gt;val&gt;0?R+root-&gt;val:0; &#125; &#125; else &#123; if(R&lt;0) &#123; res= max(res,L+max(0,root-&gt;val)); return L+root-&gt;val&gt;0?L+root-&gt;val:0; &#125; else &#123; if(root-&gt;val&gt;=0||root-&gt;val+L&gt;0||root-&gt;val+R&gt;0) res=max(res,L+R+root-&gt;val); else res=max(res,max(L,R)); int tmp=max(R,L)+root-&gt;val; return tmp&gt;0?tmp:0; &#125; &#125; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; maxPathSum(&lt;span class=&quot;hljs-type&quot;&gt;TreeNode&lt;/span&gt;* root) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a=dfs(root); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(maxval&amp;lt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) return maxval; return res; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 简化代码。int res=-0x7fffffff-1; int dfs(TreeNode* root) &#123; if(root==nullptr) &#123; return 0; &#125; int L=dfs(root-&gt;left); int R=dfs(root-&gt;right); int l=max(0,L); int r=max(0,R); res=max(res,r+l+root-&gt;val); return max(l,r)+root-&gt;val; &#125; int maxPathSum(TreeNode* root) &#123; dfs(root); return res; &#125; 代码差不多只是稍微简化了一点点。也是97% LeetCode 1245. Tree Diameter这道题是被锁住的。 题目描述给定一棵无向树，返回它的直径：树中最长路径的 边 的数量。 树用一个数组给出，数组为 edges[i] = [u, v]，每个元素代表一条双向边连接结点 u 和 v。每个结点的编号为 {0, 1, …, edges.length}。 样例 输入：edges = [[0,1],[0,2]]输出：2解释：这棵树上最长的路径是 1 - 0 - 2，边数为 2。 输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]输出：4解释：这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。限制0 &lt;= edges.length &lt; 10^4edges[i][0] != edges[i][1]0 &lt;= edges[i][j] &lt;= edges.lengthedges 会形成一棵无向树。 遇到树的题目，多数要考虑到使用dfs或者bfs来解题。本题也不例外，从任意一点开始dfs整棵树，对于任意当前节点，它能组成的最大边长应该是从自身出发的所有路径中最长两条路径长度的和。因此，在每一步dfs中，我们需要记录下当前节点最长两条路径的长度，并求出和sum。同时返回最长的一条边的长度给上层dfs。全部dfs结束后，找到最大的sum即是结果。 之前我比较纠结的一点是为什么为什么走过来不会走回去，后来才发现，因为保证了不会走回头路，又是无环图所以一定不会走回去，最后写起来就和二叉树有点像。每次判断以当前节点为中间节点的路径和最长路径的大小。 int res=0; // 返回结果 public int treeDiameter(int[][] edges) &#123; // 利用边的信息构建出树的结构，即每个节点能和哪些节点相连接 List&lt;Integer&gt;[] tree = new List[edges.length+1]; // 初始化 for(int i=0;i&lt;tree.length;i++)&#123; tree[i] = new ArrayList&lt;&gt;(); &#125; // 构建树 for(int[] edge : edges)&#123; tree[edge[0]].add(edge[1]); tree[edge[1]].add(edge[0]); &#125; dfs(tree, 0, -1); // 开始dfs return res; &#125; // tree为树的结构图 // current为当前节点 // previous为前一个节点 // 返回值为：以当前节点为起点的一条最大路径长度 int dfs(List[] tree, int current, int previous)&#123; // 查看当前节点能与哪些节点连接 List&lt;Integer&gt; list = tree[current]; int max1=0; // 以当前节点为起点的一条最大路径长度 int max2=0; // 以当前节点为起点的一条次大路径长度 // 循环所有与当前节点相连的点 for(int next : list)&#123; // 防止走回头路 if(next != previous)&#123; // dfs得到下一个节点一条路径的最大长度 // 加一之后为当前节点一条路径的长度 int max = dfs(tree, next, current)+1; // 比较当路径长度与之前得到的max1，max2，并更新最大值 if(max&gt;=max1)&#123; max2=max1; max1=max; &#125;else if(max&gt;=max2)&#123; max2=max; &#125; // max1+max2得到当前节点最大边长,与返回结果比较，更新最大值 res=Math.max(res, max1+max2); &#125; &#125; // 返回当前节点一条路径的最大长度 return max1; &#125; [LeetCode] 333. Largest BST Subtree 最大的二分搜索子树Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it. Note:A subtree must include all of its descendants. Example: Input: [10,5,15,1,8,null,7] 10 / \\ 5 15 / \\ \\1 8 7 Output: 3Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree’s size, which is 3.Follow up:Can you figure out ways to solve it with O(n) time complexity? Hint: You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity. 找最大的二叉搜索子树首先肯定是需要子树的范围, 因为我们要判断当前结点为根的树是否为二叉搜索树就要满足当前结点大于左子树的最大值, 小于右子树的最小值. 再次我们还需要知道子树是否为二叉搜索树以及其二叉搜索树的大小. 有了这些信息我们就可以判断以当前结点为根的二叉树是否为二叉搜索树了. 但是这题很容易写的比较复杂.&lt;!—hexoPostRenderEscape:class Solution &#123;public: vector&lt;int&gt; DFS(TreeNode* root, int&amp; ans) &#123; if(!root) return vector&lt;int&gt;&#123;0, INT_MAX, INT_MIN&#125;; auto left=DFS(root-&gt;left, ans), right=DFS(root-&gt;right, ans); if(root-&gt;val &gt; left[2] &amp;&amp; root-&gt;val &lt; right[1]) &#123; int Min =min(root-&gt;val, left[1]), Max =max(root-&gt;val, right[2]); ans = max(ans, left[0] + right[0] + 1); return vector&lt;int&gt;&#123;left[0] +right[0] +1, Min , Max&#125;; &#125; return vector&lt;int&gt;&#123;0, INT_MIN, INT_MAX&#125;; &#125; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; largestBSTSubtree(TreeNode* root) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; DFS(root, ans); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ans; &amp;#125; &lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/07/28/树形dp/"},{"title":"区间dp","text":"图像转CT值CT值的单位是Hounsfield，简称为Hu，范围是-1024-3071。用于衡量人体组织对X射线的吸收率，设定水的吸收率为0Hu。 在DICOM图像读取的过程中，我们会发现图像的像素值有可能不是这个范围，通常是0-4096，这是我们常见到的像素值或者灰度值，这就需要我们在图像像素值（灰度值）转换为CT值。 首先，需要读取两个DICOM Tag信息，（0028|1052）：rescale intercept和（0028|1053）：rescale slope. 然后通过公式： Hu = pixel * slope + intercept 计算得到CT值。 衰减系数相关此外，临床上常用的X射线能量范围在80-140KeV左右，也比较固定。因此，三个因素中的2个固定了，剩下的一个就是物质密度。由此可见，医学CT通常是通过物质密度来对物质进行区分的。现在来看看典型值：在临床X射线能量范围内，水的线性衰减系数为0.2cm-1，肌肉为0.2~0.21cm-1，脂肪为0.18cm-1左右，空气在0左右，骨头在0.3~0.4cm-1左右。记这些值比较麻烦，远不如记100,200这种整数来得容易。观察这些值可以发现，这些值都在水附近，所以临床上通常使用某物质与水之间的相对值来衡量物质的衰减能力，即 （物质衰减能力-水衰减能力）/（水衰减能力-空气衰减能力）*1000， 其中水衰减能力在0.2左右，空气为0左右。为了纪念第一个发明CT机的科学家Housfield，我们将这个相对值的单位记为HU。而这个相对值即为CT值。这样一来，可以得出：空气的CT值为-1000HU左右，水是0HU，脂肪是-100HU左右，肌肉是50HU左右，骨头则是500~1000HU左右。这些值就好记多了。所以，结论是：1：在医学上，由于X射线能量比较固定，有效原子序数也比较固定，CT值就基本上刻画的是不同组织的密度差异性。2：如何测量？这是CT图像重建的范畴了。X射线扫描得到投影图像，根据投影图像反演出人体每点的线性衰减系数，带入上述公式，计算得到每一个点的CT值。（注意，上述所有的值都是一些粗略的近似，实际情况则需要实际考察。例如不同部位所使用的X射线能量不同等等。为了易于理解，上述表述也不尽严谨，欢迎讨论~） 转Hu值B. Window-leveling 算法: W/L 是专门为 CT 设计的。原理很简单：CT 图像里不同组织的密度 (用 Hounsfield 单位) 是在固定的值域， 与具体设备和成像软件没有关系。因此，要看头颅时， 我们只需将头颅的值域转换到 0-255 就行了。 CT W/L 不讲头颅值域的 min 和 max, 而说 max - min (即 window_width) 和 (max+min)/2 (即 window_center)。 我们还可以用原来的公式，只是 min 和 max 的算法不一样。 // 先算图像的最大和最小值min = (2window_center - window_width)/2.0 + 0.5;max = (2window_center + window_width)/2.0 + 0.5;for (i = 0; i &lt; nNumPixels; i++) disp_pixel_val = (pixel_val - min)*255.0/(double)(max - min); 请注意，CT 图像必须先转换成 Hounsfield 值再做 window-level。 这个转换包括将多余高位 bits 变成 0 (clipping), 和用 recale slope 和 rescale intercept 来做单位转换。 HU = pixel_val*rescale_slope + rescale_intercept","path":"2020/07/27/Dicom医学图像相关内容/"},{"title":"区间dp","text":"区间dp是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态f(i,j)表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j) = max{f(i,k) + f(k+1, j) + cost}, cost 为将这两组元素合并起来的代价。 区间 DP 的特点： 合并：即将两个或多个部分进行整合，当然也可以反过来；特征：能将问题分解为能两两合并的形式；求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。一般用二维数组表示区间区间问题只需要考虑 区间头和区间尾 87. 扰乱字符串给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。 下图是字符串 s1 = “great” 的一种可能的表示形式。 great / \\ gr eat / \\ / \\g r e at / \\ a t在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。 例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。 rgeat / \\ rg eat / \\ / \\r g e at / \\ a t我们将 “rgeat” 称作 “great” 的一个扰乱字符串。 同样地，如果我们继续交换节点 “eat” 和 “at” 的子节点，将会产生另一个新的扰乱字符串 “rgtae” 。 rgtae / \\ rg tae / \\ / \\r g ta e / \\ t a我们将 “rgtae” 称作 “great” 的一个扰乱字符串。 给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。 dp[i][j][k][h] 表示 T[k..h]T[k..h] 是否由 S[i..j]S[i..j] 变来。由于变换必须长度是一样的，因此这边有个关系 j - i = h - kj−i=h−k ，可以把四维数组降成三维。dp[i][j][len]dp[i][j][len] 表示从字符串 SS 中 ii 开始长度为 lenlen 的字符串是否能变换为从字符串 TT 中 jj 开始长度为 lenlen 的字符串 class Solution &#123; public: bool isScramble(string s1, string s2) &#123; int len1=s1.size(); int len2=s2.size(); if(len1!=len2) return false; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; res(len1+1,vector&lt;vector&lt;bool&gt; &gt;(len1+1,vector&lt;bool&gt;(len1+1,false))); for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len1;j++) &#123; res[i][j][1]=s1[i]==s2[j]; &#125; &#125; for(int i=2;i&lt;=len1;i++) &#123; for(int j=0;j&lt;=len1-i;j++) &#123; for(int k=0;k&lt;=len1-i;k++) &#123; for(int r=1;r&lt;i;r++) &#123; if(res[j][k][r]&amp;&amp;res[j+r][k+r][i-r]) &#123; res[j][k][i]=true; break; &#125; if(res[j][k+i-r][r]&amp;&amp;res[j+r][k][i-r]) &#123; res[j][k][i]=true; break; &#125; &#125; &#125; &#125; &#125; return res[0][0][len1]; &#125; &#125;; 312. 戳气球DP思路是这样的，就先别管前面是怎么戳的，你只要管这个区间最后一个被戳破的是哪个气球这最后一个被戳爆的气球就是 k 注意！！！！！k是这个区间 最后一个 被戳爆的气球！！！！！k是这个区间 最后一个 被戳爆的气球！！！！！ total=dp[i][k]+val[i] val[k] val[j]+dp[k][j] 注：val[i] 表示 i 位置气球的数字然后 (i,k) 和 (k,j) 也都是开区间 之间看这个方法的时候，为什么是开区间，如果选了闭区间怎么办呢，后面想到其实是不用闭区间的。因为我们是在区间左右拓展了一个1. 如果取的是1到10中的开区间，实际上是求的是2到9之间的结果的内容。如果非要闭区间，那么实际的结果应该在0到11之间。 int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;vector&lt;int&gt; &gt; res(len+2,vector&lt;int&gt; (len+2,0)); vector&lt;int&gt; s(len+2,0); s[0]=1; s[len+1]=1; for(int i=0;i&lt;len;i++) &#123; s[i+1]=nums[i]; &#125; for(int i=3;i&lt;=len+2;i++)//作为长度 &#123; for(int j=0;j&lt;=len+2-i;j++) &#123; for(int k=j+1;k&lt;j+i-1;k++) &#123; res[j][j+i-1]=max(res[j][k]+res[k][j+i-1]+s[j+i-1]*s[j]*s[k],res[j][j+i-1]); &#125; &#125; &#125; return res[0][len+1]; 546. 移除盒子这个题目挺难的，用的是区间dp加回溯法，讲道理不太会，下次看这个专题还是有必要重新做。 例如 [9, 5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]，对于一个区间，我判断这个区间的第一个连续色块，9，它后面与他相同的色块位置在6和11位置，那么对于9这个色块的处理有3种方法：1、自己直接干掉，消除他后面的，获得1+[5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]分2、留着，先把他到他后面第一个9的区间，即[5, 3, 5, 3, 3]干掉，然后再处理9+[9, 8, 8, 5, 3, 9]3、留着，但是跳过他后面第一个9的区间，即把[5, 3, 5, 3, 3, 9, 8, 8, 5, 3]都干掉之后，再去处理9+[9]那么可以看出来状态转移方程了，next[i]表示后面第一个与boxes[i]相等的位置，presame表示前面有几个数字与当前第一个位置的数字相等：dp(presame, i, j) = max(max[dp(0, i+1, nexti-1) + dp(presame+1, nexti, j) for every nexti in next[i]], (presame+1)^2 + dp(0, i+1, j)注意这里的presame会和当前的第一个位置数字一起去当做整体去处理。 int removeBoxes(vector&lt;int&gt;&amp; boxes) &#123; int n=boxes.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n,vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(n+1,0))); return dfs(0,n-1,0,dp,boxes); &#125; int dfs(int l,int r,int k,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; dp,vector&lt;int&gt;&amp; boxes) &#123; if(r&lt;l) return 0; if(dp[l][r][k]!=0) return dp[l][r][k]; while(r&gt;l&amp;&amp;boxes[r]==boxes[r-1]) &#123; k++; r--; &#125; dp[l][r][k]=dfs(l,r-1,0,dp,boxes)+(k+1)*(k+1); for(int i=l;i&lt;r;i++) &#123; if(boxes[r]==boxes[i]) &#123; dp[l][r][k]=max(dp[l][r][k],dfs(l,i,k+1,dp,boxes)+dfs(i+1,r-1,0,dp,boxes)); &#125; &#125; return dp[l][r][k]; &#125; 877. 石子游戏这道题我们采用dp[i][j]来判断先手赢的数目，每次有两种选择选最前面的或者最后面的。然后需要减去下一次先手的结果，因为下一次先手是另外一个人的回合了。大于0就是true.bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int len=piles.size(); int sum=0; vector&lt;vector&lt;int&gt; &gt; res(len+1,vector&lt;int&gt; (len+1,0)); for(int i=0;i&lt;len;i++) &#123; res[i][i]=piles[i]; &#125; for(int i=2;i&lt;=len;i++) &#123; for(int j=0;j+i&lt;=len;j++) &#123; res[j][j+i-1]=max(piles[j]-res[j+1][j+i-1],piles[j+i-1]-res[j][j+i-2]); &#125; &#125; return res[0][len-1]&gt;0; &#125; 1000. 合并石头的最低成本这个题目四个循环包括的是区间长度从2到n，然后每个res[j][j+i-1][k]每个区间合并成k团的结果，可以考虑把前面合成k-1团，后面认成一团。最后求出每个区间合并成一团的结果。最后求出的值就是结果。 int mergeStones(vector&lt;int&gt;&amp; stones, int K) &#123; int len=stones.size(); if(!(len%(K-1)==1||K==2)) return -1; vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; res(len+1,vector&lt;vector&lt;int&gt;&gt; (len+1,vector&lt;int&gt; (len+1,1000000))); vector&lt;int&gt; sum(len+1,0); for(int i=1;i&lt;=len;i++) &#123; sum[i]=sum[i-1]+stones[i-1]; res[i-1][i-1][1]=0; &#125; for(int i=2;i&lt;=len;i++) &#123; for(int j=0;j+i&lt;=len;j++) &#123; for(int t=2;t&lt;=K;t++) &#123; for(int r=j;r&lt;=j+i-1;r++) &#123; res[j][j+i-1][t]=min(res[j][j+i-1][t],res[j][r][t-1]+res[r+1][i+j-1][1]); &#125; &#125; res[j][j+i-1][1]=min(res[j][j+i-1][1],sum[j+i]-sum[j]+res[j][j+i-1][K]); &#125; &#125; return res[0][len-1][1]; &#125;","path":"2020/07/27/区间dp/"},{"title":"矩阵动态规划","text":"矩阵动态规划的思路方法方法都是用 dp(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 dp(i, j)dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积。 那么如何计算 dpdp 中的每个元素值呢？对于每个位置 (i, j)(i,j)，检查在矩阵中该位置的值： 如果该位置的值是 00，则 dp(i, j) = 0dp(i,j)=0，因为当前位置不可能在由 11 组成的正方形中； 如果该位置的值是 11，则 dp(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dpdp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下： dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1 很巧妙的方法 统计全为 1 的正方形子矩阵给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 示例 1： 输入：matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]输出：15解释：边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。 class Solution &#123; public: int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int len=matrix.size(); if(len==0||matrix[0].size()==0) return 0; vector&lt;int&gt; t(matrix[0].size()+1,0); int num=0; vector&lt;vector&lt;int&gt;&gt; res1(len+1,t); for(int i=0;i&lt;len;i++) &#123; for(int j=0;j&lt;matrix[0].size();j++) &#123; if(matrix[i][j]==1) &#123; int r=min(res1[i][j+1],min(res1[i][j],res1[i+1][j]))+1; res1[i+1][j+1]=r; &#125; else &#123; res1[i+1][j+1]=0; &#125; num+=res1[i+1][j+1]; // cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;; &#125; // cout&lt;&lt;endl; &#125; return num; &#125; &#125;; 221. 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 输出: 4 class Solution &#123; public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int len=matrix.size(); if(len&lt;=0||matrix[0].size()&lt;=0) &#123; return 0; &#125; int maxsize=0; vector&lt;int&gt; t(matrix[0].size()+1,0); vector&lt;vector&lt;int&gt;&gt; res(len+1,t); for(int i=0;i&lt;len;i++) &#123; for(int j=0;j&lt;matrix[0].size();j++) &#123; if(matrix[i][j]==&#x27;1&#x27;) res[i+1][j+1]=min(min(res[i][j+1],res[i+1][j]),res[i][j])+1; else res[i+1][j+1]=0; //cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;; maxsize=max(maxsize,res[i+1][j+1]); &#125; //cout&lt;&lt;endl; &#125; return maxsize*maxsize; &#125; &#125;;","path":"2020/07/22/矩阵动态规划/"},{"title":"排序算法稳定性","text":"堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。 (1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。 (2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 (3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。 (4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。 (5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个元素(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。 (6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。 (7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 (8)堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。","path":"2020/07/21/排序算法稳定性/"},{"title":"桶排序基数排序相关题目","text":"164. 最大间距桶排序第一种方法采用的是桶排序，方法很巧妙。我们可以知道比较排序最好都是nlogn的，所以不能使用，使用桶排序让我们忽略桶中的顺序，只比较桶之间的大小就可以获得On的复杂度。 那么怎么得到呢，可以得到max,min 然后如果有n个，取一个比平均距离小的内容，为（max-min）/（n）+1,其实也可以加三加四都可以，只需要保证桶内的距离比平均距离小，插值一定在桶间取到就可以，如果每个每个桶的大小对平均距离向下取整，那么相差最大的两个值一定不会在桶中。所以我们只需要记录桶的最大值和最小值，然后比较桶之间的距离就行了。 int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; maxnum(len,-1); vector&lt;int&gt; minnum(len,-1); int maxval=-1,minval=nums[0]; for(int i=0;i&lt;len;i++) &#123; if(nums[i]&gt;maxval) maxval=nums[i]; if(nums[i]&lt;minval) minval=nums[i]; &#125; int sizen=(maxval-minval)/(len)+1; for(int i=0;i&lt;len;i++) &#123; int t=(nums[i]-minval)/sizen; if(nums[i]&gt;maxnum[t]) maxnum[t]=nums[i]; if(minnum[t]==-1||nums[i]&lt;minnum[t]) minnum[t]=nums[i]; // cout&lt;&lt;minnum[t]&lt;&lt;&quot; &quot;&lt;&lt;maxnum[t]&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; &#125; int res=0; int tmp=-1; for(int i=0;i&lt;len;i++) &#123; if(maxnum[i]==-1) continue; if(tmp==-1) &#123; tmp=maxnum[i]; continue; &#125; if(minnum[i]-tmp&gt;res) &#123; res=minnum[i]-tmp; // cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;minnum[i]&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl; &#125; tmp=maxnum[i]; &#125; return res; &#125; 164. 最大间距基数排序基数排序这个是从低位到高位很适合，复杂度是d(n+k),d是位数，k是基数10.这个以前不理解为啥低位到高位可行，其实原因是因为这样是稳定的，例如一个44，41，52.个位数排41，52，44排好，然后排个位就是41，44，52，为什么41一定在前面呢，就是因为，个位的时候已经在前面了，所以要保持稳定性，下次还是在前面。 class Solution &#123; public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; t(len); vector&lt;vector&lt;int&gt;&gt; res(10,t); int maxnum=-1; for(int i=0;i&lt;len;i++) &#123; maxnum=max(maxnum,nums[i]); &#125; int e=1; while(maxnum!=0) &#123; for(int i=0;i&lt;10;i++) res[i].clear(); for(int i=0;i&lt;len;i++) &#123; int t=nums[i]/e%10; res[t].push_back(nums[i]); &#125; int index=0; for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;res[i].size();j++) &#123; nums[index]=res[i][j]; index++; &#125; &#125; maxnum/=10; e*=10; &#125; int result=0; for(int i=1;i&lt;len;i++) &#123; result=max(result,nums[i]-nums[i-1]); &#125; return result; &#125; &#125;;","path":"2020/07/21/桶排序基数排序相关题目/"},{"title":"C++中取INF","text":"int型是4个字bai节 一个字节8个位 0x7f7f7f7f 是十六进制du也就是4个0x7f ,一个0x7f 转化为二进制就zhi是 01111111因为是int型 第一个位是符号位dao ，因而在int 型中 0x7f7f7f7f也就是无穷大的意思通过 #define 将 “INF” 转化为符号常量 代表 0x7f7f7f7f","path":"2020/07/17/C++中取INF/"},{"title":"计数排序基数排序和桶排序","text":"计数排序基数排序和桶排序 这三种方法我经常容易忘记，不太熟悉。总结一下。 计数排序原理很容易懂就是排序元素的范围我们知道，那么就可以将其放到一个这么大的数组中，然后直接每次从数组中取数丢进排序数组中，这个不是一个比较排序的方法。最坏时间复杂度为O(n+k),空间复杂度也为O(n+k) 空间复杂度容易理解，但是时间复杂度我一开始以为的是O(n),实际上这是不对的，因为需要考虑到n很小而k很大 n很大而k很小的情况，综合起来就是O(n+k). 桶排序假设:它使用了具有固定范围的“桶”。它假设每一个元素都会落在这些桶内。每一个桶的范围是固定的。如果桶的范围是1，则该算法就与计数排序很相似了，唯一的不同之处是，它存储的是元素本身而不是它们的计数。 算法： 假设有k个桶：B0, B1, … Bk-1 对于数组a中的每一个元素e： 当e属于Bi时，将其插入Bi中 对于B中的每一个桶b： sort b 令finalarray = {} 对于B中的每一个桶b： finalarray = concat(finalarray, b) 时间复杂度：O(n)，最坏情况O(n n)或者O(n logn)取决于其对桶使用的排序算法。最坏情况下所有元素都落入同一个桶内。 其时间复杂度还与桶的大小和范围有关。如果桶的大小和范围选择不当，可能使得所有元素都落入同一个桶中。如果元素均匀的分布在各个桶内，则时间复杂度就是O(n) 空间复杂度：O(n) 大体讲就是将数分到很多个桶中，每个桶中的排序复杂度很小，然后将数连起来。排序完成，最坏情况大家都在一个桶中效果就很差。 基数排序基数排序的主要思路是,将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次稳定排序(我们常用上一篇blog介绍的计数排序算法, 因为每个位可能的取值范围是固定的从0到9).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列. 基数排序的时间复杂度是O(n*k)，其中n是排序元素的底，如是十进制就是10，k是数字位数。","path":"2020/07/13/计数排序基数排序和桶排序/"},{"title":"背包九讲","text":"背包九讲01背包问题有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。求解将哪些物品装入背包可使价值总和最大。递推方程应该是res[i][V]=max(res[i-1][V-ci]+wi,res[i-1][V]); 可以用滚动数组优化成O(V)空间 这个空间优化的过程，应该逆序得到，顺序不可以。 res[V]=max(res[V-ci],res[V]); V=V……1； 还可以进行常数优化res[V]=max(res[V-ci],res[V]); $a_1$ $V=V……max(V-\\sum^{n}_{i+1}ci+1,ci)$ 为什么是循环到i+1就可以停下来呢？如果是ci较大，那么对于一维空间优化的情况下，表示的是res[i-1][V],对于继续向下循环是不会改变结果的。 如果是V-\\sum^{n}_{i+1}ci+1较大，说明剩下的空间已经不够装ci了，自然也没必要再继续了。 完全背包问题有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 这个题目一看很容易认为是贪心问题，但是这个物品是不能分的所以不是贪心的，需要注意。这个我们考虑的就是还是某个物品选不选，但是是可以再次选它的。 二维形式 res[i][V]=max(res[i-1][V],res[i][V-ci]+wi); 一维形式为res[V]=max(res[V],res[V-ci]+wi) v=1……V;在优化的情况下，体积大于V可以直接去掉。O(n) 另外对于任何的体积更大的，但是价值更低的，也可以优化掉。O(n^2) 还可以将体积相同的物品，都用其价值最大的代替。O(V+N)类似计数排序 for i……n if(store[V[i]]&lt;wi) store[V[i]]=wifor i ……v 把这些物品丢进去 多重背包问题有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 这个首先有两个朴素的想法 01背包的想法这个想法是把M[i]个相同的物品看成很多个不同的物品，然后用01背包方法求解。 完全背包的想法这个方法就是对于任何一个物品，每次都有许多个选择，然后选取其中的k个进行空间优化之后和01背包的思路相同。复杂度也相同int mutibackpack()//类似完全背包的方法 &#123; for (int i = 0; i &lt;N; i++) &#123; for (int j = 1; j &lt;=M[i]; j++) &#123; for (int k = C[i]*j; k &lt;=V; k++) &#123; res[k] =max(res[k], res[k-j*C[i]]+j*W[i]); &#125; &#125; &#125; return res[V]; &#125; 二进制优化二进制思想： 假设有 1000 个苹果，现在要取n个苹果，如何取？朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有 1000 个苹果和10只箱子，利用箱子进行某些预工作，然后如何快速的取出n个苹果呢？So..可以在每个箱子中放 2^i (i&lt;=0&lt;=n)个苹果，也就是 1、2、4、8、16、32、64、128、256、489（n减完之前的数之后不足 2^i，取最后剩余的数），相当于把十进制的数用二进制来表示，取任意n个苹果时，只要推出几只箱子就可以了。 再次分析： 只看上面是不好理解的，比如：7的二进制 7 = 111, 它可以分解成 001, 010, 100. 这三个数可以组合成任意小于等于 7 的数，而且每种组合都会得到不同的数。再比如，13 = 1101, 则分解为 0001, 0010, 0100, 0110. 前三个数字可以组合成 7 以内任意一个数，每个数再加上0110(= 6) 之后可以组合成任意一个大于等于 6 小于等于 13 的数，所以依然能组成任意小于等于 13 的数，很明显 6,7 会多重复 1 次，但对于求解背包问题是没有影响的，基于这种思想把一种多件物品转换为，多件一种物品，然后用01背包求解即可。 这个想法可以视为从以前我们对于某种物品取它的n数量，会考虑n-1数量的情况，现在我们不是间隔为1进行考虑，而是用二进制的方法来考虑int mutibackpack2()//二进制优化 &#123; int ste = 1; int num; for (int i = 0; i &lt; N; i++) &#123; num = M[i]; while(num&gt;0) &#123; if(num&gt;ste) num -= ste; else &#123; ste = num; num -= ste; &#125; for (int k = C[i] * ste; k &lt;= V; k++) &#123; res[k] = max(res[k], res[k - ste * C[i]] + ste * W[i]); &#125; ste *= 2; &#125; &#125; return res[V]; &#125; 可行性问题多重背包可行性问题指的是：每种有若干件的物品能否填满给定容量的背包，此时不考虑价值最大问题 F(i,j)表示使用前i个物品，填充容量为jjj的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1. F[i-1][j]&gt;0res[i][j]=M[i] F[i][j-C[i]]&lt;=0 || j&lt;C[i]res[i][j]=-1 其他res[i][j]=res[i][j-C[i]]-1 int mutibackpack3()//res[i][j]表示前i中物品填满j大小的空间最大的剩余物品数量,进行了空间优化 &#123; res[0] = M[0]; for (int i = 0; i &lt; V; i++) &#123; res[V] = -1; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (res[j] &gt; 0) res[j] = M[i]; else if (res[j - C[i]] &lt;= 0 || j &lt; C[i]) res[j] = -1; else res[j] = res[j - W[i]] - 1; &#125; &#125; return res[V]; &#125; 单调队列求解这个比较难，暂时没写 混合背包问题01 背包与完全背包的混合考虑到 01 背包和完全背包中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是 O(V N)。 再加上多重背包如果再加上最多可以取有限次的多重背包式的物品，那么利用单调队列，也可以给出均摊 O(V N) 的解法。但如果不考虑单调队列算法的话，用将每个这类物品分成 O(logMi) 个 01 背包的物品的方法也已经很优了。最清晰的写法是调用我们前面给出的三个过程。 二维费用的背包问题二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。 算法可以写成res[i][j][k]=max(res[i-1][j][k],res[i][j-ci][k-di]+2i) 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以付出的最大件数费用为 U。换句话说，设 F[v, u] 表示付出费用 v、最多选 u 件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0 . . . V, 0 . . . U] 范围内寻找答案。 分组背包有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值 res[k][v]=max(res[k-1][v],res[k][v-c[i]]+wi),ci,wi 为组中的东西 依赖背包这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则策略有 2n + 1 个，为指数级。 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于依赖背包中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑对每组内的物品应用完全背包中的优化。我们可以想到，对于第 k 个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的物品组，其中费用为 v 的物品的价值为 Fk[v − Ck] + Wk，v 的取值范围是 Ck ≤ v ≤ V 。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V − Ck + 1 个物品的物品组，就可以直接应用6的算法解决问题了。 在树形依赖的背包问题中，我们将每颗子树作为一个泛化物品来看。同样，我们可以对每个主件的附件集合进行处理，合成一个新的泛化物品。即对每个主件的附件集合做一次01背包，得到res[j],j为0……v-wi,wi为第i个主件的空间，表示该附件集合在分配体积为j的情况下该附件总和的最优值。 更一般的问题是：依赖关系以图论中“森林”3的形式给出。 也就是说，主件的附件仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物品”的思想。看完泛化物品后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 泛化物品考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它费用 v，可得到价值 h[v]。一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w ·v c，其它函数值均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函数有 h(v) = w ·vc 仅当 v 被 c 整除且 vc ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 泛化物品的和如果给定了两个泛化物品 h 和 l，要用一定的费用从这两个泛化物品中得到最大的价值，这个问题怎么求呢？事实上，对于一个给定的费用 v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v，可以求得费用v 分配到 h 和 l 中的最大价值 f(v)。 f(v)=max(h(k)+l(v-k)) k=1……v 由泛化物品的定义可知：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。若问题的和为 s，则答案就是 s(0 . . . V ) 中的最大值。 搜索还是DP?在看到一道背包问题时，应该用搜索还是动态规划呢？ 首先，可以从数据范围中得到命题人意图的线索。如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考察动态规划了。 另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。","path":"2020/07/13/背包九讲/"},{"title":"打家劫舍","text":"粉刷房子1这个题目leetcode需要会员，题干如下。假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 = 10。 选取第i个房子涂不同颜色的最小值public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs) &#123; int n=costs.size(); if(n==0) return 0; int a=costs[0][0],b=costs[0][1],c=costs[0][2]; int t1,t2,t3; for(int i=0;i&lt;n;i++) &#123; t1=a; t2=b; t3=c; a=min(b,c)+costs[i][0];//刷成红色的最大值 b=min(t1,t3)+costs[i][1]; c=min(t1,t2)+costs[i][2];//刷成蓝色 &#125; return min((min(a,b)),c); &#125; 粉刷房子2假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[1,5,3],[2,9,4]]输出: 5解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; 或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5. 这个题目如果用正常的思路，那么应该是对每个位置的房子，选取不同的颜色k，然后取其颜色不为k最小值。O(nkk). 会导致超时，复杂度过高。 可以优化每次选上一个的最短花费和次短花费。如果颜色和最短花费不一样，则选最短花费，否则选次短花费。这个地方应该注意一点，我之前很迷惑如果最短和次短都是和它一个颜色怎么办呢，后来才发现其实选的是在上一个位置颜色不同的最短花费和次短花费。这个地方比较巧妙，需要额外注意。 public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs,int k) &#123; int n=costs.size(); if(n==0||costs[0].size()==0) return 0; auto res=costs; int tmp1=0,tmp2=1; int a1=-1,a2=-1; for(int i=0;i&lt;n;i++) &#123; a1=-1; a2=-1; for(int j=0;j&lt;k;j++) &#123; if(j==tmp1) &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp1]+costs[i][j]); &#125; else &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp2]+costs[i][j]); &#125; if(a2&lt;0||res[i][j]&lt;res[i][a2]) &#123; a2=j; if(a2&lt;0||res[i][a2]&lt;res[i][a1]) &#123; swap(a2,a1); &#125; &#125; &#125; tmp1=a1; tmp2=a2; &#125; return res[n-1][tmp1]; &#125;","path":"2020/07/13/粉刷房子/"},{"title":"打家劫舍","text":"打家劫舍1递推公式为d0[i]=d1[i-1]+price,d1[i]=max(d1[i-1],d0[i-1]);可以进行空间优化class Solution &#123; public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int a=nums[0]; int b=0; int len=nums.size(); int t; for(int i=1;i&lt;len;i++) &#123; t=a; a=b+nums[i]; b=max(b,t); &#125; return max(a,b); &#125; &#125;; 打家劫舍2只需要保证最后一个和第一个不会被同时取到，注意这个不是约瑟夫问题那样可以循环的。所以只需要求两次然后考虑删除第一个和删除最后一个的情况。 int rob(vector&lt;int&gt;&amp; nums) &#123;//不能来回偷 int len=nums.size(); if(len==0) return 0; if(len==1) return nums[0]; vector&lt;int&gt; res1; res1.assign(nums.begin()+1, nums.end()); vector&lt;int&gt; res2; res2.assign(nums.begin(),nums.end()-1); int a=res2[0]; int b=0; int t; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res2[i]; b=max(t,b); &#125; int res=max(a,b); a=res1[0]; b=0; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res1[i]; b=max(t,b); &#125; int tt=max(a,b); return max(res,tt); &#125; 打家劫舍3这个结构是树形的，相比数组的要难一些，所以第一种方法就是考虑根节点偷和不偷的情况，然后返回之，我第一次做是用的递归返回的是偷和随便偷不偷，这样是不行的，应该要明确状态。 vector&lt;int&gt; dp0(TreeNode* root) &#123; vector&lt;int&gt; res(2,0); if(root==nullptr) return res; vector&lt;int&gt; res1=dp0(root-&gt;left); vector&lt;int&gt; res2=dp0(root-&gt;right); res[0]=root-&gt;val+res1[1]+res2[1];//偷这个根节点的选项 res[1]=max(res1[0],res1[1])+max(res2[0],res2[1]);//不偷的选项 return res; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; vector&lt;int&gt; res=dp0(root); return max(res[0],res[1]); &#125; 事实上确实有一种考虑随便偷不偷的方法的。在区分偷不偷的时候，我们事实上考虑的是偷目前节点加上随便偷不偷孙子节点，以及不偷目前节点，随便偷不偷儿子节点。为了防止超时，用哈希表把求得的信息存起来。unordered_map&lt;TreeNode*,int&gt; m; int dp0(TreeNode* root,unordered_map&lt;TreeNode*,int&gt;&amp; m) &#123; int value=0; if(root==nullptr) return 0; if(m.count(root)) return m[root]; if(root-&gt;left!=nullptr) value+=dp0(root-&gt;left-&gt;left,m)+dp0(root-&gt;left-&gt;right,m); if(root-&gt;right!=nullptr) value+=dp0(root-&gt;right-&gt;left,m)+dp0(root-&gt;right-&gt;right,m); int t=max(root-&gt;val+value,dp0(root-&gt;right,m)+dp0(root-&gt;left,m)); m[root]=t; return t; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; return dp0(root,m); &#125;","path":"2020/07/13/打家劫舍/"},{"title":"股票买卖问题","text":"股票买卖问题1当前的最大收益只依赖于之前的最小买入价格。只需要记住到目前为止的最小值，然后可以得到每个位置的收益。O(n)class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max=0; int len=prices.size(); if(len==0) return 0; int min=prices[0]; for(int i=0;i&lt;len;i++) &#123; if(prices[i]&gt;min) &#123; int t=prices[i]-min; if(max&lt;t) max=t; &#125; else &#123; min=prices[i]; &#125; &#125; return max; &#125; &#125;; 股票买卖问题2这个题目朴素的想法就是找到每个峰谷和峰顶，然后求差异获得利润。但是由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1 class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; int len=prices.size(); for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125; &#125;; 股票买卖问题3int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(3,0); vector&lt;int&gt; res2(3,0); for(int i=0;i&lt;3;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=2;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[2]; &#125; 股票买卖问题4买卖k次 当前处于第几天；已经交易的次数；手头是否持有股票；即根据手头是否持有股票，我们定义两个二维数组来定义状态： dp0[i][j]: 第i天结束，已有j次买卖，手头没有股票时的最大利润dp1[i][j]: 第i天结束，已有j次买卖，手头有股票时的最大利润因此，dp0[0][j]对于所有j都要初始化为0，而dp1[0][j]对于所有j都要初始化为-prices[i]。如果我们将dp0所有值都求出来了，那么很明显dp0[n-1][k]就是在最后一天结束时已进行k次交易且手头无股票时的最大收益，也即返回结果。 先看初始状态: 当i==0 &amp;&amp; j&gt;=0: dp0[0][j] = 0, dp1[0][j] = -prices[0];当i&gt;0 &amp;&amp; j==0: dp0[i][0] = 0, dp1[i][0] = max(dp1[i-1][0], -prices[i]);再来考虑状态转移方程，当i&gt;0且j&gt;0时有 dp0[i][j] = max(dp0[i-1][j], dp1[i-1][j-1] + prices[i]) # 保持 or 卖出dp1[i][j] = max(dp1[i-1][j], dp0[i-1][j] - prices[i]) # 保持 or 买入有了状态定义及转移方程，剩下就好办了。 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int k=2;//可以改变k值 int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; a(k+1,0); vector&lt;vector&lt;int&gt;&gt; res1(len,a);//没有股票在手中 vector&lt;vector&lt;int&gt;&gt; res2(len,a);//有股票在手中 int min=prices[0]; for(int i=0;i&lt;k;i++) res2[0][i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[i][0]=max(res2[i-1][0],-prices[i]); &#125; for(int i=1;i&lt;len;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; res1[i][j]=max(res1[i-1][j],res2[i-1][j-1]+prices[i]); res2[i][j]=max(res1[i-1][j]-prices[i],res2[i-1][j]); &#125; &#125; return res1[len-1][k]; &#125; 但是这个效率不高，可以知道，当k&gt;2/n的时候。就是买卖无数次了。并且可以进行空间优化。int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0||k==0) return 0; if(k&gt;len/2) &#123; int result=0; for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) result+=prices[i]-prices[i-1]; &#125; return result; &#125; vector&lt;int&gt; res1(k+1,0); vector&lt;int&gt; res2(k+1,0); int min=prices[0]; for(int i=0;i&lt;k;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=k;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[k]; &#125; 股票买卖问题5这里需要注意的就是当不持股，不在冷冻期的可能就是，上一个是冷冻期，然后这一天啥也没干，还有可能就是直接就是上一天。int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(len,0);//不持股，不在冷冻期 vector&lt;int&gt; res2(len,0);//持股，不在冷冻期 res2[0]=-prices[0]; vector&lt;int&gt; res3(len,0);//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; res1[i]=max(res1[i-1],res3[i-1]); res2[i]=max(res1[i-1]-prices[i],res2[i-1]); res3[i]=res2[i-1]+prices[i]; &#125; return max(res3[len-1],res1[len-1]); &#125; 优化空间 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; int res1=0;//不持股，不在冷冻期 int res2=-prices[0];//持股，不在冷冻期 int res3=0;//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; int a=res1; int b=res2; res1=max(a,res3); res2=max(a-prices[i],b); res3=b+prices[i]; &#125; return max(res3,res1); &#125; 股票买卖问题6也是和之前的类似，选取两个状态，持有股票，不持有股票，在卖出时还需要减去手续费。 int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int len=prices.size(); int res1=0; int res2=-prices[0]; int t; for(int i=0;i&lt;len;i++) &#123; t=res1; res1=max(res1,res2+prices[i]-fee); res2=max(res2,t-prices[i]); &#125; return res1; &#125;","path":"2020/07/12/股票买卖问题/"},{"title":"动态规划题型总结","text":"因为动态规划毕竟要满足： 阶段性无后效性子问题重叠性因此，能够利用DP来解决的问题实际上是有限的，大部分题目都是针对现有的模型的一些变种，改改题目描述，或者加点限制条件。所以要想攻克DP题目，最根本的就是要充分理解几个常见的DP模型。而要充分理解常见经典DP模型，就需要通过大量的做题和总结，而且二者不可偏废。通过做题进行思考和量的积累，通过总结加深理解和融会贯通进而完成质的提升。 动态规划是求解一个最优化问题，而最核心的思想就是： 分而治之想办法记录下中间的计算结果避免重复计算解一道DP题目，先问自己几个问题： 我需要最少哪些数据，然后经过一些比较就能得出最终结果？这些数据的求解是否可以用同样的方法分而治之？过程中的运算结果如何保存复用？当然以上内容看起来比较抽象，虽然它深刻地揭露了动态规划的本质，但是如果临场要去想明白这些问题，还是有些难度。如果只是针对比赛和面试，就像前面说的，DP题型是有限的。只要刷的题目足够多，总结出几个经典模型，剩下的都是些变种+优化而已。 一般来说，动态规划可以分成4个大类: 线性DP数位dp概率dp等区间DP树型DP背包线性DP就是阶段非常线性直观的模型，比如：最长（上升|下降）序列，最长公共子序列(LCS)等，也有一些简单的递推，甚至都算不上是经典模型。 线性dp最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。相关题目比如： 300. 最长上升子序列，裸题，但是要击败100%的话，需要单调队列优化。 354. 俄罗斯套娃信封问题，这道题还是hard。之前的最长上升序列是一维的，这道题是二维的上升序列，满足Ax&lt;Bx且Ay&lt;By，才可以构成上升序列。那么我们可以根据x进行排序，然后对y求解最长上升子序列。但是这里有个地方需要注意，因为x必须要严格升序，排序之后可能存在(1,1) (1,2) (1,3) (2,4)这样的序列，如果对y进行求解上升序列，会得到4，但是实际应该只是2。为了避免这个问题，在排序时，如果x相等，则y按照降序排列，就可以规避这个问题。 合唱队形，这道题是要求一个形如1 3 4 7 9 8 6 5 2这样的子序列。先上升再下降，最后求最长的长度。其实解决办法也很简单，先从左到右求出所有的最长上升序列asc[i]，再从右到左求出所有的最长上升序列reverseAcc[i]，最大值就是max(asc[i]+reverseAcc[i])。对算法要能够灵活运用。 LCS 最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。相关题目： 1143. Longest Common Subsequence：这道题就是裸的LCS 583. Delete Operation for Two Strings：两个字符串要删除成一样的，所以先找出最长公共序列，然后剩下的都删了。 718. Maximum Length of Repeated Subarray：这道题其实本质上不是LCS，它是寻找最长子数组，而不是子序列（子数组要求连续）。需要搞清它们的区别。找子数组就更简单了，因为必须连续，所以f[i][j] = f[i-1][j-1]+1 : 0 ? S[i]==T[j]。通过倒序枚举能够把空间优化为O(N)。 1092. Shortest Common Supersequence：这道题是hard，实际上也不算很hard。其实就是找到最长公共子序列，然后，对于A字符串，把除了LCS以外的字符插入到对应的位置；对于B字符串也做同样的操作。这道题大家需要掌握一个新姿势，就是除了求最长公共子序列有多长，还要会打印最长公共子序列（follow up：打印所有可能的最长公共子序列）。同时，要把剩余的字符插入到对应的位置其实可以想办法把原字符串按照LCS切分成k+1段，比如对于字符串A abcxdef，其lcs为bde，那么我们可以把原字符串切成4段 a bcx d ef，同样对于B字符串，也能切成4段，然后对应插入构成新字符串即可，需要注意的就是，从第1段开始，第一个字符是lcs字符，所以只插一次。 股票买卖问题 Best Time to Buy and Sell Stock：当前的最大收益只依赖于之前的最小买入价格。因此只需要一个变量保存截至目前的最低价即可，每次更新最大收益。 Best Time to Buy and Sell Stock II：由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1。 可以买卖两次股票三个状态，已经买卖2次，持有 不持有股票，第k天为结束天 可以买卖k次股票三个状态，已经买卖k次，持有 不持有股票，第k天为结束天 卖出股票之后有冷冻期选择三个状态，持有股票，不持有股票，处于冷冻期 卖出股票之后有手续费选择两个状态，持有股票，不持有股票 打家劫舍粉刷房子背包九讲图形问题区间dp树形dp","path":"2020/07/12/动态规划/"},{"title":"1143. 最长公共子序列","text":"最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。 class Solution &#123; public://使用了2N的空间的动态优化 int longestCommonSubsequence(string text1, string text2) &#123; int len1=text1.size(); int len2=text2.size(); vector&lt;int&gt; a1(len2+1,0); vector&lt;int&gt; a2(len2+1,0); int flag=2; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(text1[i]==text2[j]) &#123; if(flag==2) a2[j+1]=a1[j]+1; else a1[j+1]=a2[j]+1; &#125; else &#123; if(flag==2) a2[j+1]=max(a2[j],a1[j+1]); else a1[j+1]=max(a2[j+1],a1[j]); &#125; &#125; flag=-flag; &#125; if(flag==2) return a1[len2]; else return a2[len2]; &#125; &#125;;","path":"2020/07/12/1143.最长公共子序列/"},{"title":"300. 最长上升子序列","text":"最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。 说单调队列优化之前必须明白一个贪心策略。因为要求的是最长上升序列，那么很显然长度为k的上升序列的最大值（最后一个数）越小越好，这样后面的数才有更大的概率比它大。如果我们记录下来不同长度的上升序列的最后一个数能达到的最小值，那么对于后续每个数t，它要么能放到某个长度为y的序列之后，组成长度为y+1的上升序列，要么放到某个长度为x的序列后面，把长度为x+1的序列的最大值替换成t。同时我们可以发现，如果x&lt;y，那么长度为x序列的最后一个数一定比长度为y的序列最后一个数小。因此这个上升序列我们可以用一个数组来维护（所谓的单调队列），数组下标就代表序列长度。opt[i]=t表示长度为i的上升序列最后一个数最小是t。那么当我们在面对后续某个数x时，可以对单调队列opt进行二分，把它插到对应的位置。因此总体复杂度就是NlogN。 class Solution &#123; public: // int lengthOfLIS(vector&lt;int&gt;&amp; nums) // &#123;//dp，不用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) // int len=nums.size(); // if(len==0) // return 0; // vector&lt;int&gt; res(len,0); // res[0]=1; // int result=1; // for(int i=1;i&lt;len;i++) // &#123; // int maxnum=1; // for(int j=0;j&lt;i;j++) // &#123; // if(res[j]+1&gt;maxnum&amp;&amp;nums[j]&lt;nums[i]) // maxnum=res[j]+1; // &#125; // res[i]=maxnum; // if(res[i]&gt;result) // result=res[i]; // &#125; // return result; // &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;//dp，用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) int len=nums.size(); if(len==0) return 0; vector&lt;int&gt; res; for(int i=0;i&lt;len;i++) &#123; if(res.size()==0||res[res.size()-1]&lt;nums[i]) res.push_back(nums[i]); else //if(res[res.size()-1]&lt;nums[i]) &#123; int p=BinSearch(res,nums[i]); res[p]=nums[i]; &#125; &#125; return res.size(); &#125; int BinSearch(vector&lt;int&gt;&amp; a,int b) &#123; int len=a.size(); int l=0,r=len-1; int mid=l+(r-l)/2; while(a[mid]!=b) &#123; if(r==l) return r; if(a[mid]&lt;b) &#123; l=mid+1; &#125; else &#123; r=mid; &#125; mid=mid=l+(r-l)/2; &#125; return mid; &#125; &#125;;","path":"2020/07/12/300. 最长上升子序列/"},{"title":"验证集和测试集的区别","text":"验证集和测试集 类别 验证集 测试集 是否被训练到 否 否 作用 用于调整超参数 用于验证泛化能力 使用次数 多次使用，以不断调参 仅仅一次使用 缺陷 模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够 测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集 互相转化 验证集具有足够泛化性（一般来说，如果验证集足够大到包括大部分非训练集时，也等于具有足够泛化性了） 验证集具有足够泛化性时，测试集就没有存在的必要了 类比 校内答辩（如果校内答辩比多校联合答辩还有泛化性说服力，那么就没有必要再搞个多校联合答辩了） 多校联合答辩 附言说到底：验证集是一定需要的；如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。","path":"2020/07/03/验证集和测试集的区别/"},{"title":"166. 分数到小数","text":"166. 分数到小数这道题我认为需要注意的有几个地方 第一个地方在于除法如何计算，这里我选择的方法是当被除数相同的时候认为是循环小数。 第二个地方在于结果可能有负数，负数的求模和正数有所不同，需要注意。负数求模是a-(a/b)*b的，有个时候因此会有正负的区分。 第三个地方在于数字溢出的问题，a=-2147483648, b=-1,a*b是会溢出的，因为会先转成一个整形的数，因此需要转一下long. 第四个地方是在判断两个数是否是同号的时候最好采用异或的方法，而不要采用相乘符号的方法，这样会导致溢出，还有一个我以前没注意的地方就是异或等位运算的优先级是要低于等于符号的，因此最好加上括号。 代码如下class Solution &#123; public: string fractionToDecimal(int numerator, int denominator) &#123; long a1=long(numerator)%denominator; long a2=long(numerator)/denominator; if(a1==0) return to_string(a2); else &#123; int i=0; int quo=abs(a2); string res=&quot;&quot;; if((numerator^denominator)&lt;0) &#123; res=res+&quot;-&quot;; i++; &#125; res=res+to_string(quo)+&quot;.&quot;; i+=to_string(quo).size()-1; unordered_map&lt;int,int&gt; map; numerator=abs(a1); while(numerator!=0) &#123; numerator=abs(numerator); if(map.find(numerator)==map.end()) &#123; map[numerator]=i; i++; &#125; else &#123; string tmp=res.substr(map[numerator]+2); string tmp1=res.substr(0,map[numerator]+2); res=tmp1+&quot;(&quot;+tmp+&quot;)&quot;; return res; &#125; long ttt=numerator; ttt*=10; long a=abs(ttt/denominator); long b=abs(ttt%denominator); res=res+to_string(a); numerator=b; &#125; return res; &#125; &#125; &#125;;","path":"2020/06/12/166. 分数到小数/"},{"title":"设计模式","text":"设计模式学习[toc] 设计模式和原则单一职责的原则简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑更改的时候就不需要修改很多东西，更容易维护。 开闭原则就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。 里氏替换原则简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 在实际编程中只要遵循以下4点，就能在项目中满足这个规则。每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 创建型模式","path":"2020/06/03/设计模式/"},{"title":"ART算法实现与理解","text":"Code这两个图显示了算法的原理，整体的几何意义也较为容易理解 import numpy as np def ART_My( A, b, X0, e0): e=e0+1 i=0 while(e&gt;e0): tmp=((A[i]@X0-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i]))) X=X0-np.reshape(tmp,(-1,1)) e=np.linalg.norm(X-X0) X0=X i=(i+1)%np.shape(A)[0] print(e) return X0 if __name__==&quot;__main__&quot;: A=np.array([[3,1],[1,5]]) b=np.array([[1],[1]]) e0=0.000001 X0=np.array([[0],[0]]) X=ART_My(A,b,X0,e0) print((X))","path":"2020/06/03/ART算法实现与理解/"},{"title":"函数间隔和几何间隔","text":"对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。 SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。","path":"2020/05/21/函数间隔和几何间隔/"},{"title":"大端和小端","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下Big-endian：高位字节存入低地址，低位字节存入高地址Little-endian：低位字节存入低地址，高位字节存入高地址一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。 因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序","path":"2020/05/20/大端和小端/"},{"title":"218. 天际线问题","text":"问题的求解方法一其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。 接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。 如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。 但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。 扫描线移到[2 10]关键点时，10要大于rpre的，可以满足； 扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足； 扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足； 接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。 这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。这个问题的求解方法的重点在于合并两个点，合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。 在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(buildings.length==0) return res; return divide(buildings,0,buildings.length-1); &#125; public List&lt;List&lt;Integer&gt;&gt; divide(int [][]buildings,int l,int r) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(r==l) &#123; res.add(Arrays.asList(buildings[l][0],buildings[l][2])); res.add(Arrays.asList(buildings[l][1],0)); return res; &#125; int a=l+(r-l)/2; List&lt;List&lt;Integer&gt;&gt; res1=divide(buildings,l,a); List&lt;List&lt;Integer&gt;&gt; res2=divide(buildings,a+1,r); int l1=0; int r1=0; int lh=0,rh=0; int leftX, leftY, rightX, rightY; while(l1&lt;res1.size()||r1&lt;res2.size()) &#123; if(l1&gt;=res1.size()) res.add(res2.get(r1++)); else if(r1&gt;=res2.size()) res.add(res1.get(l1++)); else &#123; leftX = res1.get(l1).get(0); // 不会出现null，可以直接用int类型 leftY = res1.get(l1).get(1); rightX = res2.get(r1).get(0); rightY = res2.get(r1).get(1); if(leftX&gt;rightX)//每次选择一个较小的 &#123; if(rightY&gt;lh) res.add(res2.get(r1)); else if(rh&gt;lh) &#123; res.add(Arrays.asList(rightX,lh)); &#125; rh=rightY; r1++; &#125; else if(leftX&lt;rightX) &#123; if(leftY&gt;rh) res.add(res1.get(l1)); else if(lh&gt;rh) res.add(Arrays.asList(leftX,rh)); lh=leftY; l1++; &#125; else &#123; int h=Math.max(lh,rh); if(leftY&gt;=rightY&amp;&amp;leftY!=h) &#123; res.add(res1.get(l1)); &#125; else if(leftY&lt;=rightY&amp;&amp;rightY!=h)//只要不汇聚到最高点就没问题 &#123; res.add(res2.get(r1)); &#125; lh=leftY; rh=rightY; l1++; r1++; &#125; &#125; &#125; return res; &#125; &#125; 这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，然后每次和最大的节点进行比较，不同就加入节点。这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); Set&lt;Pair&lt;Integer,Integer&gt;&gt; pairs=new TreeSet&lt;&gt;((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue()); for(int[] bu:buildings) &#123; pairs.add(new Pair&lt;&gt;(bu[0],-bu[2])); pairs.add(new Pair&lt;&gt;(bu[1],bu[2])); &#125; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); int prev = 0; // 遍历 for (Pair&lt;Integer, Integer&gt; pair : pairs) &#123; if (pair.getValue() &lt; 0) queue.offer(-pair.getValue()); // 左端点 高度入堆 else queue.remove(pair.getValue()); // 右端点 高度出堆 Integer cur = queue.peek() == null ? 0 : queue.peek(); // 获取最大堆的当前顶点，当null时置为0 if (prev != cur) &#123; res.add(new ArrayList&lt;Integer&gt;() &#123; &#123; add(pair.getKey()); add(cur); &#125;&#125;); prev = cur; &#125; &#125; return res; &#125; &#125;","path":"2020/05/20/218. 天际线问题/"},{"title":"为啥那么C++pop不返回值","text":"书上的解释也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。 这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素 在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。 按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下， 因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。 从异常上看这么使用 Stack stack; stack.push(object); Object obj=stack.pop() ; 当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的， 假设这时候发生异常，丢生的栈顶元素就回不去了。 而在java中pop（）是有返回值的源码是这么写的 int i = size(); Object object = peek(); removeElementAt(i - 1); return (E)object; 实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，","path":"2020/05/20/为什么C++pop不返回值/"},{"title":"145. 二叉树的后序遍历","text":"方法后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。 所以方法有三种： 开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); Set&lt;TreeNode&gt; set=new HashSet&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(!set.contains(tmp)&amp;&amp;tmp.right!=null) &#123; treenode=tmp.right; set.add(tmp); &#125; else &#123; res.add(tmp.val); stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; TreeNode last=null; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(tmp.right!=null&amp;&amp;tmp.right!=last) &#123; treenode=tmp.right; &#125; else &#123; res.add(tmp.val); last=tmp; stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur == null) &#123; continue; &#125; if (!stack.isEmpty() &amp;&amp; cur == stack.peek()) &#123; stack.push(cur.right); stack.push(cur.right); stack.push(cur.left); stack.push(cur.left); &#125; else &#123; list.add(cur.val); &#125; &#125; return list; &#125; 可以转换成一个逆的前序遍历来实现public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; res.add(treenode.val); stack.add(treenode); treenode=treenode.right; &#125; else &#123; treenode=stack.pop().left; &#125; &#125; Collections.reverse(res); return res; &#125;","path":"2020/05/19/145. 二叉树的后序遍历/"},{"title":"232. 用栈实现队列","text":"双栈实现队列，思路较为简单 ···class MyQueue { private Stack stack1; private Stack stack2; /* Initialize your data structure here. / public MyQueue() { stack1=new Stack(); stack2=new Stack(); } /** Push element x to the back of queue. */ public void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(stack2.isEmpty()) &#123; StackMove(stack1,stack2); &#125; int res=stack2.peek(); stack2.pop(); return res; &#125; /** Get the front element. */ public int peek() &#123; if(stack2.isEmpty()) &#123; StackMove(stack1,stack2); &#125; int res=stack2.peek(); return res; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); &#125; public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2) &#123; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; int a=stack1.peek(); stack2.push(a); stack1.pop(); &#125; &#125; &#125; } /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); boolean param_4 = obj.empty();*/···","path":"2020/05/19/232. 用栈实现队列/"},{"title":"225. 用队列实现栈","text":"队列实现栈主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。&lt;!—hexoPostRenderEscape:class MyStack &#123;&lt;/span&gt; private Queue&lt;Integer&gt; quene=new LinkedList&lt;Integer&gt;(); private int mytop=0; /* Initialize your data structure here. / public MyStack() &lt;/span&gt;&#123; &#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Push element x onto stack. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123; quene.offer(x); mytop=x; &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Removes the element on top of the stack and returns that element. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;i++) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=quene.poll(); quene.offer(a); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;) mytop=a; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; quene.poll(); &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Get the top element. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!quene.isEmpty()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mytop; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Returns whether the stack is empty. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &amp;#125; &#125; /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/19/225. 用队列实现栈/"},{"title":"","text":"linux短横线的区别rm -vf *** tar -xzvf ***.tar.gz gcc --version rm --help 从上面命令我们可以看出，绝大数命令有以下的规则： ① 参数前单杠的表明后面的参数是字符形式； ② 参数前双杠的则表明后面的参数是单词形式 tar xzvf ***.tar.gz tar -xzvf ***.tar.gz 两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下： ① 参数前有横的是System V风格。 ② 参数前没有横的是BSD风格。 System V和BSD两种风格的区别主要是： 系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。 System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。","path":"2020/05/18/linux短横线的区别/"},{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。&lt;!—hexoPostRenderEscape:方法一：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 int t=0; int flag=1;//正在记录数字 for(int i=0;i&lt;s.length();i++) &#123; Character ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; if(Character.isDigit(ch)) &#123; flag=0; int num=(int)(ch-&#x27;0&#x27;); t=t*10+num; &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)||ch.equals(&#x27;(&#x27;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#x27;)&#x27;)) &#123; op1.push(CalFormula(op1,op2)); &#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; op1.push(t); &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(t); flag=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; t=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; CalFormula(op1,op2); &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; CalFormula(Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op1 , Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op2) &amp;#123; Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op3=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt;();//数字栈 Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op4=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt;();//字符栈 &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;!op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;)) &amp;#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); // &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(op2.peek()); &amp;#125; op3.push(op1.peek()); op1.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;)) op2.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op4.isEmpty()) &amp;#123; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=op3.peek(); op3.pop(); &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b=op3.peek(); op3.pop(); &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op3.peek(); &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cal(&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt; ch,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num1) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(ch.equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;)) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num-num1; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num+num1; &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 方法2： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 Integer t=0; StringBuffer nu=new StringBuffer(&quot;&quot;); int flag=1;//正在记录数字 StringBuffer a=new StringBuffer(s); String str=a.reverse().toString(); for(int i=0;i&lt;str.length();i++) &#123; Character ch=str.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); flag=1; nu=new StringBuffer(&quot;&quot;); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag=0; &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)||ch.equals(&#x27;)&#x27;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#x27;(&#x27;)) &#123; CalFormula(op1,op2); &#125; &#125; if(flag==0) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#x27;)&#x27;)) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#x27;)&#x27;)) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#x27;-&#x27;)) return num-num1; else return num+num1; &#125; &#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。&lt;!—hexoPostRenderEscape:class Solution &#123;&lt;/span&gt; public int calculate(String s)&lt;/span&gt; &lt;/span&gt; &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 HashMap&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); map.put(&#x27;+&#x27;,1); map.put(&#x27;-&#x27;,1); map.put(&#x27;(&#x27;,-1); Integer t=0; int flag=1; Character ch; for(int i=0;i&lt;s.length();i++) &#123; ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t=0; flag=1; &#125; if(Character.isDigit(ch)) &#123; flag=0; t=t*10+(int)(ch-&#x27;0&#x27;); &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals(&#x27;(&#x27;)) &#123; flag=1; op2.push(ch); &#125; else if(ch.equals(&#x27;)&#x27;)) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#x27;(&#x27;)) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; op1.push(t); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty()) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op1.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op1.pop(); Character c=op2.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op2.pop(); op1.push(cal(c,b,a)); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Character ch,Integer num,Integer num1)&lt;/span&gt;&lt;/span&gt; &#123; if(ch.equals(&#x27;-&#x27;)) return num-num1; else return num+num1; &#125;&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/224. 基本计算器/"},{"title":"","text":"第九章EM算法及其推广9.1 import numpy as np y=[1,1,0,1,0,0,1,0,1,1] pai=0.46 p=0.55 q=0.67 theta=2 while(theta&gt;0.0001): u_next=[] for i in range(len(y)): a=pai*(p**y[i])*((1-p)**(1-y[i])) b=(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a/(a+b)) pai_next=0 p_next=0 q_next=0 tmp=0 pai_next=np.mean(u_next) p_next = sum(np.multiply(u_next,y))/sum(u_next) tmp=[1-u_next[i] for i in range(len(y))] q_next = sum(np.multiply(tmp,y))/sum(tmp) print(pai_next) print(p_next) print(q_next) print(&quot;\\n&quot;) theta=abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai=pai_next p=p_next q=q_next 求得&lt;!—hexoPostRenderEscape:0.4618628351139190.53459500378501120.6561346417857326 0.461862835113919070.53459500378501120.6561346417857326&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。&lt;!—hexoPostRenderEscape:import numpy as np x = np.array([[1, 2, 3], [4, 5, 6]]) array([[1, 2, 3],[4, 5, 6]])y = np.array([1, 2]) array([1, 2])z = np.array([1, 2, 3]) array([1, 2, 3])x + y 会报错x + z array([[2, 4, 6],[5, 7, 9]])&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法matlab会弄出几个虚拟的小pc，一个算i=1:30部分循环,一个算i=50:80部分循环,再来一个算i=90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i=1算到i=100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/matlab并行/"},{"title":"","text":"此网站可以查看公式写法","path":"2020/05/18/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/conda 安装 pytorch/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/cs231图像生成/"}],"categories":[],"tags":[]}