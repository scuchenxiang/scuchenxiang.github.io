{"meta":{"title":"TheSakura's Blog","subtitle":null,"description":null,"author":"chenxiang","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about-me","text":"","path":"about-me/index.html"},{"title":"categories","text":"","path":"categories/index.html"},{"title":"tags","text":"","path":"tags/index.html"}],"posts":[{"title":"并发编程","text":"基于并发进程的并发编程当父进程接受客户端的连接请求的时候,创建新的子进程为客户服务,这个需要注意的是,子进程会继承父进程文件描述符的副本,因此都指向同一个文件表的表项,因此需要父进程关闭他的连接描述符的副本,然后子进程需要关闭listen socket的副本,然后开始服务,服务完了关闭连接描述符的副本. 在linux中文件表是引用计数的,因此父进程关闭文件描述符,不会影响子进程 IO多路复用技术可以参考select,poll,epoll那一篇. 基于线程的并发线程有自己的栈,寄存器,程序计数器,线程ID,与其他线程共享虚拟地址空间. 主要区别是join和detach的区别. join会阻塞直到线程返回,需要被其他线程回收. detach不能被其他线程回收,内存资源在终止的时候由系统自动释放. 多线程的共享变量需要同步互斥,使用信号量. 经典的比如说是生产者消费者问题 它由三个信号量,一个mutex用来设置互斥访问的,一个是itemm,empty,分别是有多少东西,有多少空位 生产者: P(empty); P(mutex); 插入 V(mutex); V(itemm); 消费者: P(itemm) P(mutex); 删除 V(mutex); V(empty); 读者写者问题:我们考虑第一种问题,读者优先的问题.有两个信号量,mutex控制读者数目,w控制临界区&lt;!—hexoPostRenderEscape:读者:P(mutex)&lt;/span&gt;;readcnt++;if(readcnt==1) p(w);V(mutex)&lt;/span&gt;; 读信息 P(mutex)&lt;/span&gt;;readcnt—;if(readcnt==0) V(w)&lt;/span&gt;;V(mutex)&lt;/span&gt;; 写者:P(w)&lt;/span&gt;;写信息;V(w)&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 注意rand函数是线程不安全的,因为它依赖于之前一次的调用结果. 可重入性:当其被多个线程调用的时候,不会引用共享数据.可重入函数是线程安全函数的真子集. 死锁也需要注意","path":"2022/03/07/操作系统/并发编程/"},{"title":"异常控制流","text":"当有异常发生的时候，会通过一张异常表的跳转表来进行一个间接异常调用，到操作系统专门用来处理这种异常的异常处理程序中。 异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器中。 异常处理程序运行在内核模式下，因此对所有资源都有完全的访问权限。 异常的类别：中断，陷阱，故障，终止 中断 来自IO设备的信号，异步处理，总是返回下一条指令 陷阱，有意的异常，同步，总是返回下一条指令，陷阱的重要用途在于系统调用，与普通函数调用的区别在于，他是运行在内核模式下的。 故障，潜在可恢复的错误，同步，可能返回当前指令，经典的是缺页异常 终止，不可恢复的错误，同步，不会返回 内核模式与用户模式处理器通常用某个控制寄存器的模式位来提供进入内核模式的功能 从用户态变为内核态的唯一方法是异常 上下文切换操作系统使用上下文切换的异常控制流来实现多任务 上下文信息包括，程序计数器，寄存器，内核栈，内核数据结构，比如地址空间的页表，当前进程信息的进程表，已打开文件的文件表。 fork创建新的子进程，不完全与父进程相同，他们有相同的堆栈，代码段数据段，相同的打开文件描述符的副本，因此子进程可以读写父进程的任何文件，但是他们有不同的PID。 fork调用一次，返回两次，返回0，说明在子进程中，在父进程中返回子进程的PID。 父进程和子进程是并发执行的，相同的但是独立的地址空间，因为继承了文件描述符的副本，如果父进程写stdout，那么子进程也可以输出。 注意fork与execve的区别，fork创建父进程的复制品，有不同的pid，execve加载执行程序，他们有着相同的PID，新程序会覆盖当前进程的地址空间，没有创建新的进程。 回收子进程进程终止的时候是由父进程回收的，父进程是由内核指定的init进程（PID=1）回收的。 当父进程回收子进程时，内核将子进程的退出状态传给父进程，然后子进程被完全抛弃。 终止了但是还没回收的进程为僵尸进程。 waitpid可以等待子进程终止或者停止。 非本地跳转C语言提供的用户级的异常控制流形式，称为非本地跳转。通过setjmp和longjmp实现。 两者是配合使用的，setjmp在env缓冲区中保存当前调用环境吗，供longjmp使用。返回0，调用环境包括程序计数器，栈指针，通用目的寄存器。其返回值不能被赋值给变量。不过可以用在switch和if中。 longjmp从env缓冲区恢复调用环境，然后触发一次最近的初始化env的setjmp的返回 注意setjmp调用一次返回多次,longjmp从不返回. C++和java的异常机制是setjmp和longjmp更加结构化的版本,可以将catch认为setjmp,throw认为是longjmp. linux的几个命令ps,列出当前系统的进程 top,打印当前进程资源的使用PMAP 显示进程的内存映射. /proc 一个虚拟文件系统,以ASCII输出大量内核数据结构内容,用户可以读取这些内容,比如cat /proc/loadavg 信号linux信号允许进程和内核中断其他的进程, 信号使用主要分为发送信号和接收信号 发送信号:内核检测到上下文信息发送信号给目的进程 接收信号,目的进程被内核强迫对信号的发送做出反应,就接收了信号.如果忽略这个信号或者终止或者执行信号处理程序的用户层函数捕捉信号. 发出而没有被接收的称为待处理的信号,任何情况,一种类型都只会有一个待处理的信号.超过1的都会被丢弃. 如果进程阻塞某个信号,那么发送过来的不会被接收,只有阻塞解除之后才会被接收. 内核为每个进程在pending位向量中维护着待处理信号的集合,在blocked位向量中维护着被阻塞的信号的集合. 具体内容可以参考csapp第八章,关于代码的比较多.","path":"2022/03/06/操作系统/异常控制流/"},{"title":"虚拟内存","text":"内存映射将虚拟内存区域与磁盘中的对象关联起来叫做内存映射。 可以映射两种对象 linux的普通文件，内存中映射文件的连续的一块，如果这一块区域比较小，那么就补0， 匿名文件，也叫请求二进制0的页面，他是由内核创建的全是二进制0的。要么从物理内存中换一个页面出来，并且覆盖0，注意没有磁盘与内存没有数据传送。 在使用内存映射的时候，对象可分为共享的，或者私有的，如果是共享对象，那么对对象的任意修改都会反映到磁盘上，如果是私有的对象，不会反映到磁盘上，而是使用写时复制的思想来处理。就是说只有对私有对象写的时候才复制，之前都是共享的，只保留一个物理副本，是只读的，如果写了，就会复制一个新的页面，然后指向新页面，让其可写。 fork函数就使用了写时复制的方法。 使用execve的时候，bss，堆栈是使用映射匿名文件，全0的 mmap函数就是为了创建一个新的虚拟内存区域，使其映射到一个文件的chunk，同时给定偏移量，长度。","path":"2022/03/06/操作系统/虚拟内存/"},{"title":"静态链接和动态链接，库打桩，位置无关代码","text":"主要是为了将一些可重定位目标文件链接为可执行的目标文件。 目标文件主要包括三种： 可重定位目标文件，可执行目标文件，共享目标文件链接的主要完成的有两点，符号解析和地址重定位 符号解析主要是为了解析函数符号，全局变量的符号，static的符号，主要是为了将符号引用与符号定义关联起来。为什么不需要对局部变量进行符号解析呢，因为在文件内部可以找到，不需要链接。 符号解析主要是通过将每个引用同输入的可重定位目标文件的符号表中的一个条目对应起来局部变量的符号解析比较简单，静态局部变量会有本地链接器的符号，编译器需要确保有唯一的名字， 如果碰到当前模块没有定义的符号，会假设是其他某个模块定义的，然后生成一个链接器符号表条目，交给链接器处理，然后去其他模块中找，没找到就会报错。 如果出现重名的全局符号，要么选出一个抛弃其他的，要么报错。重名时根据符号强弱来选择，已经初始化的为强符号，没有初始化的为弱符号。 多个强符号报错，一个强多个弱，选强，如果多个弱，任意选一个 对于函数C++和JAVA都会用方法和参数列表组合出一个对链接器唯一的名字，叫函数重整。 地址重定位汇编器生成的是从0开始的代码和数据节，链接器通过把每个符号同一个内存位置关联起来，重定位这些节，然后修改对这些符号的引用，使其指向这个位置，链接器使用汇编器产生的重定位条目。 主要包含两个，重定位节和符号定义，重定位节中的符号引用 重定位节和符号定义(确定符号和节的地址)将所有相同类型的节合并成聚合的节，然后将运行时的内存地址赋给新的聚合节，赋给输入模块的定义每个符号，此时全局变量和每条指令都有唯一的运行地址了。 重定位节中的符号引用（确定每个符号引用的地址）修改代码节和数据节中对每个符号的引用，使其指向正确的运行时地址，这一个步骤依赖于重定位条目。 重定位条目是由于目标模块不知道函数和代码具体存放在内存的位置。也不知道外部定义的函数和全局变量的位置，所以生成重定位条目用来后面生成可执行文件时的修改。 重定位条目包含 offset 被修改的引用的节偏移 type 告诉链接器如何修改新的引用 主要有两种常用类型，R_X86_64_PC32,,重定位一个32位PC相对地址的引用，例如当进行PC相对寻址的时候，这个数加上PC值得到有效地址，例如call的地址。 R_X86_64_32，重定位一个使用32位绝对地址的引用，CPU直接使用这个绝对地址作为有效地址，不需要进一步修改。 addend 有符号常熟，对一些类型的重定位需要使用其对被修改引用的值做偏移调整 symbol 表示被修改的引用应该指向的符号 重定位符号引用 可重定位目标文件包含的内容 ELF头 .text 已经编译的机器代码 .rodata 只读数据，例如printf的格式串 .data 已经初始化的全局数据和静态数据 .bss 未初始化的全局数据和静态数据,不占实际空间,分配在符号表中以及段表中,实际运行才会分配空间. .systab 符号表，存放文件引用的全局变量和函数信息（不包含局部变量），静态变量也在符号表中，局部变量放在栈中管理。 符号表的每个条目由一个结构体表示，包含name，type，section(目标文件的哪个节)，其中有三个特殊的伪节（只在可重定位目标文件才有，可执行文件中没有），UNDEF（未定义的符号），ABS(不该被重定位的符号)，COMMON(未被分配位置的未初始化的数据目标)，value，size。 COMMON主要代表未初始化的全局变量，bss主要代表未初始化的静态变量以及初始化未0的全局和静态变量 .rel.text .text 节中位置的列表，当链接器将这个文件和其他文件组合的时候需要修改，即任何调用外部函数时候都需要修改这些位置，调用本地文件不需要 .rel.data 被模块引用的全局变量的重定位信息。 .debug 调试符号表，文件中定义的局部变量，以及其类型 .line .text中的行号和对应的机器指令的映射 .strtab 字符串表 节头部表 静态链接当与静态库进行链接的时候，构建出的可执行文件实际上只复制静态库中引用的目标模块， 它只需要包含较少的模块。linux中静态库以存档的形式放在磁盘中，是一组连接起来的可重定位目标文件的集合，有头部描述每个文件的大小和位置，存档文件为.a文件。 假设有可重定位目标文件集合E，未解析的符号U，前面输入文件定义的符号集合D。 静态链接的时候是从左到右扫描，添加符号，如果文件是目标文件，那么就会添加到E中，然后修改U，D。 如果是静态库中的每个可重定位目标文件，那么就会比较U中的符号这个文件中有没有，有就添加到E，然后修改U，D，如果没有那么直接丢弃。 但是如果定义的符号的库出现在引用符号的库之前，那么就会链接失败，所以顺序很重要。 所以我们一般把库都放在链接命令的末尾，如果各个库之间没有相互引用，那么顺序是任意的，如果有相互引用，那么需要按照一定的顺序 可执行目标文件ELF头 描述总体格式，程序的入口点 段头部表 .init 初始化代码时调用的 .text .rodata .data .bss 其他的像符号表可重定位条目都没了 加载器加载可执行目标文件时在linux中使用execve函数来调用，在程序头部表的引导下，然后将可执行目标文件的片（chunk）代码和数据复制到内存，然后跳转到第一个入口点（_start）运行该程序。这个入口是在系统目标文件ctrl.o中定义的，然后_start调用__libc_start_main,此函数定义在libc.o中，它初始化环境，调用用户的main函数，处理返回值，需要时将控制返回给内核。 实际上当父shell进程生成一个子进程的时候，foke继承父进程的所有内容，然后删除子进程的虚拟内存段，然后创建新的代码数据，堆栈段，并用虚拟地址空间的页映射可执行目标文件的片（chunk），代码段和数据段初始化为可执行文件的内容。然后跳到_start，执行main 代码段总是从0x400000开始，然后地址从低到高分别是数据段，堆，栈，内核内存。 数据段要求内存对齐，因此有间隙， 动态链接共享库静态链接的缺点在于每次需要复制静态库中的模块到最终的文件中，同时如果静态库更新了，需要重新链接。使用动态共享库使得每次运行或者加载的时候才将文件加载到内存中，进行连接，重定位符号引用，不需要复制模块，只复制一些符号表和重定位信息，而且只有一个副本，由不同的进程共享 linux 中dlopen函数用来在运行的时候加载和链接共享库 JAVA JNI(java native interface)java本地接口他是将本地的C函数foo编译到一个共享库中，然后当正在运行的java程序试图调用foo时，会使用dlopen动态链接和加载foo.so，然后调用foo 位置无关代码（PIC)可以加载而无需重定位的代码称为PIC，使用-fpic，生成pic代码，共享库的生成总是需要这个选项，对于共享文件内部，是不需要做什么的，因为进行引用的时候直接用PC相对寻址就好，但是外部过程和全局变量需要特殊的技巧。 PIC数据引用有一个事实是这样的：无论在内存的哪里加载目标模块（包括共享目标模块），数据段和代码段的距离总是不变的。 同时在数据段中会有一个全局偏移量表GOT，每个被这个模块引用的全局数据目标都有一个条目，动态链接器会重定位每个条目，使其包含正确的地址，比如说调用一个A，是在其他模块定义的，然后它就会去通过GOT间接访问。 PIC函数调用使用了延迟绑定技术，即将过程地址的绑定推迟到第一次调用该过程时候。优点在于当一个共享库的函数太多的时候，将地址绑定推迟到第一次调用时，可以减少很多不需要的重定位，虽然第一次很慢，但是后面都很快，只需要一条指令和一个间接的内存引用。 他是通过GOT和过程链接表PLT实现的，GOT属于数据段，PLT数据代码段。 第一次的时候，会先跳到PLT，然后跳到对应的GOT，然后跳到PLT，然后在栈中压入一些参数，然后跳到动态链接器，使用栈中的条目确定函数地址，然后重写GOT的内容，再调用函数。 后面每次就直接会先跳到PLT，然后跳到对应的GOT，然后跳到对应函数。 库打桩机制它可以截获对共享库函数的调用，转而执行我们自己的代码。 可以在编译时，运行时，或者加载和链接时刻。 编译时打桩在编译的时候的命令行参数加入-I. ，此时会进行打桩，在搜索系统目录的时候优先搜索当前目录。 链接时打桩例如使用—wrap f 标志进行链接时打桩，这个会将f符号解释为wrap_f，将real_f的符号解释为f。 运行时打桩编译时打桩需要访问程序的源代码，链接时打桩需要访问程序的可重定位对象文件。运行时打桩只需要访问可执行目标文件。 它基于动态链接器的LD_PRELOAD.将LD_PRELOAD设置为一个路径，然后当加载和执行一个程序的时候，需要解析其他未定义的引用的时候，会优先搜索LD_PRELOAD库，然后才搜索其他的库。","path":"2022/03/06/操作系统/静态链接和动态链接/"},{"title":"C++运行时的内存映像","text":"主要分为这几个部分， 地址从高到低 系统内核的内存 栈的内存，由高地址向低地址延申 共享库的内存映射区域 堆内存，由低地址向高地址延申 已经初始化全局数据段和静态变量区data，以及未初始化的全局变量区和静态变量bss 只读代码段","path":"2022/03/05/C++/C++运行时的内存映像/"},{"title":"cookie和session的区别","text":"1、由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车。 当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。 这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 2、思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。 有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 3、Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 所以，总结一下： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。","path":"2022/03/05/计算机网络/cookie和session的区别/"},{"title":"如何实现DNS劫持","text":"DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。具体实施步骤如下：1.获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。 2.控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取。 3.修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。 4.使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。 用户端的一些预防手段：直接通过 IP 地址访问网站，避开 DNS 劫持。由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。","path":"2022/03/05/计算机网络/如何实现DNS劫持/"},{"title":"DNS为什么使用UDP","text":"其实 DNS 的整个过程是既使用 TCP 又使用 UDP。 当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。 当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。","path":"2022/03/04/计算机网络/DNS为什么使用UDP/"},{"title":"TCP的最大连接数目","text":"如何标识一个TCP连接在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。 client最大tcp连接数client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535，这些连接可以连到不同的server ip。 server最大tcp连接数server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。 实际的tcp连接数上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。 对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万 是没问题的，国外 Urban Airship 公司在产品环境中已做到 50 万并发 。在实际应用中，对大规模网络应用，还需要考虑C10K 问题。","path":"2022/03/04/计算机网络/TCP的最大连接数目/"},{"title":"IP地址和MAC地址作用的区别","text":"简单着说，IP 地址主要用来网络寻址用的，就是大致定位你在哪里，而 MAC 地址，则是身份的唯一象征，通过 MAC 来唯一确认这人是不是就是你，MAC 地址不具备寻址的功能。 IP 地址是基于逻辑的，比较灵活，不受硬件的限制，也容易记忆。而 MAC地址在一定程度上与硬件一致，是基于物理的，能够标识具体的网络节点。这两种地址各有优点，使用时也因条件不同而采取不同的地址 [6] 。 大多数接入Internet的方式是把主机通过局域网组织在一起，然后再通过交换机或路由器等设备和 Internet 相连接。这样一来就出现了如何区分具体用户，防止 IP地址被盗用的问题。由于IP地址只是逻辑上的标识，任何人都能随意修改，因此不能用来具体标识一个用户。而 MAC地址则不然，它是固化在网卡里面的。从理论上讲，除非盗来硬件即网卡，否则一般是不能被冒名顶替的。基于 MAC 地址的这种特点，因此局域网采用了用MAC地址来标识具体用户的方法 。 在具体的通信过程中，通过交换机内部的交换表把 MAC地址和 IP 地址一一对应。当有发送给本地局域网内一台主机的数据包时，交换机首先将数据包接收下来，然后把数据包中的 IP 地址按照交换表中的对应关系映射成 MAC地址，然后将数据包转发到对应的 MAC地址的主机上去。这样一来，即使某台主机盗用了这个 IP 地址，但由于此主机没有对应的 MAC地址，因此也不能收到数据包，发送过程和接收过程类似 。 所以，无论是局域网，还是广域网中的计算机之间进行通信时，最终都表现为将数据包从某种形式的链路上的一个初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的传递都是由 ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到 MAC地址上来完成的 。 身份证就是用来证明一个人的身份。平日身份证的作用并不是很大，但是到了有的关键时刻，必须有身份证来说明一个人的一切。那么，IP地址与MAC地址绑定，就如同在日常生活中一个人与身份证的关系。因为，IP地址可以随意的，但MAC地址是唯一说明IP地址身份的。 从上面看如果没有ip地址，只用mac地址，那么很难进行网络寻址，不知道目标主机在哪个区域，但是mac地址就是在局域网中映射成mac地址，然后转发给那个主机，确保是你，没有被冒用。","path":"2022/03/04/计算机网络/IP地址和MAC地址的区别是什么/"},{"title":"IPV4不够如何解决","text":"目前主要有以下两种方式： 1、其实我们平时上网，电脑的 IP 地址都是属于私有地址，我无法出网关，我们的数据都是通过网关来中转的，这个其实 NAT 协议，可以用来暂缓 IPV4 地址不够，关于 NAT，具体可以看我写的这篇文章：什么是 NAT 网络地址转换协议？ 2、IPv6 ：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个IP地址，该协议能够从根本上解决 IPv4 地址不够用的问题。 NAT协议：在私有地址和全局地址之间转换的协议。 就是使得私有ip通过转换成网关的地址和ip去访问东西，然后返回结果时再映射为私有地址。 首先什么是私有地址？私有地址是不能用在Internet上(路由器将丢弃寻址这种地址的包)的内部地址。这些地址是不能够在公网上面用的，只能用在局域网的内部。私有地址有三种：①10.0.0.0~10.255.255.255/8 ②172.16.0.0~172.31.255.255/12 ③192.168.0.0~192.168.255.255/16 这些IP地址是用于私有的网络。与之对应的是全局地址，就是正规的自己电脑的地址，全网络承认。比如说，每个人都有自己的大名，走到哪里都能被承认，这就是自己的全局地址；但是在班级里面的外号，就是私有地址，只有班级里面的人知道，在外面别人都不知道这个外号对应的是谁。 、","path":"2022/03/04/计算机网络/IPV4不够如何解决/"},{"title":"ICMP以及相关应用","text":"ICMP 主要有两个应用，一个是 Ping，一个是 Traceroute。 1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。","path":"2022/03/04/计算机网络/ICMP以及相关的应用/"},{"title":"SYN洪水攻击","text":"SYN Flood 又称 SYN 洪水攻击，也是拒绝服务攻击的一种，是一种曾经很经典的攻击方式。攻击者利用TCP协议的安全缺陷，不断发送一系列的SYN请求到目标系统，消耗服务器系统的资源，从而导致目标服务器不响应合法流量请求。 在谈SYN flood 之前，我们先了解一下一次正常的网络请求都有哪些步骤，从而更清晰的了解SYN Flood的攻击方式。 一般一次正常的网络请求分以下几个步骤： 域名解析 TCP握手建立链接 客户端发起请求 服务器响应请求 客户端解析并且渲染页面 至此一次请求结束。 而此种攻击正是发生在TCP握手的阶段。TCP握手一般分为三步。客户端发送SYN请求数据包。服务器回复（ACK）确认包。客户端再次回复（ACK）确认包。至此，TCP握手阶段结束。 SYN Flood / SYN 洪水攻击原理为了创建拒绝服务，攻击者利用的正是TCP协议的安全缺陷。在接收到初始SYN数据包之后，服务器用一个或多个SYN / ACK数据包进行响应，并等待握手中的最后一步。这是它的工作原理。 此种攻击是攻击者向目标服务器发送大量的SYN数据包，服务器会响应每一个请求然后返回ACK确认包，并且等待客户端的最终响应。 因为攻击者通常会采用虚拟ip，所以也就意味着服务器永远不可能接收到最终的确认包。这种情况下当服务器未接收到最终ACK数据包的时候，服务端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接。 这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况（伪造IP地址），那么服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源。从而造成服务器的崩溃，即使你的服务器系统资源够强大，服务端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小）。 此时，正常用户就会觉得服务器失去响应，这种情况就叫做，服务端收到了SYN Flood攻击（SYN 洪水攻击）","path":"2022/03/04/计算机网络/SYN洪水攻击/"},{"title":"TIME_WAIT 状态会导致什么问题，怎么解决","text":"我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。 解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。 下面是读者提供的具体操作 修改配置文件：/etc/sysctl.conf net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。","path":"2022/03/04/计算机网络/过多的TIME_WAIT 状态会导致什么问题，怎么解决/"},{"title":"HTTP 长连接短连接使用场景是什么","text":"长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个 TCP 连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多， 所以每个操作完后都不断开，下次处理时直接发送数据包就 OK 了，不用建立 TCP 连接。例如： 数据库的连接用长连接， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket创建也是对资源的浪费。 而像 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的 资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源， 如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接。","path":"2022/03/04/计算机网络/HTTP长连接和短连接的场景区别/"},{"title":"DNS的解析过程","text":"主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。 本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。 域名缓存为了提升域名查询效率，设计了域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间（即TTL值）的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。 目前，除了传统的递归DNS服务器（如运营商的Local DNS, 114dns,Google public DNS等）外，计算机中DNS记录在本地也有两种缓存方式：浏览器缓存和操作系统(OS)缓存。在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问递归DNS服务器，然后递归DNS服务器会递归式的查找域名记录，然后返回结果。那么浏览器DNS缓存和操作系统DNS缓存又是怎样的呢？ 浏览器DNS缓存：首先，浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的DNS缓存时间，如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。常用的浏览器的DNS缓存时间如下：Chrome：为了加快访问速度，Google Chrome浏览器采用了预提DNS记录，在本地建立DNS缓存的方法，加快网站的连接速度。在Chrome地址栏中输入chrome://net-internals/#dns 就可以看各域名的DNS 缓存时间。默认，Chrome对每个域名会默认缓存60s： 操作系统DNS缓存：OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。 Linux：Linux系统的nscd服务可以实现DNS缓存的功能。nscd会缓存三种服务passwd,group,hosts，所以它会记录三个库，分别对应源/etc/passwd, /etc/hosts 和/etc/resolv.conf每个库保存两份缓存，一份是找到记录的，一份是没有找到记录的。每一种缓存都保存有生存时间（TTL）。其作用就是增加cache ，加快如DNS的解析等的速度。配置文件为/etc/nscd.conf 默认该服务在redhat或centos下是关闭的，可以通过services nscd start开启。缓存DB文件在/var/db/nscd下。可以通过nscd -g查看统计的信息 清除缓存 nscd -i passwd nscd -i group nscd -i hosts除了上面的方法，重启nscd服务同样可以达到清理cache的目的。","path":"2022/03/04/计算机网络/DNS的解析过程/"},{"title":"在浏览器中输入 URL 地址到显示主页的过程？","text":"DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手； 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求； 服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 连接结束。","path":"2022/03/04/计算机网络/浏览器输入网址到显示的过程/"},{"title":"什么是粘包以及如何解决","text":"在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界； 从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。 基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。 接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。 发送方产生粘包 采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。 接收方产生粘包 接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） 分包机制一般有两个通用的解决方法： 特殊字符控制； 在包头首都添加数据包的长度。 如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。 tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。","path":"2022/03/04/计算机网络/粘包是什么以及如何解决/"},{"title":"ARQ协议和停止等待协议","text":"停止等待协议停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认收到。 自动重传请求 ARQ 协议停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。 连续 ARQ 协议连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。","path":"2022/03/04/计算机网络/ARQ协议/"},{"title":"TCP协议是如何保证可靠传输的。","text":"数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据； 对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。 TCP 将对失序数据进行重新排序，然后才交给应用层； 丢弃重复数据：对于重复数据，能够丢弃重复数据； 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒； 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段； 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。","path":"2022/03/04/计算机网络/TCP 协议是如何保证可靠传输的？/"},{"title":"HTTP和HTTPS的区别","text":"Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份； Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： 1、端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443； 2、资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源； 3、开销：Https通信需要证书，而证书一般需要向认证机构购买； Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。 一般http中存在如下问题：请求信息明文传输，容易被窃听截取。 数据的完整性未校验，容易被篡改 没有验证对方身份，存在冒充危险 HTTPS 协议过程SSL握手协议的过程 握手阶段分成以下五步： 第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。 第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。 第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。 第四步，服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。 第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成&quot;对话密钥&quot;（session key），用来加密接下来的整个对话过程。 为什么非得这么麻烦，非要三个随机数呢？这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测 客户端是没有证书的，也就没有公钥和私钥。SSL握手阶段，服务器把证书传输给客户端，同时也就传输了公钥（公钥是证书的一部分）。 有一个问题？如何保证公钥传输正确，如何防止中间人攻击？ 找到一个拥有公信力、大家都认可的认证中心(CA)。 服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要 为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成数字签名。 并且，最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成数字证书 当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。 这样，就可以保证服务器的公钥安全着交给客户端了。从而防止了中间人攻击。 由客户端来对这个证书进行有效性认可，再由这个客户端来生成对称密钥。对称密钥用服务器证书中的公钥加密后，传回给服务器。只有服务器才能解密这个信息，也就只有服务器才知道你的对称密钥。只要这个SSL连接没有关闭，后续的所有数据，无论是客户端发出的还是服务器发出的，均会使用这个对称密钥加密。对称加密算法中，依赖的是密钥的保密性，只要密钥没有被泄露，对称加密的结果被截获也没有什么意义。而密钥是用公钥加密的，只能由服务器解开。 HTTPS的缺点HTTPS协议多次握手，导致页面的加载时间延长近50%； HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗； 申请SSL证书需要钱，功能越强大的证书费用越高。 SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。","path":"2022/03/04/计算机网络/HTTP和HTTPS的区别/"},{"title":"讲一下网络五层模型，每一层的职责？","text":"天各一方的两台计算机是如何通信的呢？ 在成千上万的计算机中，为什么一台计算机能够准确着寻找到另外一台计算机，并且把数据发送给它呢？可能很多人都听说过网络通信的 5 层模型，但是可能并不是很清楚为什么需要五层模型，五层模型负责的任务也有可能经常混淆。 下面是网络通信的五层模型 说实话，五层模型的具体内容还是极其复杂的，不过今天这篇文章，我将用最简洁的模式，通过网络通信的五层模型来讲解一台计算机是如何找到另外一台计算机并且把数据发送给另一台计算机的，就算你没学过计算机网络，也能够听的懂。 1. 物理层 一台计算机与另一台计算机要进行通信，第一件要做的事是什么？ 当然是要把这台计算机与另外的其他计算机连起来啊，这样，我们才能把数据传输过去。 例如可以通过光纤啊，电缆啊，双绞线啊等介质把他们连接起来，然后才能进行通信。 也就是说，物理层负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。 2. 数据链路层 前面说了，物理层它只是单纯着负责把计算机连接起来，并且在计算机之间传输0，1这样的电信号。 如果这些0，1组合的传送毫无规则的话，计算机是解读不了的。 一大堆0，1谁知道是什么鬼啊。 因此，我们需要制定一套规则来进行0，1的传送。 例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等等。 于是，有了以太网协议。 1. 以太网协议以太网协议规定，一组电信号构成一个数据包，我们把这个数据包称之为帧。 每一个桢由标头(Head)和数据(Data)两部分组成。 帧的大小一般为 64 – 1518 个字节。 假如需要传送的数据很大的话，就分成多个桢来进行传送。 对于表头和数据这两个部分，他们存放的都是一些什么数据呢？ 我猜你眯着眼睛都能想到他们应该放什么数据。 毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？ 所以标头部分主要是一些说明数据，例如发送者，接收者等信息。 而数据部分则是这个数据包具体的，想给接守者的内容。 大家想一个问题，一个桢的长度是 64~1518 个字节，也就是说桢的长度不是固定的，那你觉得标头部分的字节长度是固定的吗？ 它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道标头是几个字节，数据是几个字节呢。 所以标头部分的字节是固定的，并且固定为18个字节。 把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，，你总得给他们一个唯一的标识吧？ 于是，MAC 地址出现了。 2. MAC 地址连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。 计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。 MAC地址 由 48 个二进制位所构成，在网卡生产时就被唯一标识了。 3. 广播与ARP协议(1). 广播如图，假如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是它要怎么给它传送数据呢？ 计算机 A 不仅连着计算机 B，而且计算机 A 也还连着其他的计算机。 虽然计算机 A 知道计算机 B 的 MAC 地址，可是计算机 A 却不知道知道计算机 B 是分布在哪边路线上，为了解决这个问题，于是，有了 广播的出现。 在同一个子网中，计算机 A 要向计算机 B 发送一个数据包，这个数据包会包含接收者的 MAC 地址。 当发送时，计算机 A 是通过广播的方式发送的，这时同一个子网中的计算机 C, D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的 MAC 地址取出来，与自身的 MAC 地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。 这种发送方式我们称之为广播,就像我们平时在广场上通过广播的形式呼叫某个人一样，如果这个名字是你，你就理会一下，如果不是你，你就当作听不见 (2). ARP 协议。那么问题来了，计算机 A 是如何知道计算机 B 的 MAC 地址的呢？ 这个时候就得由 ARP 协议这个家伙来解决了，不过 ARP 协议会涉及到IP地址，我们下面才会扯到IP地址。 因此我们先放着，就当作是有这么一个 ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。 3. 网络层上面我们有说到子网这个关键词，实际上我们所处的网络，是由无数个子网络构成的。 广播的时候，也只有同一个子网里面的计算机能够收到。 假如没有子网这种划分的话，计算机 A 通过广播的方式发一个数据包给计算机 B , 其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。 世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。 那还不得奔溃。 因此产生了子网这么一个东西。 那么问题来了，我们如何区分哪些 MAC 地址是属于同一个子网的呢？ 假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发。 为了解决这个问题，于是，有了 IP 协议。 3. DNS服务器这里再说一个问题，我们是如何知道对方计算机的IP地址的呢？ 这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。 这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入 www.baidu.com 这个域名。 其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。 因此，网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。 4. 传输层通过物理层、数据链路层以及网络层的互相帮助，我们已经把数据成功从计算机A传送到计算机B了，可是，计算机B里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？ 这个时候，端口(Port)这个家伙就上场了，也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。 也就是说，传输层的功能就是建立端口到端口的通信。 相比网络层的功能是建立主机到主机的通信。 也就是说，只有有了IP和端口，我们才能进行准确着通信。 这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。 其实呢，对于有些传输协议，已经有设定了一些默认端口了。 例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。 传输层最常见的两大协议是 TCP 协议和 UDP 协议，其中 TCP 协议与 UDP 最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。 5. 应用层终于说到应用层了，应用层这一层最接近我们用户了。 虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。 你确定你能看的懂？ 因此我们需要指定这些数据的格式规则，收到后才好解读渲染。 例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。 总结五层模型至此讲到这里。 对于有些层讲的比较简洁，就随便概况了一下。 因为如果我说的详细一点的话，篇幅肯定会特别特别长，我着已经是尽最大的努力以最简洁的方式来讲的了。 如果你想详细去了解，可以去买计算机网络相应的资料，强烈推荐《计算机网络：自顶向下》这本书。 希望我的讲解能让你对计算机之间数据的传输有个大概的了解。 1. IP协议IP协议，它所定义的地址，我们称之为IP地址。 IP协议有两种版本，一种是 IPv4,另一种是 IPv6。 不过我们目前大多数用的还是 IPv4，我们现在也只讨论 IPv4 这个版本的协议。 这个 IP 地址由 32 位的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255。 每一台想要联网的计算机都会有一个IP地址。 这个IP地址被分为两部分，前面一部分代表网络部分，后面一部分代表主机部分。 并且网络部分和主机部分所占用的二进制位数是不固定的。 假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是处于同一个子网中。 例如 192.168.43.1 和 192.168.43.2, 假如这两个 IP 地址的网络部分为 24 位，主机部分为 8 位。 那么他们的网络部分都为 192.168.43，所以他们处于同一个子网中。 可是问题来了，你怎么知道网络部分是占几位，主机部分又是占几位呢？ 也就是说，单单从两台计算机的IP地址，我们是无法判断他们的是否处于同一个子网中的。 这就引申出了另一个关键词————子网掩码。 子网掩码和IP地址一样也是 32 位二进制数，不过它的网络部分规定全部为 1，主机部分规定全部为 0.也就是说，假如上面那两个IP地址的网络部分为 24 位，主机部分为 8 位的话，那他们的子网掩码都为 11111111.11111111.11111111.00000000，即255.255.255.0。 那有了子网掩码，如何来判端IP地址是否处于同一个子网中呢。 显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位。 我们只需要把 IP 地址与它的子网掩码做与(and)运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。 例如，192.168.43.1和192.168.43.2的子码掩码都为255.255.255.0，把IP与子码掩码相与，可以得到他们都为192.168.43.0，进而他们处于同一个子网中。 2. ARP协议有了上面IP协议的知识，我们回来讲一下ARP协议。 有了两台计算机的IP地址与子网掩码，我们就可以判断出它们是否处于同一个子网之中了。 假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。 我们可以通过ARP协议来得到计算机B的MAC地址。 ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。 对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。 这样，计算机A就能知道计算机B的MAC地址了。 可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？ 其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。 假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送 注意ARP协议arp协议在，在OSI模型中属于链路层。 arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。 它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。 arp协议，也称地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。","path":"2022/03/04/计算机网络/讲一下网络五层模型，每一层的职责/"},{"title":"SQL注入","text":"SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 1). SQL注入攻击的总体思路 (1). 寻找到SQL注入的位置 (2). 判断服务器类型和后台数据库类型 (3). 针对不同的服务器和数据库特点进行SQL注入攻击 2). SQL注入攻击实例 比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录： 用户名： ‘or 1 = 1 — 密 码： BashCopy 用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢? 下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句： String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; JavaCopy 因此，当输入了上面的用户名和密码，上面的SQL语句变成： SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’ JavaCopy 分析上述SQL语句我们知道，username= or 1=1 这个语句一定会成功；然后后面加两个 -，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。 应对方法 (1). 参数绑定 使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和$来获取参数值。 当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入； 当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。 (2). 使用正则表达式过滤传入的参数","path":"2022/03/04/计算机网络/SQL注入/"},{"title":"IP地址分类（A类 B类 C类 D类 E类）","text":"IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。 全0和全1的都保留不用。 A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。 B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。 C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。 D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。 E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。 在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：A类地址：10.0.0.0～10.255.255.255B类地址：172.16.0.0～172.31.255.255C类地址：192.168.0.0～192.168.255.255 回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。","path":"2022/03/04/计算机网络/IP地址分类（A类 B类 C类 D类 E类）/"},{"title":"TCP滑动窗口和拥塞控制详解","text":"滑动窗口（流量控制）滑动窗口的定义： 1.“窗口”对应的是一段可以被发送的字节序列，其连续的范围称为窗口；2.“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。 滑动窗口的作用： 是一种流量控制方法，该协议允许发送方在停止等待确认前可以连续发送发个分组。由于发送方不必每发送一个分组就停下来等待确认，因此该协议可以加速数据的传输。 1 TCP协议的两端分别是发送者A和接受者B，由于是全双工通讯的，因此A and B应该同时维护着一个独立的发送缓冲区和接受缓冲区，由于对等性，我们以A发送B接受的情况作为例子； -2 发送窗口是发送缓存的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区了；当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。 -3 发送窗口相关的四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）；已发送但未收到确认的数据（位于发送窗口之中）；允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不需要发送的数据。 -4 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。(即受到接收方的ACK) 当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。 拥塞控制原理 原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。主要用三种方法： 慢启动阈值 + 拥塞避免 快速重传 快速恢复 慢启动阈值 + 拥塞避免对于拥塞控制来说，TCP 主要维护两个核心状态： 拥塞窗口（cwnd） 慢启动阈值（ssthresh）在发送端使用拥塞窗口来控制发送窗口的大小。 然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。 然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮 RTT，拥塞窗口翻倍，现在每一轮就加一个。 快速重传在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间） 选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包 快速恢复如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段： 会将拥塞阈值降低为 拥塞窗口的一半 然后拥塞窗口大小变为拥塞阈值 接着 拥塞窗口再进行线性增加，以适应网络状况","path":"2022/03/04/计算机网络/TCP滑动窗口和拥塞控制机制详解/"},{"title":"在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？","text":"在 HTTP 中响应体的 Connection 字段指定为 keep-aliveconnetion:keep-alive;","path":"2022/03/04/计算机网络/在交互过程中如果数据传送完了_还不想断开连接怎么办_怎么维持/"},{"title":"HTTP状态码301和302的区别，都有哪些用途？","text":"一. 301重定向的概念301重定向（301 Move Permanently），指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息（header）中包含状态码 301 ，表示该资源已经永久改变了位置。 301重定向是一种非常重要的”自动转向“技术，网址重定向最为可行的一种方法。 二. 哪些情况需要做301重定向？网页开发过程中，时常会遇到网站目录结构的调整，将页面转移到一个新地址；网页扩展名的改变，这些变化都会导致网页地址发生改变，此时用户收藏夹和搜索引擎数据库中的旧地址是一个错误的地址，访问之后会出现404页面，直接导致网站流量的损失。或者是我们需要多个域名跳转至同一个域名，例如本站主站点域名为 www.conimi.com ，而还有一个域名 www.nico.cc，由于对该域名设置了301重定向，当输入www.nico.cc 时，自动跳转至 www.conimi.com 。 三. 301重定向有什么优点？有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。例如 www.conimi.com和 conimi.com 是两个不同的域名，但是指向的内容完全相同，搜索引擎会对两个域名收录情况不同，这样导致网站权重和排名被分散；对conimi.com 做301重定向跳转至www.conimi.com 后，权重和排名集中到www.conimi.com，从而提升自然排名。 四. 302重定向又是什么鬼？302重定向（302 Move Temporarily），指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用。 五. 301与302的区别302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。","path":"2022/03/04/计算机网络/HTTP状态码301和302的区别，都有哪些用途？/"},{"title":"HTTP常用状态码","text":"状态码分类1xx：表示目前是协议的中间状态，还需要后续请求 2xx：表示请求成功 3xx：表示重定向状态，需要重新请求 4xx：表示请求报文错误 5xx：服务器端错误 常用状态码101 切换请求协议，从 HTTP 切换到 WebSocket 200 请求成功，有响应体 301 永久重定向：会缓存 302 临时重定向：不会缓存 304 协商缓存命中 403 服务器禁止访问 404 资源未找到 400 请求错误 500 服务器端错误 503 服务器繁忙","path":"2022/03/04/计算机网络/HTTP常用状态码/"},{"title":"GET 和 POST的区别","text":"使用场景GET 用于获取资源，而 POST 用于传输实体主体。 参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中， 而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。 安全性安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：","path":"2022/03/04/计算机网络/POST与GET区别/"},{"title":"HTTP 1和1.1和2的区别","text":"HTTP1HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接， HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。 HTTP1.0 其实也可以强制开启长链接，例如接受Connection: keep-alive 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 HTTP1.1为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。 由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。 HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 HTTP2HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。 也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。 而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。 除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。 Header压缩就是压缩老板和员工之间的对话。 服务端推送就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。 目前，主流的HTTP协议还是HTTP/1.1 和 HTTP/2。并且各大网站的HTTP/2的使用率也在逐年增加。","path":"2022/03/03/计算机网络/HTTP1_1.1_2的区别/"},{"title":"TCP和UDP的区别","text":"TCP协议的主要特点（1）TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。 （2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的； （3）TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；（4）TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；（5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。 TCP的可靠性原理 可靠传输有如下两个特点:a.传输信道无差错,保证传输数据正确; b.不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据; （1）首先，采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。 （2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。 （3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。 UDP协议特点（１）UDP是无连接的传输层协议； （２）UDP使用尽最大努力交付，不保证可靠交付； （３）UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； （４）UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； （５）UDP支持一对一 一对多 多对多的交互通信； （６）UDP的首部开销小，只有８字节． TCP和UDP的区别(1)TCP是可靠传输,UDP是不可靠传输; (2)TCP面向连接,UDP无连接; (3)TCP传输数据有序,UDP不保证数据的有序性; (4)TCP不保存数据边界,UDP保留数据边界; (5)TCP传输速度相对UDP较慢; (6)TCP有流量控制和拥塞控制,UDP没有; (７)TCP是重量级协议,UDP是轻量级协议; (８)TCP首部较长２０字节,UDP首部较短８字节; （如果有可选字段那么TCP最多60） 基于TCP和UDP的常用协议 HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议 TCP 和 UDP 应用场景 TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 UDP应用场景： 效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播） udp如何实现可靠性传输？UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。 传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。 最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。 1、添加seq/ack机制，确保数据发送到对端 2、添加发送和接收缓冲区，主要是用户超时重传。 3、添加超时重传机制。 详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。 目前有如下开源程序利用udp实现了可靠的数据传输。分别为RUDP、RTP、UDT。","path":"2022/03/03/计算机网络/TCP和UDP区别/"},{"title":"TCP四次挥手","text":"刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。 2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。 3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态 5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。 至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。 这里我给出每个状态所包含的含义，有兴趣的可以看看。 LISTEN – 侦听来自远方TCP端口的连接请求； SYN-SENT -在发送连接请求后等待匹配的连接请求； SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认； ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认； FIN-WAIT-2 – 从远程TCP等待连接中断请求； CLOSE-WAIT – 等待从本地用户发来的连接中断请求； CLOSING -等待远程TCP对连接中断的确认； LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认； TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； CLOSED – 没有任何连接状态；","path":"2022/03/03/计算机网络/TCP四次挥手/"},{"title":"TCP三次握手","text":"三次握手 当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，我想很多人会这样回答： 首先很多人会先讲下握手的过程： 1、第一次握手：客户端给服务器发送一个 SYN 报文。 2、第二次握手：服务器收到 SYN 报文之后 3.第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。 4、服务器收到 ACK 报文之后，三次握手建立完成 作用是为了确认双方的接收与发送能力是否正常。 这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后 1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。 2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。 3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态。 4、服务器收到 ACK 报文之后，也处于 established 状态，此时，双方以建立起了链接 三次握手的作用也是有好多的，多记住几个，保证不亏。例如：1、确认双方的接受能力、发送能力是否正常。 2、指定自己的初始化序列号，为后面的可靠传送做准备。 1、（ISN）是固定的吗三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。 如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。 2、什么是半连接队列服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。 这里在补充一点关于SYN-ACK 重传次数的问题： 服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s, 3、三次握手过程中可以携带数据吗很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。 为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。 而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。","path":"2022/03/03/计算机网络/TCP三次握手/"},{"title":"计算机网络七层协议以及相关的功能是什么","text":"可以参考 https://www.cnblogs.com/schips/p/osi_framework_and_tcp-ip.html 应用层：负责给应⽤程序提供统⼀的接⼝； 表示层：数据格式的转换，以及一些压缩解压的功能，比如下层给过来的数据是二进制的，转换其为图片让人可以看到图片这就是数据转换。即对数据格式进行转换，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。 会话层：为网络设备提供会话的功能，过程中可能会有身份验证等功能，然后当进程终止时会话不一定是终止的，如果没超时，下次继续连接这个会话还存在，那么就不需要身份验证等事情了。 传输层：向上提供可靠的透明数据传输功能，是用于网络中两个进程之间的，处理数据包的错误等传输问题。 网络层：负责数据的路由、转发、分⽚； 链路层：负责数据的封帧和差错检测，以及 MAC 寻址； 物理层：负责在物理⽹络中传输数据帧； 在四层，既传输层数据被称作段（Segments）； 三层网络层数据被称做包（Packages）； 二层数据链路层时数据被称为帧（Frames）； 一层物理层时数据被称为比特流（Bits）。","path":"2022/03/03/计算机网络/计算机网络七层协议/"},{"title":"push_back and emplace difference","text":"push_back 和 emplace_back 的区别在哪里？ 回答emplace_back 能就地通过参数构造对象，不需要拷贝或者移动内存，相比 push_back 能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用 emplace_back 来代替 push_back。 下面的代码节选自 https://en.cppreference.com/w/cpp/container/vector/emplace_back，可以很好的解释它们的区别， #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; struct President &#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; &quot;I am being constructed.\\n&quot;; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; &quot;I am being moved.\\n&quot;; &#125; President&amp; operator=(const President&amp; other) = default; &#125;; int main() &#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; &quot;emplace_back:\\n&quot;; elections.emplace_back(&quot;Nelson Mandela&quot;, &quot;South Africa&quot;, 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; &quot;\\npush_back:\\n&quot;; reElections.push_back(President(&quot;Franklin Delano Roosevelt&quot;, &quot;the USA&quot;, 1936)); std::cout &lt;&lt; &quot;\\nContents:\\n&quot;; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; &quot; was re-elected president of &quot; &lt;&lt; president.country &lt;&lt; &quot; in &quot; &lt;&lt; president.year &lt;&lt; &quot;.\\n&quot;; &#125; &#125; 输出： emplace_back: I am being constructed. push_back: I am being constructed. I am being moved. Contents: Nelson Mandela was elected president of South Africa in 1994. Franklin Delano Roosevelt was re-elected president of the USA in 1936.","path":"2022/02/20/C++/C++_push_back相比emplace_back/"},{"title":"placement new and delete 用法","text":"运算符重载可以重载new and delete。 但是第一个参数必须为std::size_t size 必须返回值为void*，一般如果重载了new，也要 用相同参数重载delete，因为当使用了某种new，就会使用对应参数的delete来删除，如果没有定义，就不会调用，会发生内存泄漏 void * new(std::size_t size) &#123; return std:: malloc(size); &#125; Foo* m = new Foo; void* operator new(std::size_t size, void* ptr) &#123; std::cout &lt;&lt; &quot;placement new&quot; &lt;&lt; std::endl; return ptr; &#125; 如果加入其他形参，比如指针，就是placement new。就是实际上没有分配内存，返回了之前给的指针，实际上是用的之前的内存。 调用就像下面这样 Foo* m2 = new(m) Foo; 如果定义了placement new，就要使用placement delete，不然会发生内存泄漏。","path":"2022/02/14/C++/C++_placement_new/"},{"title":"STL:priority_queue 用法","text":"#include&lt;queue&gt; // 默认优先从小到大输出 std::priority_queue&lt;Type,Container,Functional&gt; //期中type是数据类型，第二个是保存数据的容器，第三个是元素比较函数，默认从大到小operator&lt; //容器默认为vectord //如果优先输出小数据则使用， priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; p; // less则是大顶堆，降序 //如果使用自定义的节点 struct node &#123; int x; int y; node(int a,int b):x(a),y(b)&#123;&#125; &#125;; struct cmp &#123; bool operator()(node a,node b) &#123; if(a.x==b.x) return a.y&gt;b.y; else return a.x&gt;b.x;//从小到大 &#125; &#125;; priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; p; 这里很容易混淆的一点是priority_queue是默认大顶堆的，所以a.x&lt;b.x是降序，a.x&gt;b.x是升序。 但是sort是默认升序的，所以a.x&lt;b.x是升序，a.x&gt;b.x是降序。 优先队列自定义排序方式 重载operater&lt;或operator&gt; 创建大顶堆时重载operator&lt;，对应less方法，元素降序 bool operator&lt;(node a,node b) &#123; if(a.x==b.x) return a.y&gt;b.y; else return a.x&lt;b.x;//从小到大 &#125; 创建小顶堆时重载operator&gt;，对应greater方法，元素升序 声明比较类cmp struct cmp &#123; bool operator()(node a,node b) &#123; if(a.x==b.x) return a.y&gt;b.y; else return a.x&gt;b.x;//从小到大 &#125; &#125;; 但是sort还多一个自定义比较函数cmp bool cmp(node a,node b) &#123; return a.x&lt;b.x; &#125; sort(vec.begin(),vec.end(),cmp()) 两个自定义函数对比 priority_queue有两种自定义方式：重载操作符和声明比较类；sort相比于前者增加一个定义比较函数； 默认排序方式不同：priority_queue默认为大顶堆，降序；sort默认升序 自定义运算方式不同：比如&quot;a &lt; b&quot;在priority_queue中代表降序，而在sort中代表升序 调用方式不同：定义比较类时，priority_queue调用过程中不需要&quot;()&quot;–&gt;cmp，而sort无论调用自定义比较函数还是比较类都需要加上&quot;()&quot;–&gt;cmp() 可以参考这篇文章 https://blog.csdn.net/wwrzzu/article/details/106177818","path":"2022/02/14/C++/STL_priority_queue用法/"},{"title":"signal和sigaction的用法","text":"参考博客 Linux进程间通信（一）： 信号 signal()、sigaction()一、什么是信号用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止。 信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。但它们还可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。 二、信号的种类信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，常用的信号如下：SIGINT一般是由终端敲击的ctrl+C组合键以及预先设置的中断字符 SIGUSR1,SIGUSR2,进程间使用这个信号通信，如报告状态信息 SIGPIPE，如果向管道写数据但是没有读进程就会产生这个信号。 三、信号的处理 —— signal()函数程序可用使用signal()函数来处理指定的信号，主要通过忽略和恢复其默认行为来工作。 void (signal(int sig, void (func)(int)))(int);这是一个相当复杂的声明，耐心点看可以知道signal是一个带有sig和func两个参数的函数，func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须为void func（int），或者是下面的特殊值： SIG_IGN : 忽略信号 SIG_DFL : 恢复信号的默认行为 四、信号处理 —— sigaction()函数前面我们看到了signal()函数对信号的处理，但是一般情况下我们可以使用一个更加健壮的信号接口 —— sigaction()函数。它的原型为： int sigaction(int sig, const struct sigaction act, struct sigaction oact); 该函数与signal()函数一样，用于设置与信号sig关联的动作，而oact如果不是空指针的话，就用它来保存原先对该信号的动作的位置，act则用于设置指定信号的动作。 sigaction结构体定义在signal.h中，但是它至少包括以下成员： void (*) (int) sa_handler：处理函数指针，相当于signal函数的func参数。 sigset_t sa_mask： 指定一个。信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被加入到进程的信号屏蔽字中。信号屏蔽字是指当前被阻塞的一组信号，它们不能被当前进程接收到 int sa_flags：信号处理修改器; sa_mask 的值通常是通过使用信号集函数来设置的，关于信号集函数，我将会在我的下一篇文章 —— Linux进程间通信——信号集函数，详细讲述。 sa_flags，通常可以取以下的值：例如SA_NODEFER,捕捉到信号时不添加到信号屏蔽字中。 此外，现在有一个这样的问题，我们使用signal()或sigaction()函数来指定处理信号的函数，但是如果这个信号处理函数建立之前就接收到要处理的信号的话，进程会有怎样的反应呢？它就不会像我们想像的那样用我们设定的处理函数来处理了。sa_mask就可以解决这样的问题，sa_mask指定了一个信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被加入到进程的信号屏蔽字中，设置信号屏蔽字可以防止信号在它的处理函数还未运行结束时就被接收到的情况，即使用sa_mask字段可以消除这一竞态条件。 五、发送信号上面说到的函数都是一些进程接收到一个信号之后怎么对这个信号作出反应，即信号的处理的问题，有没有什么函数可以向一个进程主动地发出一个信号呢？我们可以通过两个函数kill()和alarm()来发送一个信号。 1、kill()函数 先来看看kill()函数，进程可以通过kill()函数向包括它本身在内的其他进程发送一个信号，如果程序没有发送这个信号的权限，对kill()函数的调用就将失败，而失败的常见原因是目标进程由另一个用户所拥有。想一想也是容易明白的，你总不能控制别人的程序吧，当然超级用户root，这种上帝般的存在就除外了。 kill()函数的原型为： include include int kill(pid_t pid, int sig); 它的作用把信号sig发送给进程号为pid的进程，成功时返回0。 kill()调用失败返回-1，调用失败通常有三大原因： 1、给定的信号无效（errno = EINVAL)2、发送权限不够( errno = EPERM ）3、目标进程不存在( errno = ESRCH ) 2、alarm()函数 这个函数跟它的名字一样，给我们提供了一个闹钟的功能，进程可以调用alarm()函数在经过预定时间后向发送一个SIGALRM信号。 alarm()函数的型如下： alarm()函数用来在seconds秒之后安排发送一个SIGALRM信号，如果seconds为0，将取消所有已设置的闹钟请求。alarm()函数的返回值是以前设置的闹钟时间的余留秒数，如果返回失败返回-1。","path":"2021/12/26/C++/signal和sigaction/"},{"title":"select和poll和epoll的区别","text":"参考博客参考博客 参考博客参考博客 selectselect本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。 这带来缺点： FD_SETSIZE宏定义，其大小是32个整数的大小当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试 一般该数和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认1024个，64位默认2048 对socket是线性扫描，即轮询，效率较低： 仅知道有I/O事件发生，却不知是哪几个流，只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。 （1）使用copy_from_user从用户空间拷贝fd_set到内核空间 （2）注册回调函数__pollwait （3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll） （4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。 （5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。 （6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。 （7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。 （8）把fd_set从内核空间拷贝到用户空间。 缺点： 内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。 每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大 同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大 select支持的文件描述符数量太小了，默认最大支持1024个 主动轮询效率很低 poll 和select类似，只是描述fd集合的方式不同，poll使用pollfd结构而非select的fd_set结构。 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但poll没有最大文件描述符数量的限制。因为pollfd使用的是链表 poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。 它将用户传入的数组拷贝到内核空间 然后查询每个fd对应的设备状态： 如果设备就绪 在设备等待队列中加入一项继续遍历 若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。 没有最大连接数限制，因其基于链表存储，其缺点： 大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义 如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd epoll epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。 可理解为event poll，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。 epoll的触发模式，两种水平触发和边缘触发，EPOLLLT和EPOLLET两种： LTLT的一个例子 默认的模式（水平触发） 只要该fd还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作， ETET的一个例子 是“高速”模式（边缘触发），只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误 epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，epoll_wait便可收到通知。 若用EPOLLLT，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这大大降低处理程序检索自己关心的就绪文件描述符的效率。 而采用EPOLLET，当被监控的文件描述符上有可读写事件发生时，epoll_wait会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait时，它不会通知你，即只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。 epoll优点没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口） 效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。 epoll通过内核和用户空间共享一块内存来实现的 总结：在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。 epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。 对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。 对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，O(1)复杂度和select实现中的第7步是类似的）。 对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。","path":"2021/12/26/C++/select和epoll和poll的区别/"},{"title":"红黑树知识点","text":"一般来说红黑树有以下的知识点 根是黑色 叶节点是黑色的（即为空的黑色的哨兵节点） 从跟到叶子经过相同数目的黑色节点 红色节点的子节点一定是两个黑色的 节点为红色或者黑色 可以参考这个链接来使用30张图带你彻底理解红黑树 红黑树主要是通过左旋右旋和节点变色来实现的。这个左旋右旋和b树b+树的都是一样的。 红黑树查找与二叉搜索树差不多的，但是由于红黑树总是黑色平衡的，所以最坏是O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性 红黑树插入首先必须先找到插入位置，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。 一般来说加入红节点会破坏1或者4。 1. 如果此时树为空树，那么必须把插入的节点改成黑色。2. 如果插入的节点父节点为黑节点，那么可以直接插入。3. 如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论3.1 叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。3.2 叔叔节点为黑色或者不存在，且父亲是爷爷的左节点3.2.1 自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。3.2.2 自己插入的是父亲节点的右节点，对父亲节点左旋变成3.2.13.3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在且为黑色，那么自己的路径和叔叔路径的黑色数目就不一样了），且父亲是爷爷的右节点（是3.2的另外一个方向的版本） 3.3.1 自己插入的是父亲节点的左节点，右旋，变成3.3.2。3.3.2 自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。插入节点的key已经存在，那么此时更新节点的value。红黑树删除删除的情况主要有几个点 1.删除的节点没有子节点，直接删除。 删除的节点有一个子节点，用子节点代替删除的节点（可以认为是删除了子节点） 删除的节点有两个子节点，用后继节点代替删除的节点。（也可以用前驱节点代替，这里以后继节点为例）。把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。（即中序遍历的后面一个节点）这里可以认为是删除了后继节点，转成情况2或者通过情况2（不存在左节点）转情况1 我们目的都是可以把情况2，3认为是情况1 综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。 替换节点是红色节点 我们把替换结点换到了删除结点的位置时，由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。 2.替换节点是黑色节点 2.1.1 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点，兄弟节点的父节点和子节点都是黑色。 此时把替换节点，父节点，兄弟节点变成黑红黑，然后左旋。 2.1.2 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点， 2.1.2.1替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色 此时由于会删除黑色节点导致不平衡，所以兄弟节点改成父节点的颜色，将父节点改为黑色，兄弟节点的右节点改为黑色。然后左旋。 2.1.2.2 替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点 删除黑色的替换节点会不平衡，所以将S设置为红色，对兄弟节点右旋，然后得到2.1.2.1的情况。 2.1.2.3 替换结点的兄弟结点的右子结点为黑结点，左子结点为黑结点 将兄弟节点设置为红色。将父节点作为新的替换节点。然后重新进行删除节点处理。 2.2：替换结点是其父结点的左子结点 这个情况和2.1相同，只是方向相反。","path":"2021/12/24/算法/红黑树知识点/"},{"title":"1705. 吃苹果的最大数目（可以用红黑树即map或者优先队列priority_queue实现）","text":"一般可以用优先队列的也可以用红黑树实现，可以比较一下。 优先队列实现&lt;!—hexoPostRenderEscape:int eatenApples(vector&lt;int&gt;&amp; apples, vector&lt;int&gt;&amp; days)&lt;/span&gt; &lt;/span&gt;&#123; &lt;span class=&quot;hljs-built_in&quot;&gt;priority_queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;, greater&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; pq; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, n = apples.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); i &amp;lt; n || !pq.empty(); ++i) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; n &amp;amp;&amp;amp; apples[i] != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; pq.emplace(i + days[i], apples[i]); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!pq.empty() &amp;amp;&amp;amp; pq.top().first &amp;lt;= i) &amp;#123; pq.pop(); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!pq.empty()) &amp;#123; res++; &lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mypair = pq.top(); mypair.second--; pq.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (mypair.second&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; pq.emplace(mypair); &amp;#125; &amp;#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;红黑树实现class Solution &#123; public: int eatenApples(vector&lt;int&gt;&amp; apples, vector&lt;int&gt;&amp; days) &#123; int n=apples.size(); map&lt;int,int&gt; m; int res=0; for(int i=0;i&lt;n||!m.empty();i++) &#123; m.erase(i); if(i&lt;n&amp;&amp;apples[i]!=0) m[i+days[i]]=apples[i]; if(!m.empty()) &#123; auto tmp=m.begin(); tmp-&gt;second--; if(tmp-&gt;second==0) m.erase(tmp); res++; &#125; &#125; return res; &#125; &#125;;","path":"2021/12/24/算法/优先队列和红黑树实现/"},{"title":"C++虚函数虚表内容","text":"知乎这个答案讲的很详细可以看下","path":"2021/12/21/C++/c++虚函数_虚表内容/"},{"title":"const and static and volatile用法","text":"static用法主要是表明某个变量是模块私有的，放在静态区，和全局变量放在一个区域，默认初始化为0，在类实例化之前，静态变量区域的变量就已经初始化好了。 具体分为几种情况：1类成员变量，初始化后不可改变，只能在类外初始化，可由类直接访问，也可以用对象访问。 2类成员函数，只能访问静态成员变量，可有类直接访问，而且由于是修饰类的，没有this指针。 3局部变量，在模块外不可使用，实际上变成全局的，但是只能在这个模块内用。 4某个文件全局变量，不可在文件外使用，即使用了extern 5静态函数，只能在本文件调用，其他文件不可以调用 const规则：const离谁近，谁就不能被修改； const修饰一个变量时，一定要给这个变量初始化，若不初始化，在后面也不能初始化。 例如const int *p=1;p指向的内容是不可以改变的，可以去除int来看，易于理解。 int* const p=1;指针的地址是不可改变的。 这个和&amp;的语法糖是一样的T * const p 关键字volatile有什么含意？并给出三个不同的例子。一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子： 1：并行设备的硬件寄存器（如：状态寄存器） 2：一个中断服务子程序中会访问到的非自动变量(Non-automatic variables) 3：多线程应用中被几个任务共享的变量","path":"2021/12/21/C++/const_static_votatile用法/"},{"title":"C语言宏定义和一些小用法","text":"UL后缀代表无符号长整型后缀#define SEC_YEAR (365*24*60*60)UL 下面的宏定义代表最小值，但是会有副作用#define MIN(a,b) ((a)&lt;=(b)?(a):(b))例如使用MIN(a++,b),此时可以使用下面的代替#include &lt;stdio.h&gt; #define min_i(x,y) ((x)&lt;=(y)?(x):(y)) //（1） #define min_t(type,x,y) (&#123;type _x = x;\\ //（2） type _y = y;\\ _x&lt;_y?_x:_y;\\ &#125;) #define min(x,y) &#123;const typeof(x) _x = (x);\\ //（3） const typeof(y) _y = (y);\\ (void)(&amp;_x=&amp;_y);\\ //（4） _x&lt;_y?_x:_y;\\ &#125;)这个定义计算x和y分别两次（x和y中的小者被计算两次)，当参数由副作用时，将产生不正确的结果使用语句表达式只计算参数一次，避免了可能的错误，语句表达式通常用于宏定义typeof(x)表示x的值类型检查参数x和y的类型是否相同(如果x和y的类型不同编译器将会发出warning，并不影响后面语句的运行 e)int a[10]指针数组，修饰后面的每个元素，数组的每个元素都是指针 f)int (a)[10]，指向数组的指针，修饰a， g)int (*a)(int a)，函数指针a，这个函数返回值为int，参数为int h)int (*a[10])(int)，用指针数组指向函数，该函数有一个整型参数并返回一个整型数 访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。 ptr = (int *)0x67a9;","path":"2021/12/21/C++/c语言宏定义和一些小用法/"},{"title":"WSL的图形界面设置","text":"安装xserver首先是Windows上Xserver的安装，作者这里选择的是VcXsrv X Server，下载之后按照所有默认设置进行安装即可。安装完毕之后打开防火墙配置，允许所有的Xserver连接。 然后安装apt-get install xfce4和xfce4-terminal 打开XLaunch，在Display settings里面将Display number改为0，在Extra settings里面勾选Disable access control，启动Xserver。 然后是WSL2里面的配置，作者是用Ubuntu，其他发行版也类似。首先sudo vim ~/.zshrc # sudo vim ~/.bashrc # export DISPLAY=:0 # in WSL 1 export DISPLAY=$(awk &#x27;/nameserver / &#123;print $2; exit&#125;&#x27; /etc/resolv.conf 2&gt;/dev/null):0 # in WSL 2 然后source ~/.zshrc就可以了","path":"2021/12/21/文档相关/WSL的图形界面设置/"},{"title":"哈夫曼树压缩和解压缩","text":"主要是把字符串读到vector中，然后记录每个字符出现的次数，然后构建哈夫曼树，然后再生成哈夫曼编码，再写入。 #include &lt;iostream&gt; #include &lt;Windows.h&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include&lt;stdio.h&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;map&gt; #include &lt;bitset&gt; #include&lt;unordered_map&gt; using namespace std; long byteNum = 0; typedef struct &#123; int weight; int parent, lchild, rchild; &#125;HafuNode, * HufumanTree; typedef struct &#123; char* data; int* num; int length; &#125;TNode; typedef struct &#123; char* data; char** HM; &#125;Code; typedef char** HuffmanCode; class Hafuman &#123; private: HuffmanCode code; TNode tnod; HufumanTree hafutree; map&lt;string, char&gt; hafumanHash; //存文件内容 vector&lt;char&gt; str; public: void compression(string decomFile,string comFile) &#123; Read(comFile); TNodeCount(); CreateHuffmanTree(); CreatHuffmanCode(); int i, j, k; unsigned int tmp = 0; int bit = 0; ofstream outfile(&quot;compression.txt&quot;, ios::out); ofstream outComFile(decomFile, ios::out); if (!outfile) &#123; cerr &lt;&lt; &quot;open error&quot; &lt;&lt; endl; exit(1); &#125; //写入编码 outComFile &lt;&lt; tnod.length &lt;&lt; &#x27; &#x27;; for (i = 0; i &lt; tnod.length; i++) &#123; outComFile &lt;&lt; tnod.data[i]; outComFile &lt;&lt; code[i + 1]; outComFile &lt;&lt; &#x27; &#x27;; &#125; for (i = 0; i &lt; str.size(); i++) &#123; for (j = 0; j &lt; tnod.length; j++) &#123; if (tnod.data[j] == str[i]) &#123; break; &#125; &#125; for (k = 0; code[j + 1][k] != &#x27;\\0&#x27;; k++) &#123; outfile &lt;&lt; code[j + 1][k]; if (code[j + 1][k] == &#x27;0&#x27;) &#123; tmp = tmp | 0; &#125; else &#123; tmp = (tmp | 1); &#125; bit = (bit + 1) % 32; if (!bit) &#123; outComFile &lt;&lt; tmp &lt;&lt; &#x27; &#x27;; tmp = 0; &#125; else tmp = tmp &lt;&lt; 1; byteNum++; &#125; &#125; tmp = tmp &lt;&lt; (32 - byteNum % 32 - 1); outComFile &lt;&lt; tmp &lt;&lt; &#x27; &#x27;; outComFile &lt;&lt; byteNum; cerr &lt;&lt; &quot;文件的总的字符数为 &quot; &lt;&lt; byteNum &lt;&lt; endl; outfile.close(); //写总共的位数 cerr &lt;&lt; &quot;压缩成功!,可以到compression.txt中查看具体二进制码，压缩文件为 &quot;&lt;&lt;decomFile &lt;&lt; endl; //outComFile.seekg(0, ios::beg); //streampos size = outComFile.tellg(); cout &lt;&lt; &quot;压缩文件大小为：&quot; &lt;&lt; byteNum/8 &lt;&lt; &quot; 字节&quot; &lt;&lt; endl; outComFile.close(); &#125; void decompression(string decomFilename, string comfilename) &#123; char a[30]; ofstream outfile(comfilename, ios::out); ifstream inComfile(decomFilename, ios::in); if (!outfile) &#123; cerr &lt;&lt; &quot;open error&quot; &lt;&lt; endl; exit(1); &#125; if (!inComfile) &#123; cerr &lt;&lt; &quot;open error&quot; &lt;&lt; endl; exit(1); &#125; int bytenum; inComfile.seekg(-2L, ios::end); inComfile &gt;&gt; bytenum; inComfile.seekg(0, ios::beg); int codeNum; inComfile &gt;&gt; codeNum; char* code = new char[100]; char ch; unordered_map&lt;string, char&gt; hash; for (int i = 0; i &lt; codeNum; i++) &#123; inComfile &gt;&gt; ch; inComfile &gt;&gt; code; string tmp = code; hash[tmp] = ch; &#125; unsigned int m; string mystr = &quot;&quot;; for (; bytenum &gt;= 32; bytenum -= 32) &#123; inComfile &gt;&gt; m; unsigned int mask = 0x80000000; int countForByte = 32; while (1) &#123; if (!(mask &amp; m)) mystr.append(&quot;0&quot;); else mystr.append(&quot;1&quot;); m = m &lt;&lt; 1; countForByte--; if (hash.count(mystr)) &#123; outfile &lt;&lt; hash[mystr]; mystr = &quot;&quot;; &#125; if (countForByte &lt;= 0) break; &#125; &#125; inComfile &gt;&gt; m; unsigned int mask = 0x80000000; int countForByte = bytenum; while (1) &#123; if (!(mask &amp; m)) mystr.append(&quot;0&quot;); else mystr.append(&quot;1&quot;); m = m &lt;&lt; 1; countForByte--; if (hash.count(mystr)) &#123; outfile &lt;&lt; hash[mystr]; mystr = &quot;&quot;; &#125; if (countForByte &lt;= 0) break; &#125; cout &lt;&lt; &quot;解压成功！解压文件为&quot; &lt;&lt; comfilename&lt;&lt;endl; delete code; code = nullptr; &#125; void CreatHuffmanCode() &#123; int n = tnod.length; int pare, child, start; code = new char* [n + 1]; char* cd = new char[n]; cd[n - 1] = &#x27;\\0&#x27;; for (int i = 1; i &lt;= n; i++) &#123; start = n - 1; child = i; pare = hafutree[i].parent; while (pare != 0) &#123; start--; if (child == hafutree[pare].lchild) &#123; cd[start] = &#x27;0&#x27;; &#125; else &#123; cd[start] = &#x27;1&#x27;; &#125; child = pare; pare = hafutree[child].parent; &#125; code[i] = new char[n - start]; strcpy(code[i], &amp;cd[start]); &#125; for (int i = 1; i &lt;= n; i++) &#123; cerr &lt;&lt; tnod.data[i-1] &lt;&lt; &quot;权重 : &quot; &lt;&lt; tnod.num[i-1]; cerr &lt;&lt;&quot;二进制编码为&quot;&lt;&lt; code[i] &lt;&lt; endl; &#125; delete cd; &#125; void initTnode() &#123; tnod.data = new char[256]; tnod.num = new int[256]; if (tnod.data == NULL || tnod.num == NULL) &#123; cout &lt;&lt; &quot;发生错误&quot; &lt;&lt; endl; exit(1); &#125; tnod.length = 0; &#125; void Read( string filename) &#123; char ch; ifstream infile(filename, ios::in); if (!infile) &#123; cout &lt;&lt; &quot;open error&quot; &lt;&lt; endl; exit(1); &#125; while (infile.peek() != EOF) &#123; infile.get(ch); str.push_back(ch); &#125; infile.seekg(0, ios::end); streampos size = infile.tellg(); cout &lt;&lt; &quot;源文件大小为：&quot; &lt;&lt; size &lt;&lt; &quot; 字节&quot; &lt;&lt; endl; infile.close(); &#125; bool find(const char ch, TNode t) &#123; for (int i = 0; i &lt; t.length; i++) &#123; if (t.data[i] == ch) &#123; return true; &#125; &#125; return false; &#125; void TNodeCount() &#123; int m = str.size(), j = 0; char ch; for (int i = 0; i &lt; m; i++) &#123; ch = str[i]; if (!find(ch, tnod)) &#123; tnod.data[j] = ch; tnod.num[j] = count(str.begin(), str.end(), ch); tnod.length++; j++; &#125; &#125; &#125; void Select(HufumanTree&amp; tree, int a, int&amp; b, int&amp; c) &#123; int min1, min2, minweight = 10000; for (int i = 1; i &lt;= a; i++) &#123; if (tree[i].parent == 0) &#123; if (tree[i].weight &lt; minweight) &#123; minweight = tree[i].weight; min1 = i; &#125; &#125; &#125; tree[min1].parent = 1; minweight = 10000; for (int i = 1; i &lt;= a; i++) &#123; if (tree[i].parent == 0) &#123; if (tree[i].weight &lt; minweight) &#123; minweight = tree[i].weight; min2 = i; &#125; &#125; &#125; tree[min2].parent = 1; b = min1; c = min2; &#125; void CreateHuffmanTree() &#123; int n = tnod.length; if (n &lt;= 1) &#123; return; &#125; int m = 2 * n - 1; hafutree = new HafuNode[m + 1]; for (int i = 1; i &lt;= m; i++)//为0表示没有左右节点，父节点 &#123; hafutree[i].lchild = 0; hafutree[i].parent = 0; hafutree[i].rchild = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; hafutree[i].weight = tnod.num[i - 1]; &#125; int s1, s2; for (int i = n + 1; i &lt;= m; i++) &#123; Select(hafutree, i - 1, s1, s2); hafutree[s1].parent = i; hafutree[s2].parent = i; hafutree[i].lchild = s1; hafutree[i].rchild = s2; hafutree[i].weight = hafutree[s1].weight + hafutree[s2].weight; &#125; &#125; &#125;; int main() &#123; Hafuman hafumanClass; hafumanClass.initTnode(); string command; char commandOpt; string comFile, deComFile; while (1) &#123; cerr &lt;&lt; &quot;请输入选择的功能&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;1.压缩文件（SZip A xx.haf test.txt（需要压缩的文件名）)&quot; &lt;&lt; endl; cerr &lt;&lt; &quot;2.解压文件（SZip X xx.haf test1.txt(解压的文件名))&quot; &lt;&lt; endl; cin &gt;&gt; command; cin &gt;&gt; commandOpt; if (command != &quot;SZip&quot;||(commandOpt!=&#x27;A&#x27;&amp;&amp; commandOpt != &#x27;X&#x27;)) &#123; cout &lt;&lt; &quot;命令输入错误，请重新输入 &quot; ; continue; &#125; cin &gt;&gt; deComFile &gt;&gt; comFile; switch (commandOpt) &#123; case &#x27;A&#x27;: hafumanClass.compression(deComFile, comFile); break; case &#x27;X&#x27;: hafumanClass.decompression(deComFile,comFile); break; default: cout &lt;&lt; &quot;输入错误！请重新输入&quot;; break; &#125; &#125; return 0; &#125;","path":"2021/12/21/算法/哈夫曼树/"},{"title":"latex中文使用miktex，ctexart","text":"latex中文使用miktex，ctexart \\documentclass[UTF8]&#123;ctexart&#125; \\usepackage[T1]&#123;fontenc&#125; \\usepackage&#123;listings&#125; \\usepackage&#123;graphicx&#125; \\usepackage&#123;xcolor&#125; \\usepackage&#123;fancyhdr&#125; \\usepackage&#123;lastpage&#125; \\pagestyle&#123;fancy&#125; \\chead&#123;西安邮电大学实验报告&#125; \\lhead&#123;&#125; \\rhead&#123;&#125; \\lstset&#123;numbers=left, %用来设置代码块的 numberstyle= \\tiny,keywordstyle= \\color&#123; blue!70&#125;,commentstyle=\\color&#123;red!50!green!50!blue!50&#125;, frame=shadowbox, rulesepcolor= \\color&#123; red!20!green!20!blue!20&#125;, escapeinside=``&#125; \\begin&#123;document&#125; \\tableofcontents \\clearpage \\begin&#123;lstlisting&#125;[language=&#123;[ANSI]C&#125;,numbers=left,numberstyle=\\tiny,%frame=shadowbox, rulesepcolor=\\color&#123;red!20!green!20!blue!20&#125;, keywordstyle=\\color&#123;blue!70!black&#125;, commentstyle=\\color&#123;blue!90!&#125;, basicstyle=\\ttfamily] \\end&#123;document&#125;","path":"2021/12/21/文档相关/latex中文使用/"},{"title":"leetcode29_两数相除","text":"方法主要是用了倍增的思想+位运算如果能用long，就用位运算，再判断溢出的特例。class Solution &#123; public: int divide(int dividend, int divisor) &#123; int flag; if((dividend&gt;0&amp;&amp;divisor&gt;0)||(divisor&lt;0&amp;&amp;dividend&lt;0)) flag=1; else flag=-1; if(dividend==0x80000000&amp;&amp;divisor==-1) return 0x7fffffff; long long div1=abs(long(dividend)),div2=abs(long(divisor)); long long res=0; while(div1&gt;=div2) &#123; int tmp=0; while((div1&gt;&gt;(tmp+1))&gt;=(div2)) &#123; tmp++; &#125; div1-=(div2&lt;&lt;(tmp)); res+=(1&lt;&lt;tmp); &#125; return res*flag; &#125; &#125;; 如果不能用long，就用倍增的方法+同时将数全部化为负数，然后要控制数小于INT_MIN/2的情况。 int divide(int dividend, int divisor) &#123; int flag; if((dividend&gt;0&amp;&amp;divisor&gt;0)||(divisor&lt;0&amp;&amp;dividend&lt;0)) flag=1; else flag=-1; if(dividend==0x80000000&amp;&amp;divisor==-1) return 0x7fffffff; int div1=dividend,div2=divisor; if(dividend&gt;0) div1=-dividend; if(divisor&gt;0) div2=-divisor; int res=0; while(div1&lt;=div2) &#123; int tmp=-1; int div2tmp=div2; while(div2tmp&gt;=INT_MIN/2&amp;&amp;((div1)&lt;=(div2tmp+div2tmp))) &#123; div2tmp+=div2tmp; tmp+=tmp; &#125; div1-=div2tmp; res+=tmp; &#125; return res*-flag; &#125;","path":"2021/12/19/算法/29. 两数相除/"},{"title":"raft算法","text":"raft相比 paxos更容易理解。 raft leader 是一种强leader，日志只能从leader复制日志到其他服务器。 复制是用来解决分布式系统的容错的问题的。 复制状态机就是这种用来解决分布式系统的容错的问题的，在怎么做的呢？复制状态机是通过复制日志来实现的，每个服务器都有相同的日志 raft这种一致性算法就是为了实现分布式的容错性，通过保证复制日志的一致性来实现的。为了解决这个问题，实际上是通过raft实际上只有三个问题. 1 是如何选举出leader 2 如何复制日志 3 怎么保证安全 raft必须保证大部分机器可用。以下是一些raft的基础的内容，三种角色，leader，candidate，follower。 只有leader可以处理客户端的请求，如果其他角色接收到了请求，会重定向到leader。 任期，每个任期从选举开始，只会有一个leader，时间长度不确定。当出现选举分裂的情况下，将不会选取leader，然后新的任期开始，重新选举。 在服务器被孤立的情况下，可能服务器接收到请求时发现任期和自己不一样。如果请求的任期太旧了，拒绝请求。如果任期比自己新，那么如果自己是leader，转变成follower，然后更新任期，如果是其他角色，也更新任期。 raft通过RPC通信请求选举RPC追加日志RPC传送快照RPC 心跳机制，folloewr有计时器，如果超时就发起选举，leader会发送心跳授权延长自己的任期在一次选举开始时，folloewr转为候选者，然后任期增加当候选者接收到其他服务器请求投票的请求时 实现：对于每个raft的服务器同时启动follower和Leader的协程 follower协程sleep，每当超时就发起选举，对其他的每个服务器发送请求投票RPC。Leader的协程每当间隔一定时间就向其他的服务器发送心跳同时给出自己的日志相关信息，通过增加日志RPC发送给它们，同时如果对方的日志太旧就安装快照，发送安装快照RPC，针对结果进行。 6.824 内容Shard把所有数据按照Key Hash然后取模10,把数据切分成10片.每一片称为一个Shard, 其中包括一组键值对 ShardServer (Group)每个Group都是一个Raft集群, 通过Raft保证这组服务器上的数据一致性. 一组服务器负责几个Shard的读写请求.整个集群由N个Group组成 Client客户端, 发起读写请求. ShardMaster是集群中的协调者, 他负责调整Shard在集群间的分配, 以及集群路由的查询工作. 扩容: 新加入了一组服务器Group3, 需要将针对某个Shard的历史数据和后续的读写请求由Group1交给Group3负责以扩容集群. 缩容: 需要下线Group3, 需要将Group3负责的Shard历史数据和后续读写请求交给其他Group负责.扩缩容操作后需要保证Group间的负载均衡 路由查询: 假设Client 需要 Put(key:”name”, value: “L” ), “name”这个key存储在Shard1上. 需要Client根据从ShardMaster获取到的配置来确认向哪个Group发起写请求. Config由ShardMaster维护, 客户端和ShardServer拉取的配置, 其中包括的所有服务器分组地址以及集群路由信息. 每次集群动作的变更都会引起Config Version的更新. Recoverable快照和Raft中的状态要及时落盘,每一台服务器都要能够在故障后重启恢复 线性一致性需要能立刻读到之前完成的写请求 负载均衡Shard在Group间的分布要尽可能均衡, 可以通过一致性哈希或者其他方法来实现 multiRaft我们使用 Raft 一致性算法来确保在机器发生故障时数据也能保持一致。在大多数使用 Raft 的系统中，如 etcd 和 Consul，整个系统只有一个 Raft 共识组。然而，在 CockroachDB 中，数据被分成不同的范围，每个范围都有自己的共识组。这意味着每个节点都可能参与成千上万个共识组。这就提出了一些独特的挑战，我们通过在 Raft 之上引入一层 MultiRaft 来解决这些问题。 简单来说，MultiRaft 是在整个系统中，把所管理的数据按照一定的方式切片，每一个切片的数据都有自己的副本，这些副本之间的数据使用 Raft 来保证数据的一致性，在全局来看整个系统中同时存在多个 Raft-Group单个 Raft-Group 在 KV 的场景下存在一些弊端: (1) 系统的存储容量受制于单机的存储容量（使用分布式存储除外）。 (2) 系统的性能受制于单机的性能（读写请求都由Leader节点处理）。 MultiRaft 需要解决的一些核心问题： (1) 数据何如分片。 (2) 分片中的数据越来越大，需要分裂产生更多的分片，组成更多 Raft-Group。 (3) 分片的调度，让负载在系统中更平均（分片副本的迁移，补全，Leader 切换等等）。 (4) 一个节点上，所有的 Raft-Group 复用链接（否则 Raft 副本之间两两建链，链接爆炸了）。 (5) 如何处理 stale 的请求（例如 Proposal 和 Apply 的时候，当前的副本不是 Leader、分裂了、被销毁了等等）。 (6) Snapshot 如何管理（限制Snapshot，避免带宽、CPU、IO资源被过度占用）。 lab4b在实际的生产系统中，不同 raft 组的成员可能存在于一个物理节点上，而且一般情况下都是一个物理节点拥有一个状态机，不同 raft 组使用不同地命名空间或前缀来操作同一个状态机。系统的运行方式：一开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。 对于集群内部，我们需要保证所有分片能够较为均匀的分配在所有 raft 组上，还需要能够支持动态迁移和容错。 对于集群外部，我们需要向用户保证整个集群表现的像一个永远不会挂的单节点 KV 服务一样，即具有线性一致性。 所有涉及修改集群分片状态的操作都应该通过 raft 日志的方式去提交，这样才可以保证同一 raft 组内的所有分片数据和状态一致。在 6.824 的框架下，涉及状态的操作都需要 leader 去执行才能保持正确性，否则需要添加一些额外的同步措施，而这显然不是 6.824 所推荐的。因此配置更新，分片迁移，分片清理和空日志检测等逻辑都只能由 leader 去检测并执行。数据迁移的实现为 pull 还是 push？其实都可以，个人感觉难度差不多，这里实现成了 pull 的方式。 首先，每个 raft 组的 leader 需要有一个协程去向 shardctrler 定时拉取最新配置，一旦拉取到就需要提交到该 raft 组中以更新配置。此外，为了防止集群的分片状态被覆盖，从而使得某些任务永远被丢弃，因此一旦存在某一分片的状态不是默认状态，配置更新协程就会停止获取和提交新配置直至所有分片的状态都为默认状态为止。","path":"2021/05/25/分布式/raft 算法/"},{"title":"kmp算法，模板","text":"在求next数组和求相似数组很相似，只是i的起始点要为1，一个为0 可以参考leetcode链接 void getNext(List&lt;Integer&gt; next,String s1) &#123; int j=0; for(int i=1;i&lt;s1.length();i++) &#123; while(j&gt;0&amp;&amp;(s1.charAt(j)!=s1.charAt(i))) j=next.get(j-1); if(s1.charAt(j)==s1.charAt(i)) j++; next.set(i,j); &#125; &#125; public int strStr(String haystack, String needle) &#123; if(needle.length()==0) return 0; List&lt;Integer&gt; next=new ArrayList&lt;&gt;(Collections.nCopies(needle.length(),0)); getNext(next,needle); int i,j=0; for(i=0;i&lt;haystack.length();i++) &#123; while((j&gt;0)&amp;&amp;(haystack.charAt(i)!=needle.charAt(j))) j=next.get(j-1); if(haystack.charAt(i)==needle.charAt(j)) j++; if(j==needle.length()) return i-j+1; &#125; return -1; &#125;","path":"2021/04/27/算法/kmp算法/"},{"title":"马拉车算法","text":"关键之处在于要利用镜像的信息，对于镜像已经知道的及时跳过。 然后还有一点就是扩充字符串#，然后两端加@！，这个时候我们如果得到最长回文串，那么怎么获得原始的最长回文串呢，是最右边的-中心得到最左边的位置，然后最左边的位置除2就是原始的起始值，这个很容易理解，因为是刚好扩充了两倍的，用#隔开的。 还有一点关键是更新的是每个点已经以他为中心扩充的字符串，dp数组记录的是长度 class Solution &#123; public String longestPalindrome(String s) &#123; StringBuilder sb=new StringBuilder(&quot;!#&quot;); for(int i=0;i&lt;s.length();i++) &#123; sb.append(s.charAt(i)); sb.append(&quot;#&quot;); &#125; sb.append(&quot;@&quot;); int dp[]=new int[sb.length()]; int C=0,R=0; int maxlen=0,center=0; for(int i=0;i&lt;sb.length();i++) &#123; int slen=1;//子串长度 if(i&lt;R)//如果包含在内 &#123; int mirror=2*C-i;//如果镜像没超过边界，那么直接赋值，否则还要验证 dp[i]=Math.min(dp[mirror],R-i);//直接取镜像的dp值和到边界距离的最小值 slen=dp[i]; &#125; while((i-slen)&gt;=0&amp;&amp;(i+slen)&lt;sb.length()&amp;&amp;(sb.charAt(i-slen)==sb.charAt(i+slen))) &#123; slen++; &#125; if(i+slen-1&gt;R) &#123; R=i+slen-1; C=i; &#125; dp[i]=slen-1; if(dp[i]&gt;maxlen) &#123; maxlen=dp[i]; center=i; &#125; &#125; // System.out.println(maxlen); return s.substring((center-maxlen)/2,(center-maxlen)/2+maxlen); &#125; &#125;","path":"2021/04/12/算法/马拉车算法/"},{"title":"146. LRU 缓存机制","text":"HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供 有序，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照插入的顺序，一种是按照读取的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护&lt;!—hexoPostRenderEscape:class LRUCache &#123;&lt;/span&gt; private int cap; private Map&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(); // 保持插入顺序 &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LRUCache&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.cap = capacity; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;(key); &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key); &lt;span class=&quot;hljs-comment&quot;&gt;// 保证每次查询后，都在末尾&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;() == cap) &amp;#123; Iterator&amp;lt;Map.E***y&amp;lt;Integer, Integer&amp;gt;&amp;gt; iterator = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.e***ySet().iterator(); iterator.next(); iterator.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(); &lt;span class=&quot;hljs-comment&quot;&gt;// int firstKey = map.e***ySet().iterator().next().getValue();&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// map.remove(firstKey);&lt;/span&gt; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value); &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 另外一个方法是采用双向链表，然后用hashmap存每个节点的key和地址。&lt;!—hexoPostRenderEscape:class LRUCache &#123; class myLinked &#123; int val; int key; myLinked next; myLinked prev; myLinked()&#123;&#125; myLinked(int _key,int _value)&#123;key=_key;val=_value;&#125; &#125; private HashMap&lt;Integer,myLinked&gt; m&lt;/span&gt;=new HashMap&lt;&gt;(); private int size; private int capacity; private myLinked head,tail; public LRUCache(int capacity&lt;/span&gt;) &lt;/span&gt;&lt;/span&gt; &#123; this.size=0; this.capacity=capacity; head=new myLinked(); tail=new myLinked(); head.next=tail; tail.next=head; &#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key&lt;/span&gt;)&lt;/span&gt; &amp;#123; myLinked l=m.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(key); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(l==&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; movetohead(l); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; l.val; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt; &lt;/span&gt; &#123; myLinked l=m.get(key); if(l!=null) &#123; l.val=value; movetohead(l); &#125; else &#123; myLinked tmp=new myLinked(key,value); m.put(key,tmp); addtohead(tmp); ++size; if(size&gt;capacity) &#123; myLinked tt=removetail(); m.remove(tt.key); size—; &#125; &#125; &#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addtohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; node.prev = head; node.next = head.next; head.next.prev = node; head.next = node; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; node.prev.next = node.next; node.next.prev = node.prev; &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;movetohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123; removeNode(node); addtohead(node); &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; myLinked &lt;span class=&quot;hljs-title&quot;&gt;removetail&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123; myLinked res = tail.prev; removeNode(res); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2021/03/29/算法/146. LRU 缓存机制/"},{"title":"5. 最长回文子串 和马拉车算法","text":"主要是利用了回文串中的对称性质。将回文串分成两部分来看待，左边的已知结果，右边的未知，然后利用左边的信息，需要特殊讨论的情况就是左边回文串超出最左边的时候，超出中心并不需要讨论，因为超出中间的时候不会影响右边的结果，因为右边也只是超出中心，并没有超出最右边。算法效率很好。public String longestPalindrome(String s) &#123; int C=0,R=0; int len=s.length(); StringBuilder sbd=new StringBuilder(&quot;&quot;); sbd.append(&quot;!&quot;); sbd.append(&quot;#&quot;); for(int i=0;i&lt;len;i++) &#123; sbd.append(s.charAt(i)); sbd.append(&#x27;#&#x27;); &#125; sbd.append(&quot;?&quot;); int n=sbd.length(); int a[]=new int[n]; for(int i=1;i&lt;n-1;i++) &#123; int mirror=2*C-i; if(i&lt;R) &#123; a[i]=Math.min(a[mirror&lt;0?C:mirror],R-i); a[i]=Math.min(a[i],i-C); &#125; else &#123; a[i]=0; &#125; while(sbd.charAt(i-a[i]-1)==sbd.charAt(i+a[i]+1)) &#123; a[i]++; &#125; if(i+a[i]&gt;R) &#123; R=i+a[i]; C=i; &#125; // System.out.println(a[i]); &#125; int maxlen=0; int center=0; for(int i=1;i&lt;n-1;i++) &#123; if(a[i]&gt;maxlen) &#123; maxlen=a[i]; center=i; &#125; &#125; String res=sbd.substring(center-maxlen,center+maxlen); int reslen=res.length(); StringBuilder s1=new StringBuilder(&quot;&quot;); for(int i=1;i&lt;reslen;i+=2) &#123; s1.append(res.charAt(i)); &#125; return s1.toString(); &#125;","path":"2021/02/19/算法/5. 最长回文子串/"},{"title":"327. 区间和的个数（树状数组+前缀和+离散化）","text":"依然考虑前缀和数组 \\textit{preSum}preSum。 对于每个下标 jj，以 jj 为右端点的下标对的数量，就等于数组 \\textit{preSum}[0..j-1]preSum[0..j−1] 中的所有整数，出现在区间 [\\textit{preSum}[j]-\\textit{upper}, \\textit{preSum}[j]-\\textit{lower}][preSum[j]−upper,preSum[j]−lower] 的次数。 区间和的问题比较适合用线段树和树状数组 很多人都把constexpr和const相比较。 其实，const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定。 constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。 树状数组可以参考class Solution &#123; public: class BIT &#123; private: int n; vector&lt;int&gt; arr; public: int lowerbit(int i) &#123; return i&amp;(-i); &#125; int query(int i)//求A[1 - i]的和 &#123; int res=0; while(i) &#123; res+=arr[i]; i-=lowerbit(i); &#125; return res; &#125; void add(int i,int x)//在i位置加上k &#123; while(i&lt;=n)//树状数组是从1开始的，所以需要有等号 &#123; arr[i]+=x; i+=lowerbit(i); &#125; &#125; BIT(int _n): n(_n),arr(_n+1)&#123;&#125; &#125;; typedef long long ll; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int len=nums.size(); vector&lt;ll&gt; presum=&#123;0&#125;; ll sum=0; for(int i=0;i&lt;len;i++) &#123; sum+=nums[i]; presum.push_back(sum); &#125; set&lt;ll&gt; se; for(ll p: presum) &#123; se.insert(p); se.insert(p-upper); se.insert(p-lower); &#125; unordered_map&lt;ll,int&gt; m; int index=0; for(ll p: se) &#123; m[p]=index; index++; &#125; int result=0; BIT tree(m.size()); for(int i=0;i&lt;presum.size();i++) &#123; int left=m[presum[i]-upper]; int right=m[presum[i]-lower]; result+=tree.query(right+1)-tree.query(left);//这里有点迷惑，不懂为什么这样弄 tree.add(m[presum[i]]+1,1); &#125; return result; &#125; &#125;;","path":"2021/01/23/算法/327. 区间和的个数/"},{"title":"1584. 连接所有点的最小费用（最小生成树Prime）","text":"朴素版Prim O(n^2) 适用于稠密图 稀疏图的 最小生成树 这个是prim的情况 学习STL，发现STL默认都是使用()比较的，默认比较使用less（即’&lt;’运算符），如sort(a,a+n)，默认将数组按照递增的顺序来排序（前面的元素&lt;后面的嘛），但是优先队列的源码比较奇特，虽然按道理使用less比较应该默认是小根堆（即堆顶元素最小），但是priority_queue&lt;&gt;默认是大根堆的，这是因为优先队列队首指向最后，队尾指向最前面的缘故！每次入队元素进去经排序调整后，优先级最大的元素排在最前面，也就是队尾指向的位置，这时候队首指向优先级最小的元素！所以虽然使用less但其实相当于greater，我们重载运算符的时候比较函数里面写&gt;就相当于&lt;排序方式，这点需要花点时间想想，再来说一说优先队列的这个类型，其实有三个参数：priority_queue，即类型，容器和比较器，后两个参数可以缺省，这样默认的容器就是vector，比较方法是less，也就是默认大根堆，可以自定义写比较方法，但此时若有比较方法参数，则容器参数不可省略！priority_queue&lt;&gt;的可支持的容器必须是用数组实现的容器，如vector，deque，但不能是list（推荐vector），比较方法可以写结构体重载()运算符，也可以用less，greater这些语言实现了的，但是灵活性不够，建议手写重载结构体，或者——如果不想写比较结构体的话，就将后面的两个参数缺省，直接重载类型的&lt;运算符，所以这里写的时候要注意优先队列和其他容器比较器的区别。 class Solution &#123; public: int a[1002][1002]; int sta[1002]; struct node &#123; int weight,p1,p2; &#125;; struct cmp &#123; bool operator()(node a,node b) &#123; return a.weight &gt; b.weight; &#125; &#125;; int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int INF=0x3f3f3f3f; int len=points.size(); vector&lt;vector&lt;int&gt;&gt; dist(len+1,vector&lt;int&gt;(len+1,INF)); for(int i=0;i&lt;points.size();i++) &#123; for(int j=0;j&lt;points.size();j++) &#123; dist[j][i]=dist[i][j]=abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]); &#125; &#125; vector&lt;int&gt; po; po.push_back(0); sta[0]=1; int result=0; priority_queue &lt;node,vector&lt;node&gt;,cmp&gt; qu; for(int i=1;i&lt;len;i++) &#123; node tt = &#123;weight:dist[0][i], p1:0,p2:i&#125;; qu.push(tt); &#125; while(po.size()&lt;len) &#123; while(!qu.empty()) &#123; node tmp1=qu.top(); if(sta[tmp1.p2]==1&amp;&amp;sta[tmp1.p1]==1) &#123; qu.pop(); continue; &#125; else break; &#125; node tmp=qu.top(); // cout&lt;&lt;tmp.p1&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;endl; qu.pop(); sta[tmp.p2]=1; for(int i=0;i&lt;len;i++) &#123; if(sta[i]==1||i==tmp.p2) continue; // cout&lt;&lt;dist[tmp.p2][i]&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; node tt = &#123;weight:dist[tmp.p2][i], p1:tmp.p2,p2:i&#125;; qu.push(tt); &#125; result+=tmp.weight; po.push_back(1); &#125; return result; &#125; &#125;;","path":"2021/01/22/算法/1584. 连接所有点的最小费用/"},{"title":"能谱CT物理原理","text":"CNR = contrast-to-noise ratio, EID = energy-integrating detector, PCD= photon-counting detector 相对于传统的能量集成探测器CT，光子计数CT将允许减少辐射剂量，提高空间分辨率，纠正光束硬化伪影，并使用替代对比剂，同时为定量成像创造机会。 EID CT， x光打到一个吸收层上，吸收层吸收x射线光子，然后转化为可见光光子，可见光光子被一个由半导体材料制成的光电二极管吸收，光电二极管测量入射光的数量，并产生一个电信号，该电信号与在测量期间沉积的总能量成比例，而不是单个x射线光子的能量。 光子计数探测器(PCDs)，另一方面，不需要一个单独的层来转换x射线到光，但由一个单一的厚层半导体二极管(1.6-30毫米取决于材料)，在上面施加一个大的电压。如果入射的x射线被半导体吸收，它就会产生一团正负电荷(6)，迅速地彼此分离。移动的电荷在连接在电极上的电线上产生一个电脉冲，并被电子读出电路记录下来。因此，pcd直接将单个x射线光子转换成电信号，不像当前CT中使用的EIDs，需要额外的步骤将光子转换成可见光。 每一个光子撞击探测器元件，都会产生一个电脉冲，其高度与光子储存的能量成正比。探测器的电子系统计算高度超过预设阈值水平的脉冲的数目。阈值设置在高于电子噪声水平但低于入射光子产生的脉冲水平。此外，通过将每个脉冲与几个阈值水平进行比较，探测器可以根据光子的能量将入射光子分类成若干个能量箱(通常为2到8个)(图3)。因此，电子噪声有效地排除在光子和/或脉冲计数之外，所以一次射线可以产生很多个能谱段。 PCD计数器暂时没有商业应用。使用特定能量测量和能量阈值来拒绝电子噪声。促进新的成像方法，如k-边缘减法原因：造成性能下降的影响取决于探测器中使用的传感器材料的类型。PCDs的研究主要集中在碲化镉、碲化镉锌和硅(6) 康普顿效应 在理想PCD中，光子只在它所撞击的探测器元件中产生信号。在现实中，有几个物理效应可能导致单个光子在多个探测器元素中被登记为计数事件。在硅探测器中，很大一部分光子在探测器材料中通过康普顿散射相互作用，将一小部分能量沉积在探测器元素中。然后，散射光子就会向一个新的、随机的方向移动，可能会把剩余的能量储存在另一个探测器元素中，对于碲化镉和碲化镉锌，康普顿散射概率较低。然而，在原始相互作用中沉积的部分能量可能会以荧光x射线的形式释放，它可以被邻近的探测器元素吸收，如图4,a(8,9)所示。尽管康普顿散射和x射线荧光是不同的物理效应，但它们都导致光子的能量范围不正确，并且可能被多次计算。 电荷共享效应 在硅和镉碲化或镉锌碲化探测器中，探测器元件之间的串扰也可以归因于一种称为电荷共享的效应。如图4,B所示，每个被吸收的x射线光子都会在传感器材料中产生大量的正负电荷。如果光子在两个探测器元件之间的边界附近被吸收，电荷云的一部分可能会延伸到相邻的探测器元件，这可以记录光子能量的一部分。结果是光子被计数两次。 各种各样的串扰在不同的方面降低了图像质量。首先，它们会降低空间分辨率(即模糊图像)，因为它们会导致光子被记录在错误的探测器元件中。其次，它们可能会导致光子被多次计数。这降低了图像的对比度-噪声比(CNR)，因为所有在计数光子数量中引入额外随机性的影响都会产生额外的图像噪声。第三，不同形式的串扰降低了探测器的能量分辨率，降低了能量信息的可靠性，并导致材料选择性图像中的图像噪声增加。 堆积效应 需要一个快速探测器来计数单个光子。每平方毫米每秒有几亿光子撞击探测器，因此传感器材料必须能够快速传输释放的电荷，读出电子必须能够足够快地计算产生的脉冲。对足够快速和稳定的探测器的需求是光子计数CT扫描仪最近才开始用于临床CT剂量水平的原因之一(13)。然而，PCDs广泛应用于PET、SPECT和双能量x线吸收仪，并已被引入一种商业乳房x线成像系统(微剂量;Philips Healthcare, Best，荷兰)，那里的计数率要低得多。如果光子到达得太快，一些由此产生的电脉冲会相互叠加，这种现象被称为脉冲堆积 如果两个连续脉冲几乎同时发生，它们将被记录为一个能量等于两个入射光子能量之和的单个脉冲。如果脉冲到达时间的差异稍微大一些，探测器可能会将它们记录为两个单独的计数，但部分重叠仍然会导致测量光子能量的误差(图5,B)。堆积对图像质量有两种影响。首先，计数损失增加了图像噪声，因为较少的光子有助于测量(14)。第二，能量分辨率下降，类似于相声(14-16)的效果。因为在高计数率下会发生堆积，所以它不会降低图像的所有部分这些影响可以通过设计更小的探测器元件和更快的计数器来最小化。然而，当探测器元件变得更小时，在堆积和电荷共享之间有一个折衷。 由于具有不同能量的光子的加权方式，理想PCD可以产生比理想EID更低的图像噪声。由于EID测量的是吸收的总x射线能量，高能光子对总信号的贡献相对于低能量光子。然而，这种加权并不能产生最佳的CNR，因为在高能量时组织对比度较低。为了优化图像的CNR，可以将最大的权重分配给能量较低、组织间对比度最高的光子，如图7所示。能量分解PCD能够为低能量箱分配更高的权重因子，从而提高CNR(4,18,19)。给予低能量光子更高重量的一个缺点是，由于x射线光谱中低能量部分的组织衰减更加非均匀，因此会导致光束硬化现象的增加(20) 在x射线计算机断层扫描(CT)中，具有不同元素组成的材料可以用CT图像上的相同像素值(即CT数)表示，这取决于材料的质量密度 在双能量CT中，以第二能量获得额外的衰减测量，允许两种材料的区分，这个双能CT，就是加两个能量kev，和能谱CT划分能量箱有所不同。 双能量CT的技术途径 Two Temporally Sequential Scans 两个时间顺序扫描,进行了两次时间顺序扫描，以获取两个管电位处的数据,由于数据不是同时获得的，患者在两次扫描之间发生的运动导致结果图像和材料组成信息的严重退化,后面有一种单轴旋转改进的方法，但是效果应该也不是很好，然后我也没太看懂，尴尬。这个方法可以在任何CT扫描仪上执行(不需要特殊硬件 Rapid Switching of X-Ray Tube Potential x射线管电位的快速切换，允许在低和高管电位下获得交替投影测量，应用主要是骨骼密度测量。然而，在低管电位测量中，管电流不能迅速增加到足够快的程度，从而在低管电位和高管电位数据集中都能达到相当的噪声水平。这种噪音上的差异限制了该技术在骨密度测量之外的应用在连续视图之间切换管电位要求从低到高管电位的转换时间小于一毫秒。此外，过渡必须尽可能突然，以最大限度地分离测量数据的能量，尽管快速调制x射线管电流的困难可能在低能量数据中造成高噪音水平或来自高能量投影的过量剂量。然而，这个问题可以通过对低和高能量投影使用不对称采样来解决。通过这种方式，在不迅速改变管电流的情况下，获得了低能量投影所需的增加管电流-时间积低能量和高能量数据集的近同时数据采集。允许通过使用投影数据或重建图像来实现双能量物质分解算法。减少计算出的“虚拟单能量”图像中的光束硬化现象，需要专门的硬件。能量谱的高重叠 Multilayer Detector 多层探测器就是探测头有两层，里层的获得低能量的信息，外层的获得高能量的信息。低能耗数据收集从前面或内层的探测器层和高能数据收集从后面或外层探测器层(图5)。这类似于多层探测器的使用双能x线摄影(6 - 8)。为了在低和高能量图像中获得相同的噪声，使用了不同的探测器厚度。低能量数据集和高能量数据集的同时数据采集。所有图像数据都以支持特定材料成像的方式获取，但是需要专门的硬件。能量谱的高重叠。低和高能量图像的噪声水平可能不同 Dual x-ray sources双x射线源双源CT是将两个x射线源和两个数据采集系统安装在同一架龙门上，相互垂直放置的CT系统因为两个管同时被激发，原始主光子来自一个管的散射辐射可能被另一个管的探测器探测到，反之亦然。这将降低光谱分离，并要求实现适当的散射校正算法(12)。双源方法的一个优点是能够独立优化每个管-探测器对的光谱过滤，从而增加在特定物质图像中光谱分离和增加信噪比管电流和管过滤可以分别优化每个管电位。相对较低的光谱重叠程度，这提高了材料特定图像的对比噪声比。光束硬化校正应用于图像重建之前，允许在图像域中创建特定材料的图像。需要专门的硬件。在低能和高能数据之间有90度的相移。同时使用这两种x射线源允许散射辐射，其原始的主光子来自一个管被另一个管的探测器检测到，需要专门的散射校正。","path":"2021/01/18/医学图像/能谱CT物理原理/"},{"title":"匈牙利算法（二分图）","text":"匹配：在图论中，一个匹配（matching）是指一个边的集合，其中任意两条边都没有公共顶点。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突），但并非每个图都存在完美匹配。 交替路径：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径称为交替路径。 增广路径：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。 增广路径性质： （1）P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 （2）P经过取反操作可以得到一个更大的匹配M’。 （3）M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法：利用增广路径求二分图的最大匹配算法称作匈牙利算法。（匈牙利数学家Edmonds于1965年提出）。基本思想：通过寻找增广路径，把增广路径中的匹配边和非匹配边的相互交换，这样就会多出一条匹配边，直到找不到增广路径为止。 就是每次从一个未匹配点出发，然后依次经过非匹配边、匹配边、非匹配边，并且途径另一个未匹配点，然后匹配边和非匹配边的相互交换，这样就会多出一个匹配边，直到找不到增广路径。 这是leetcodeLCP 04. 覆盖你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为1 * 2的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。 输入：n, m代表棋盘的大小；broken是一个b * 2的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。 输出：一个整数，代表最多能在棋盘上放的骨牌数。 该题看上去与二分图匹配无关，但其实可以转化成二分图匹配。一个骨牌恰好覆盖两格，而这两格必须是相邻的。因此如果把相邻的两格看成分别属于X、Y两个集合的节点，相邻的节点之间认为有一条（黑色）边相连，放骨牌看做将被覆盖的两格之间的边染成红色；由于一格（一个节点）只能被一个骨牌覆盖（被一条红边连接），那么连接的方式整个就是二分图的一个匹配。如何构建这张图呢？由于相邻的点属于不同的集合，因此仿照国际象棋的棋盘“间隔地”染色就好了。于是，相邻格子之间对应的边连接的都是属于不同集合的节点，相同集合的节点因为对应的不是相邻格子都不直接相连，形成了二分图。最后，能放置骨牌的最大数量就是二分图最大匹配中的边数。 二分图最大匹配可以用匈牙利算法解决，也可以转化成最大流解决，本次使用前者。匈牙利算法的核心操作其实与后者还挺像，后者是寻找增流路径，而前者是寻找一个“交互道路”（节点颜色交替的道路），其实都可以理解为增广道路（augmentation path）。只不过，由于在二分图匹配中一条边要么就是选要么就是不选，相当于是特殊的“流”，0或者1，因此最大流的“退流”操作，被简化为了异或操作。无论是从算 示例 1： 输入：n = 2, m = 3, broken = [[1, 0], [1, 1]]输出：2解释：我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。（见下图）&lt;!—hexoPostRenderEscape:class Solution &#123;public: int row=0,col=0; int grid[10][10]; int erge[100][100]; int matchvi[100]; int belong[100]; int domino(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; broken) &#123; row=n,col=m; int a[4][2]=&#123;1,0,-1,0,0,-1,0,1&#125;; for(auto g: broken) &#123; grid[g[0]][g[1]]=1; &#125; for(int i=0;i&lt;row;i++) &#123; for(int j=0;j&lt;col;j++) &#123; if(grid[i][j]) continue; for(int k=0;k&lt;4;k++)//构造边 &#123; int arow=a[k][0]+i,acol=a[k][1]+j; if(arow&lt;0||arow&gt;=row||acol&lt;0||acol&gt;=col||grid[arow][acol]) continue; // cout&lt;&lt;1; erge[icol+j][arowcol+acol]=erge[arowcol+acol][icol+j]=1; &#125; &#125; &#125; return hug(); &#125; int hug() &#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(grid[tmp1][tmp2]) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//为偶数格子跳过，对奇数找匹配&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; memset(matchvi, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, sizeof(matchvi)); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(match(i)) res++; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; match(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//如果是偶数跳过&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((erge[x][i]==&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(matchvi[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)) &amp;#123; matchvi[i]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(belong[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;||match(belong[i])) &amp;#123;&lt;span class=&quot;hljs-comment&quot;&gt;//如果i没有确定，或者确定的人可以换&lt;/span&gt; belong[i]=x; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &amp;#125; &amp;#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2021/01/16/算法/二分图_匈牙利算法/"},{"title":"785. 判断二分图（染色法）","text":"一个图是二分图，当且仅当图中不含有奇数环二分图的方法，染色法，就是通过对节点进行着色，算法就是深搜的方法 bool res=true; int sta[105]; bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; for(int i=0;i&lt;graph.size();i++) &#123; if(sta[i]==0) paint(i,1,graph); &#125; return res; &#125; void paint(int t,int color,vector&lt;vector&lt;int&gt;&gt;&amp; g) &#123; if(res==false) return ; for(int i=0;i&lt;g[t].size();i++) &#123; if(sta[g[t][i]]==0) &#123; sta[g[t][i]]=-color; paint(g[t][i],-color,g); &#125; else if(sta[g[t][i]]==-color) continue; else &#123; res=false; return ; &#125; &#125; &#125;","path":"2021/01/14/算法/785. 判断二分图/"},{"title":"787. K 站中转内最便宜的航班（bellman-ford）","text":"循环n次遍历所有边u-&gt;v,权w (松弛操作)dist[v]=min(dist[v], dist[u]+w) 应用处理有负权边的图循环次数的含义：循环K次后，表示不超过K条边的最短距离有边数限制的最短路，只能用Bellman-Ford算法，不能用spfa算法如果有负权回路，最短路不一定存在 - Bellman-Ford算法可以求出是否有负环第n循环后，还有更新，说明路径上有n+1个点，也就是存在环，还有更新，说明环是负环循环n次后, 所有的边u-&gt;v,权w满足三角不等式:dist[v]&lt;=dist[u]+wint findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; res(n+1,INF); res[src]=0; for(int i=0;i&lt;=K;i++) &#123; vector&lt;int&gt; tmp(res); for(int j=0;j&lt;flights.size();j++) &#123; if(flights[j][2]+tmp[flights[j][0]]&lt;res[flights[j][1]]) res[flights[j][1]]=flights[j][2]+tmp[flights[j][0]]; &#125; &#125; if(res[dst]==INF) return -1; return res[dst]; &#125;","path":"2021/01/13/算法/787. K 站中转内最便宜的航班/"},{"title":"743. 网络延迟时间（迪杰斯特拉+SPFA+floyd)","text":"有 N 个网络节点，标记为 1 到 N。 给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。 现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。 输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2输出：2 主要就是迪杰斯特拉的代码这个是没有优化的结果，每次选的是距离初始点最小距离的点。集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷for v: 1 ~ nt &lt;- 不在s中的距离最近的点s &lt;- t用t更新其他点的距离朴素的Dijkstra算法往往是稠密图，用邻接矩阵来存储class Solution &#123; public: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; vector&lt;vector&lt;int&gt;&gt; mat(N+1,vector&lt;int&gt;(N+1,0x3f3f3f3f)); vector&lt;int&gt; res(N+1,0x3f3f3f3f); vector&lt;int&gt; sta(N+1,0);//值为1点被被选，为0没被选 int result=-1; sta[K]=1; res[K]=0; for(int i=0;i&lt;times.size();i++) &#123; mat[times[i][0]][times[i][1]]=times[i][2]; if(times[i][0]==K) &#123; res[times[i][1]]=times[i][2]; &#125; &#125; // cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; for(int i=0;i&lt;N-1;i++) &#123; int t=-1; for(int j=1;j&lt;=N;j++) &#123; if(sta[j]==0&amp;&amp;(t==-1||res[j]&lt;res[t])) &#123; t=j; &#125; &#125; sta[t]=1; for(int j=1;j&lt;=N;j++) &#123; if(res[t]+mat[t][j]&lt;res[j]) &#123; res[j]=res[t]+mat[t][j]; &#125; &#125; &#125; for(int i=1;i&lt;=N;i++) &#123; if(res[i]==0x3f3f3f3f) return -1; if(i==K) continue; result=max(result,res[i]); &#125; return result; &#125; &#125;; 集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷for v: 1 ~ nt &lt;- 不在s中的 与起始点距离最近的点 ；小顶堆维护 O(logN)s &lt;- t; O(1)用t更新其他点的距离 ; O(mlogN)稀疏图用堆优化版的Dijkstra算法这个是优化之后的，主要是用稀疏图替换邻接矩阵，同时用优先队列替换遍历搜寻最小的边。 int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; stat(N+1,0); vector&lt;int&gt; res(N+1,INF); vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; m(N+1); priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; queue; queue.push(&#123;0,K&#125;); res[K]=0; int result=0; for(int i=0;i&lt;times.size();i++) &#123; m[times[i][0]].push_back(&#123;times[i][2],times[i][1]&#125;); &#125; while(!queue.empty()) &#123; auto tmp=queue.top(); queue.pop(); if(stat[tmp.second]==1) continue; stat[tmp.second]=1; for(auto &amp;p: m[tmp.second]) &#123; if(p.first+tmp.first&lt;res[p.second])//tmp代表我们找到的下一个加入的点，然后找这个点的所有的边来更新 &#123; res[p.second]=p.first+tmp.first; queue.push(&#123;p.first+tmp.first,p.second&#125;); &#125; &#125; &#125; for(int i=1;i&lt;=N;i++) &#123; if(res[i]==INF) return -1; if(i==K) continue; result=max(result,res[i]); &#125; return result; &#125; SPFA算法 首先相比Dijkstra算法，SPFA可以处理带有负权变的图。（个人认为原因是SPFA在进行松弛操作时就是那个更新距离的地方可以对某一条边重复进行松弛，因为可能某一个点会被多次加入队列，这个可以这么理解，如果在没有负边的情况下松弛一次就是说一条最短路径最多只能经过松弛的这个点一次，这个在没有负边的情况下是显而易见的，当有负边的情况下，经过这个点多次就可能获得更小的最短路径。当我们松弛了某个点超过N次，就可以认为出现了负环，为什么是超过N次呢，极端情况下如果没有负环那么每次加入一次点我们都可以认为这个点与其他点连成的一条边加入最短路径中，如果加了N-1条边还不是最短路径，到第n次那肯定就是有负环了。（大家都写的大于N次），我个人交代码试了以下，好像到n就可以了，但是保险还是大于N更好） 实现方法： 建立一个队列，初始时队列里只有起始点，再建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点作为起始点去刷新到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。 判断有无负环： 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图，但是可以判断是否出现负权环）,这一点和ford算法是一样的，超过N次松弛就代表出现的最短路径长度是大于等于N的，这样的简单路径是不存在的。 我们可以看出代码上其实是和迪杰斯特拉算法很像的。&lt;!—hexoPostRenderEscape: int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int N, int K) &#123; const int INF=0x3f3f3f3f; vector&lt;int&gt; stat(N+1,0); vector&lt;int&gt; res(N+1,INF); vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; m(N+1);//距离队列 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; queue;//刷新队列 queue.push(&#123;0,K&#125;); res[K]=0; stat[K]=1; int result=0; for(int i=0;i&lt;times.size();i++) &#123; m[times[i][0]].push_back(&#123;times[i][2],times[i][1]&#125;); &#125; while(!queue.empty()) &#123; auto tmp=queue.top(); queue.pop(); stat[K]=0; // if(stat[tmp.second]==1) // continue; // stat[tmp.second]=1; for(auto &amp;p: m[tmp.second]) &#123; if(p.first+tmp.first&lt;res[p.second])//first 距离，second 目的点 &#123; res[p.second]=p.first+tmp.first; if(stat[K]==0) &#123; queue.push(&#123;p.first+tmp.first,p.second&#125;); stat[p.second]=1; &#125; &amp;#125; &amp;#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=N;i++) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(res[i]==INF) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==K) &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;; result=max(result,res[i]); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; floyd算法 这个也是求最短路径的算法，是求任意两点之间的最短路径，可以有负边，时间复杂度为O(N^3),空间复杂度为O(N^2),算法主要是考虑的是从i到j经过的点的号不超过k的路径dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j]); 这个可以通过动态规划进行空间优化。//主要的代码如下 for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]); &#125; &#125; &#125;","path":"2021/01/13/算法/743. 网络延迟时间/"},{"title":"177. 第N高的薪水","text":"编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。 +——+————+| Id | Salary |+——+————+| 1 | 100 || 2 | 200 || 3 | 300 |+——+————+例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。 +————————————+| getNthHighestSalary(2) |+————————————+| 200 |+————————————+ SELECT e1.salary FROM employee e1 JOIN employee e2 ON e1.salary &lt;= e2.salary GROUP BY e1.salary HAVING count(DISTINCT e2.salary) = N","path":"2021/01/04/数据库/mysql177. 第N高的薪水/"},{"title":"601. 体育馆的人流量","text":"表：Stadium+———————-+————-+| Column Name | Type |+———————-+————-+| id | int || visit_date | date || people | int |+———————-+————-+visit_date 是表的主键每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)每天只有一行记录，日期随着 id 的增加而增加 编写一个 SQL 查询以找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录。 返回按 visit_date 升序排列的结果表。 查询结果格式如下所示。 Stadium table:+———+——————+—————-+| id | visit_date | people |+———+——————+—————-+| 1 | 2017-01-01 | 10 || 2 | 2017-01-02 | 109 || 3 | 2017-01-03 | 150 || 4 | 2017-01-04 | 99 || 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-09 | 188 |+———+——————+—————-+ Result table:+———+——————+—————-+| id | visit_date | people |+———+——————+—————-+| 5 | 2017-01-05 | 145 || 6 | 2017-01-06 | 1455 || 7 | 2017-01-07 | 199 || 8 | 2017-01-09 | 188 |+———+——————+—————-+id 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。 select distinct t1.* from Stadium t1,Stadium t2, Stadium t3 where t1.people&gt;=100 and t2.people&gt;=100 and t3.people&gt;=100 and ( (t1.id=t2.id-1 and t2.id=t3.id-1) or (t1.id=t2.id+1 and t2.id=t3.id-2) or (t1.id=t2.id+1 and t2.id=t3.id+1)) order by id;","path":"2021/01/04/数据库/mysql601. 体育馆的人流量/"},{"title":"626. 换座位","text":"小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。 其中纵列的 id 是连续递增的 小美想改变相邻俩学生的座位。 你能不能帮她写一个 SQL query 来输出小美想要的结果呢？ 示例： +————-+————-+| id | student |+————-+————-+| 1 | Abbot || 2 | Doris || 3 | Emerson || 4 | Green || 5 | Jeames |+————-+————-+假如数据输入的是上表，则输出结果如下： +————-+————-+| id | student |+————-+————-+| 1 | Doris || 2 | Abbot || 3 | Green || 4 | Emerson || 5 | Jeames |+————-+————-+注意： 如果学生人数是奇数，则不需要改变最后一个同学的座位。 我第一次发现mysql还能这样写判断，学习一个。select if(id%2=0, id-1, if(id=(select count(*) from seat), id, id+1 ))as id,student from seat order by id;","path":"2021/01/04/数据库/mysql626. 换座位/"},{"title":"886. 可能的二分法（二分图+染色法）","text":"染色，一个染色成-1，一个染色成1.，出现冲突就false,否则为true。 我之前只记录单向边，然后dfs中间也没判断，然后就有样例一直过不了，很奇怪。class Solution &#123; bool ans = true; public: bool possibleBipartition(int N, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) &#123; if(dislikes.size() &lt;= 2) return true; vector&lt;int&gt; color(N+1, 0); vector&lt;vector&lt;int&gt;&gt; link(N+1); for(auto&amp; d : dislikes)//建图 &#123; link[d[0]].push_back(d[1]); link[d[1]].push_back(d[0]);//这里反向的也要选择不然容易出错 &#125; for(int i = 1; i &lt;= N; i++) &#123; if(color[i] == 0&amp;&amp;link[i].size()!=0)//未着色的 &#123; color[i] = 1;//着色为1 dfs(link,i, 1, color); if(!ans) return false; &#125; &#125; return true; &#125; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; link,int id, int col, vector&lt;int&gt; &amp;color) &#123; if(!ans) return; int nextcol = -col;//跟我相连的(不喜欢的人)颜色相反 for(int i=0;i&lt;link[id].size();i++) &#123; if(color[link[id][i]] == col)//颜色相同，出错 ans = false; if(color[link[id][i]] == 0)//没有访问过的，继续着色 &#123; color[link[id][i]] = nextcol; dfs(link,link[id][i], nextcol, color); &#125; &#125; &#125; &#125;;","path":"2020/12/24/算法/886. 可能的二分法/"},{"title":"127. 单词接龙","text":"我一开始用的dfs，然后超时了，剪支了还是超时，写普通的广度优先搜索还是超时，这个是双向的bfs. 具体地，可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 it、ht、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。 最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。 class Solution &#123; public: unordered_map&lt;string, int&gt; wordId; vector&lt;vector&lt;int&gt;&gt; link; int nodeNum = 0; void addword(string &amp; s) &#123; if(!wordId.count(s)) &#123; wordId[s]=nodeNum++; link.emplace_back(); &#125; &#125; void geneword(string &amp; s) &#123; addword(s); int n1=wordId[s]; int len=s.size(); for(char&amp; it : s) &#123; char a=it; it=&#x27;*&#x27;; addword(s); int n2=wordId[s]; it=a; // cout&lt;&lt;1; link[n1].push_back(n2); link[n2].push_back(n1); // cout&lt;&lt;2; &#125; &#125; int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; for(auto &amp; word : wordList) &#123; geneword(word); &#125; geneword(beginWord); if(!wordId.count(endWord)) return 0; int endnum=wordId[endWord]; int beginnum=wordId[beginWord]; queue&lt;int&gt; qbegin; queue&lt;int&gt; qend; qbegin.push(beginnum); qend.push(endnum); vector&lt;int&gt; disbegin(nodeNum+2,INT_MAX); vector&lt;int&gt; disend(nodeNum+2,INT_MAX); disbegin[beginnum]=0; disend[endnum]=0; while(!qbegin.empty()&amp;&amp;!qend.empty()) &#123; int beginlen=qbegin.size(); for(int i=0;i&lt;beginlen;i++) &#123; int w=qbegin.front(); qbegin.pop(); if(disend[w]!=INT_MAX) return (disend[w]+disend[w])/2+1; for(int j=0;j&lt;link[w].size();j++) &#123; if(disbegin[link[w][j]]==INT_MAX) &#123; qbegin.push(link[w][j]); disbegin[link[w][j]]=disbegin[w]+1; &#125; &#125; &#125; int endlen=qend.size(); for(int i=0;i&lt;endlen;i++) &#123; int w=qend.front(); qend.pop(); if(disbegin[w]!=INT_MAX) &#123; return (disend[w]+disend[w])/2+1; &#125; for(int j=0;j&lt;link[w].size();j++) &#123; if(disend[link[w][j]]==INT_MAX) &#123; qend.push(link[w][j]); disend[link[w][j]]=disend[w]+1; &#125; &#125; &#125; &#125; return 0; &#125; &#125;;","path":"2020/12/24/算法/127. 单词接龙/"},{"title":"1293. 网格中的最短路径(状压dp+记忆化搜索）","text":"状态空间搜索解题模板class Solution &#123; public: struct State &#123; int x,y; int r; State(int x1,int y1,int r1) &#123; x=x1; y=y1; r=r1; &#125; &#125;; int dx[4]=&#123;1,0,-1,0&#125;; int dy[4]=&#123;0,1,0,-1&#125;; int shortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; g, int k) &#123; int m=g.size(); int n=g[0].size(); if(k&gt;=m+n-3) return m+n-2; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(m, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(k + 1, 0))); queue&lt;State&gt; Q; Q.emplace(0, 0, k); int step = 0; while(!Q.empty()) &#123; int s = Q.size(); while(s--) &#123; auto p = Q.front(); Q.pop(); int x = p.x, y = p.y; int r = p.r; if(x == m - 1 &amp;&amp; y == n - 1 &amp;&amp; r &gt;= 0) return step; if(visited[x][y][r] == 1) continue; visited[x][y][r] = 1; for(int k = 0; k &lt; 4; k++) &#123; if(x + dx[k] &gt;= 0 &amp;&amp; x + dx[k] &lt; m &amp;&amp; y + dy[k] &gt;= 0 &amp;&amp; y + dy[k] &lt; n) &#123; if(g[x + dx[k]][y + dy[k]] == 1 &amp;&amp; r &gt;= 1) Q.emplace(x + dx[k], y + dy[k], r - 1); else if(g[x + dx[k]][y + dy[k]] == 0) Q.emplace(x + dx[k], y + dy[k], r); &#125; &#125; &#125; step++; &#125; return -1; &#125; &#125;;","path":"2020/11/02/算法/1293. 网格中的最短路径/"},{"title":"901. 股票价格跨度","text":"答案的题解用的是单调栈我用的不是，但是总体来说也是dp的方法，速度好像还快一点的，击败了99.8%。 class StockSpanner &#123; public: vector&lt;int&gt; num; vector&lt;int&gt; res; StockSpanner() &#123; num.clear(); res.clear(); num.push_back(-1); res.push_back(0); &#125; int next(int price) &#123; int len=num.size(); int top=num[len-1]; if(top&lt;=price) &#123; int tmp=0;//最后的结果 int p=len-1;//最后的位置 while(top&lt;=price&amp;&amp;p!=0) &#123; tmp+=res[p]; p=p-res[p]; top=num[p]; &#125; num.push_back(price); res.push_back(tmp+1); return tmp+1; &#125; else &#123; num.push_back(price); res.push_back(1); return 1; &#125; &#125; &#125;;","path":"2020/11/02/算法/901. 股票价格跨度/"},{"title":"576. 出界的路径数（记忆化搜索）","text":"class Solution &#123; public: long res[55][55][55]; int findPaths(int m, int n, int N, int i, int j) &#123; res[0][i][j]=1; int mod = 1000000007; for(int num=1;num&lt;N;num++) &#123; for(int row=0;row&lt;m;row++) &#123; for(int col=0;col&lt;n;col++) &#123; if(row-1&gt;=0) res[num][row][col]=(res[num-1][row-1][col]+res[num][row][col])%(mod); if(row+1&lt;m) res[num][row][col]=(res[num-1][row+1][col]+res[num][row][col])%(mod); if(col-1&gt;=0) res[num][row][col]=(res[num-1][row][col-1]+res[num][row][col])%(mod); if(col+1&lt;n) res[num][row][col]=(res[num-1][row][col+1]+res[num][row][col])%(mod); &#125; &#125; &#125; long result=0; for(int num=0;num&lt;N;num++) &#123; for(int row=0;row&lt;m;row++) &#123; result+=res[num][row][0]; result%=mod; result+=res[num][row][n-1]; result%=mod; &#125; for(int col=0;col&lt;n;col++) &#123; result+=res[num][0][col]; result%=mod; result+=res[num][m-1][col]; result%=mod; &#125; // cout&lt;&lt;result&lt;&lt;endl; &#125; return int(result); &#125; &#125;;","path":"2020/11/02/算法/576. 出界的路径数/"},{"title":"LeetCode 794. Valid Tic-Tac-Toe State (medium)（ 博弈dp）","text":"因为X先下，所以如果X和O的数目关系要么相等，要么X比O多1，只有这两种关系，其次再判断如果X已经赢了，O没法下，此时O的数目只能比X小1，或者O赢了，X的数目只能和O一样。bool check(vector&lt;string&gt;&amp; board,char key) &#123; if(board[0][0]==board[0][1]&amp;&amp;board[0][1]==board[0][2]&amp;&amp;board[0][2]==key)return true; if(board[2][0]==board[2][1]&amp;&amp;board[2][1]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][0]==board[1][0]&amp;&amp;board[1][0]==board[2][0]&amp;&amp;board[2][0]==key)return true; if(board[0][2]==board[1][2]&amp;&amp;board[1][2]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][0]==board[1][1]&amp;&amp;board[1][1]==board[2][2]&amp;&amp;board[2][2]==key)return true; if(board[0][2]==board[1][1]&amp;&amp;board[1][1]==board[2][0]&amp;&amp;board[2][0]==key)return true; return false; &#125; bool validTicTacToe(vector&lt;string&gt;&amp; board) &#123; int ansX=0,ansO=0; for(int i=0;i&lt;3;i++) &#123; for(int j=0;j&lt;3;j++) &#123; if(board[i][j]==&#x27;X&#x27;) ansX++; else if(board[i][j]==&#x27;O&#x27;) ansO++; &#125; &#125; if(ansX&lt;ansO)return false; if(ansX-ansO&gt;1)return false; if(check(board,&#x27;X&#x27;)&amp;&amp;ansX==ansO)return false; if(check(board,&#x27;O&#x27;)&amp;&amp;ansX!=ansO)return false; return true; &#125;","path":"2020/11/02/算法/LeetCode 794. 有效的井字游戏/"},{"title":"1349. 参加考试的最大学生数","text":"方法就是每次求前n排的人数和前n-1排的人数的关系，重点在于相邻两排斜着的人是否都有，一排是否有相邻的，是否坐在坏的座位上。一一排除。遍历，所有的状态，一排最多2^8个状态。 class Solution &#123; public: int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) &#123; int m=seats.size(); int n=seats[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(1&lt;&lt;n)); for(int i=1;i&lt;=m;i++) &#123; for(int j=0;j&lt;(1&lt;&lt;n);j++) &#123; bitset&lt;8&gt; bs(j); bool state=true; for(int k=0;k&lt;n;k++) &#123; if((seats[i-1][k]==&#x27;#&#x27;&amp;&amp;bs[k])||(k&lt;n-1&amp;&amp;bs[k]&amp;&amp;bs[k+1])) &#123; state=false; break; &#125; &#125; if(state==false) &#123; dp[i][j]=-1; continue; &#125; for(int k=0;k&lt;(1&lt;&lt;n);k++) &#123; if(dp[i-1][k]==-1) &#123; continue; &#125; bitset&lt;8&gt; lastbs(k); bool state1=true; for(int r=0;r&lt;n;r++) &#123; if(lastbs[r]&amp;&amp;(r&gt;0&amp;&amp;bs[r-1]||r&lt;n-1&amp;&amp;bs[r+1])) &#123; state1=false; break; &#125; &#125; if(state1==true) &#123; dp[i][j]=max(dp[i][j],dp[i-1][k]+int(bs.count())); &#125; &#125; &#125; &#125; int result=0; for(int i=0;i&lt;(1&lt;&lt;n);i++) &#123; result=max(result,dp[m][i]); &#125; return result; &#125; &#125;;","path":"2020/11/02/算法/1349. 参加考试的最大学生数/"},{"title":"1125. 最小的必要团队","text":"这个题一开始不会做，做出来一直超时，看的别人的思路先把某些技能树是别人子集的人去掉，然后做dp。class Solution &#123; public: vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123; int bitmap=0;//代表技能，比如111这种 for(int i=0;i&lt;req_skills.size();i++) &#123; bitmap=bitmap|(1&lt;&lt;i); &#125; vector&lt;pair&lt;int,int&gt;&gt; peo2map; for(int i=0;i&lt;people.size();i++) &#123; int tmp=0; for(int j=0;j&lt;people[i].size();j++) &#123; for(int k=0;k&lt;req_skills.size();k++) &#123; if(people[i][j]==req_skills[k]) &#123; tmp=tmp|(1&lt;&lt;k); break; &#125; &#125; &#125; peo2map.push_back(&#123;i,tmp&#125;); &#125; vector&lt;bool&gt; issame(peo2map.size(),0); for(int i=0;i&lt;issame.size();i++) &#123; for(int j=i+1;j&lt;issame.size();j++) &#123; if((peo2map[i].second|peo2map[j].second)==peo2map[i].second) &#123; issame[j]=1; &#125; else if((peo2map[i].second|peo2map[j].second)==peo2map[j].second) &#123; issame[i]=1; &#125; &#125; &#125; decltype(peo2map) peo2map1; for(int i=0;i&lt;peo2map.size();i++) &#123; if(issame[i]==0) &#123; peo2map1.push_back(peo2map[i]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt;res(bitmap+1);//每一个数组代表一组技能 vector&lt;int&gt;skill(bitmap+1,-1);//记录每种技能组合对应的人数，最低位表示没有技能 skill[0]=0;//位图为00000..的技能被获得，某个技能树需要的人数 for(int i=0;i&lt;peo2map1.size();i++) &#123; for(int j=0;j&lt;=bitmap;j++) &#123; if(skill[j]==-1) continue; int newskill=(peo2map1[i].second)|j; if(skill[newskill]==-1||skill[newskill]&gt;skill[j]+1) &#123; skill[newskill]=skill[j]+1;//从j那边技能树走人数会更少 res[newskill]=res[j]; res[newskill].push_back(peo2map1[i].first); &#125; &#125; &#125; return res[bitmap]; &#125; &#125;;","path":"2020/11/02/算法/1125. 最小的必要团队/"},{"title":"数据库的三级模式：外模式、模式和内模式","text":"一、模式（Schema） 定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 理解： ① 一个数据库只有一个模式； ② 是数据库数据在逻辑级上的视图； ③ 数据库模式以某一种数据模型为基础； ④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。 二、外模式（External Schema） 定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。 三、内模式（Internal Schema） 定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。 理解： ① 一个数据库只有一个内模式； ② 一个表可能由多个文件组成，如：数据文件、索引文件。 它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法 其目的有： ① 为了减少数据冗余，实现数据共享； ② 为了提高存取效率，改善性能。","path":"2020/10/13/数据库/数据库的三级模式：外模式、模式和内模式/"},{"title":"MySQL - ON & WHERE 条件区别和执行顺序","text":"MySQL - ON &amp; WHERE 条件区别和执行顺序on是在生成临时表的时候使用的条件，不管on的条件是否起到作用，都会返回左表 (table_name1) 的行。where则是在生成临时表之后使用的条件，此时已经不管是否使用了left join了，只要条件不为真的行，全部过滤掉。 内连接，外连接，笛卡尔积连接自然连接和等值连接1、自然连接(Naturaljoin)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。 2、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。 3、自然连接与等值连接 在连接运算当中，一种最常用的连接是自然连接。 所谓自然连接就是在等值连接的情况下，当连接属性X与Y具有相同属性组时，把在连接结果中重复的属性列去掉。 自然连接是在广义笛卡尔积R×S中选出同名属性上符合相等条件元组，再进行投影，去掉重复的同名属性，组成新的关系。 4、等值连接与自然连接的区别： 1）等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。 2）等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。 5、事实上，我们一般使用的都是自然连接。 select FirstName, LastName, City, State from Person left join Address on Person.PersonId =Address.PersonId; 很纠结的一点是为啥这个on不能是where，然后才发现其实因为是因为在address没有的情况下Address.PersonId;这个本身就是不对的，on因为是就算为空也会生成，所以是对的。","path":"2020/10/13/数据库/MySQL - ON & WHERE 条件区别和执行顺序/"},{"title":"486. 预测赢家","text":"我考虑的是在i，j区间中获胜的人的分数，题解考虑的是分数差值，更好一点。bool PredictTheWinner(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;vector&lt;int&gt; &gt; sum(len,vector&lt;int&gt;(len,0)); vector&lt;vector&lt;int&gt; &gt; res(len,vector&lt;int&gt;(len,0)); for(int i=0;i&lt;len;i++) &#123; sum[i][i]=nums[i]; res[i][i]=nums[i]; &#125; for(int i=2;i&lt;=len;i++)//长度 &#123; for(int j=0;i+j-1&lt;len;j++)//左边起始位置 &#123; sum[j][i+j-1]=sum[j+1][i+j-1]+nums[j]; &#125; &#125; for(int i=2;i&lt;=len;i++)//长度 &#123; for(int j=0;i+j-1&lt;len;j++)//左边起始位置 &#123; res[j][i+j-1]=max(sum[j+1][i+j-1]-res[j+1][i+j-1]+nums[j],sum[j][i+j-2]-res[j][i+j-2]+nums[i+j-1]); &#125; &#125; if(res[0][len-1]&gt;=(sum[0][len-1]/2.0)) return true; else return false; &#125;","path":"2020/10/07/算法/486. 预测赢家/"},{"title":"837. 新21点","text":"我们以 N = 21，K = 17，W = 10 来思考。因为我们的结果是求手上点数为 0 时，赢得游戏的概率。 所以我们需要从后往前逆向求，比如在这里，我们就需要知道在手上点数为 16 时赢得游戏的概率，从而在往前求手上点数为 15 时的概率，最后求出手上点数为 0 时的赢得游戏的概率。 那我们怎么求点数为 16 时赢得游戏的概率呢？ 这里我们知道手上点数为 17 时赢得游戏的概率为 100%，所以 K ~ N 区间的赢得游戏的概率为 100%，超过 N 时赢得游戏概率为 0，那么手上点数为 16 时，赢得游戏的概率就是 手上点数为 17 ~ 17 + 10 - 1 的赢得游戏的概率和除以 W，即用一个表达式为 win[16] = sum(win[17] ~ win[26]) / W。 这里我们可以以 O(1) 的时间复杂度计算 sum(win[i + 1] ~ win[i + W - 1])。我们用一个sumProb = sum(win[17] ~ win[26])然后每次计算win[i] = sumProb / WsumProb = sumProb + win[i] - win[i + W] 这个题目如果用简单的dp会超时，需要从后向前dp，进行优化，考虑差分。double new21Game(int N, int K, int W) &#123; vector&lt;double&gt; res(K+W+1,0); res[0]=1; for(int i=K;i&lt;=N;i++) &#123; res[i]=1; &#125; double tmp=N-K+1; for(int i=K-1;i&gt;=0;i--) &#123; res[i]=tmp/W; tmp=tmp-res[i + W] + res[i]; &#125; return res[0]; &#125;","path":"2020/10/06/算法/837. 新21点/"},{"title":"808. 分汤","text":"即使将 N 除以 25 之后，仍然没法在短时间内得到答案，因此我们需要尝试一些别的思路。可以发现，分配操作有 (4, 0)，(3, 1)，(2, 2) 和 (1, 3) 四种，那么在一次分配中，汤 A 平均会少 (4 + 3 + 2 + 1) / 4 = 2.5 份，汤 B 平均会少 (0 + 1 + 2 + 3) / 4 = 1.5 份。因此在 N 非常大的时候，A 会有很大的概率比 B 先分配完，所有概率应该非常接近 1。事实上，当 N &gt;= 500 25 时，所求概率已经大于 0.999999 了（可以通过上面的动态规划方法求出），它和 1 的误差（无论是绝对误差还是相对误差）都小于 10^-6。因此在 N &gt;= 500 25 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。 double soupServings(int N) &#123; N=N/25+(N%25&gt;0?1:0); if(N&gt;=500*25) return double(1); vector&lt;vector&lt;double&gt; &gt; res(N+1,vector&lt;double&gt;(N+1,0)); for(int i=1;i&lt;=N;i++) &#123; res[0][i]=1.0; &#125; res[0][0]=0.5; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=N;j++) &#123; double tmp=res[(i-4)&lt;0?0:(i-4)][j]+res[(i-3)&lt;0?0:(i-3)][(j-1)&lt;0?0:(j-1)]; double tmp1=res[(i-2)&lt;0?0:(i-2)][(j-2)&lt;0?0:(j-2)]+res[(i-1)&lt;0?0:(i-1)][(j-3)&lt;0?0:(j-3)]; res[i][j]=0.25*(tmp+tmp1); &#125; &#125; return res[N][N]; &#125;","path":"2020/10/06/算法/808. 分汤/"},{"title":"957. N 天后的牢房","text":"为啥14总是一个循环呢？ 首先，经过一次变化之后，0位和7位的数字都会固定是0，不再改变？？？？？？？?|0 ？？？？？？0 其次，第n次的1357位的值决定了n+1次2468位的值，而n+1次的2468位的值又决定了n+2次1357位的值。因此可以得出，第n次的1357位的值可以决定n+2次1357位的值，并且，第n次的2468位的值可以决定n+2次2468位的值。 下面先考虑2468位的情况。因为，8位的值是固定的，所以，只需要考虑246位的值。按2^3=8的情况考虑，246的值可能的情况最多只有8种。然而，仔细观察后会发现，如果第n次的246位的值是001，那么n+2次246位的值也是001，所以001的情况下，246位的值保持不变，所以循环次数为1。如果246位值是其他的情况，那么他们会经历7次循环，因为每次循环需要变换两次，所以，总共需要的变化次数就是14。(1)111 -&gt; (2)010 -&gt; (3)110 -&gt; (4)000 -&gt; (5)011 -&gt; (6)100 -&gt; (7)101 -&gt; (8)111 因为1357位和2468位的地位相同，情况一样，同理，考虑1357位。100的情况下，135的值保持不变，其他情况下，7次循环，14次变化。(0)111 -&gt; (1)010 -&gt; (2)011 -&gt; (3)000 -&gt; (4)110 -&gt; (5)001 -&gt; (6)101 -&gt; (7)111 但是，注意，我们没有考虑到在每次变换中间，375位和246位的值。其实在中间位置时，它们也同样处于一个循环B中。还是先考虑246位，最好的情况就是，由246位初始决定的A循环，和由1357位的初始值决定的B循环，两个循环恰好互补，也就是下面的情况：（我们用A，B分别表示两个循环，A1表示第一个循环中的第一次，B1表示第二个循环中的第一次）(初始情况：A1)111 -&gt; (第一次变化：B1)011 -&gt; (第二次变化：A2)010 -&gt; (第三次变化：B2)100 -&gt; (第四次变化：A3)110 -&gt; (第五次变化：B3)101 -&gt; (第六次变化：A4)000 -&gt; (第七次变化：B4)111 -&gt; (第八次变化：A5)011 -&gt; (第九次变化：B5)010 -&gt; (第十次变化：A6)100 -&gt; (第十一次变化：B6)110 -&gt; (第十二次变化：A7)101 -&gt; (第十三次变化：B7)000 -&gt; (第十四次变化：A8)111这样，在第8次变化前，246位的值已经完成了一次循环。因为，A循环由246位初始决定，B循环由1357位的初始值决定，所以其实在上述情况下，1357位的值也是固定的。 因此，当1357位固定为0100并且2468位固定为0010时，即情况为{0,0,1,0,0,1,0,0}时，循环次数为1。当1357位和2468位出现最佳情况时，循环次数为7，有一下其中情况：1: {0, 1, 1, 1, 1, 1, 1, 0}2: {0, 0, 1, 1, 1, 1, 0, 0}3: {0, 0, 0, 1, 1, 0, 0, 0}4: {0, 1, 0, 0, 0, 0, 1, 0}5: {0, 1, 0, 1, 1, 0, 1, 0}6: {0, 1, 1, 0, 0, 1, 1, 0}7: {0, 0, 0, 0, 0, 0, 0, 0}其他情况下，循环次数为14。vector&lt;int&gt; prisonAfterNDays(vector&lt;int&gt;&amp; cells, int N) &#123; if(N==0) return cells; N=N%14; if(N==0)//当N为0的时候需要特别注意。 N=14; vector&lt;int&gt; res(8,0); int flag=1; for(int i=1;i&lt;=N;i++) &#123; for(int j=1;j&lt;=6;j++) &#123; if(flag==1) &#123; if(cells[j-1]==cells[j+1]) &#123; res[j]=1; &#125; else res[j]=0; &#125; else &#123; if(res[j-1]==res[j+1]) &#123; cells[j]=1; &#125; else cells[j]=0; &#125; &#125; if(flag==1) &#123; res[0]=0; res[7]=0; &#125; else &#123; cells[0]=0; cells[7]=0; &#125; flag=-flag; &#125; if(flag==1) return cells; else return res; &#125;","path":"2020/10/06/算法/957.N 天后的牢房/"},{"title":"auto和decltype之间的区别","text":"auto与decltype区别：1 auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。2 编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。3 decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。关于详细的顶层const和底层const可以参考 详细的例子参考 关于decltype和函数指针迷惑,函数指针参考","path":"2020/08/13/C++/auto和decltype之间的区别/"},{"title":"拉东变换","text":"","path":"2020/08/04/test/"},{"title":"拉东变换","text":"x射线在穿过人体传播的时候，它的衰减是这样的 $I=I_0 e^{-ux}$","path":"2020/08/03/医学图像/拉东变换/"},{"title":"attention机制","text":"attention机制这篇文章讲的很详细attention机制 这篇文章的例子讲的可以attention机制","path":"2020/07/31/深度学习/attention机制/"},{"title":"医学图像相关内容","text":"ASTRA Toolbox一个python的库，包含很多的医学图像的算法，比如fbp，sart，生成投影数据等问题。 还可以进行gpu加速，可以学习学习。","path":"2020/07/29/医学图像/医学图像相关内容/"},{"title":"memset赋值问题","text":"在memset的赋值问题中，是按字节赋值的，如果是menset(array,1,n*sizeof(int));结果不是每个int变成1，而是变成很大的数，它是将int的每一个字节赋值为1，因此最好只在赋值为0的时候使用。","path":"2020/07/29/C++/memset赋值问题/"},{"title":"状压dp","text":"状压dp状态压缩动态规划，就是我们俗称的状压DP，是利用计算机二进制的性质来描述状态的一种DP方式。 很多棋盘问题都运用到了状压，同时，状压也很经常和BFS及DP连用。 状压dp其实就是将状态压缩成2进制来保存 其特征就是看起来有点像搜索，每个格子的状态只有1或0 ，是另一类非常典型的动态规划 举个例子：有一个大小为n*n的农田，我们可以在任意处种田，现在来描述一下某一行的某种状态： 设n = 9； 有二进制数 100011011（九位），每一位表示该农田是否被占用，1表示用了，0表示没用，这样一种状态就被我们表示出来了。这表示的是一中状态，表示的是在这个状态下每个东西的情况。如果要用数组来表示，必须用很多空间表示这一个状态的集合。而在现实因为每个东西状态只有01 所以我们用一个数来表示这种集合状态。 leetcode 464. 我能赢吗采用状压dp来压缩状态。对于每次回溯来说，如果本次(第一个人)选择数字i达到了desiredTotal，说明当前状态下能赢，即返回true，又或者下一次(另一个人)输了，那么说明本次选择必赢。 用dp数组索引表示所选整数的累加和减1，而这个累加和又能体现整数元素选取的情况。dp数组的索引对应整数累加和状态，该整数累加和状态对应组合状态；dp数组元素的值表示整数组合状态对应的结果，为true表示该组合状态已存在并且能赢，直接返回；为false表示该组合状态已存在并且输了，直接返回；为空表示还没出现这种整数组合状态，是一个新状态，需要进行递归计算。 class Solution &#123; public: bool canIWin(int maxChoosableInteger, int desiredTotal) &#123; if(maxChoosableInteger&gt;=desiredTotal) return true; if((maxChoosableInteger+1)*maxChoosableInteger/2&lt;desiredTotal) return false; int *dp=new int[1&lt;&lt;(maxChoosableInteger)];//减法优先级更高 for(int i=0;i&lt;1&lt;&lt;(maxChoosableInteger);i++) dp[i]=-1; bool res= dfs(maxChoosableInteger,desiredTotal,dp,0); return res; &#125; bool dfs(int maxChoosableInteger,int desiredTotal,int *p,int state) &#123; if(p[state]!=-1) return p[state]; for(int i=1;i&lt;=maxChoosableInteger;i++) &#123; int s=1&lt;&lt;i-1; if((s&amp;state)==0)//位运算的优先级很低 &#123; if(desiredTotal-i&lt;=0||!dfs(maxChoosableInteger,desiredTotal-i,p,s|state)) &#123; p[state]=1; return true; &#125; &#125; &#125; p[state]=0; return false; &#125; &#125;; 526. 优美的排列这个题目使用两个数字来记录。第一个是代表哪些数字已经被使用，状态压缩记录，另一个代表的是这是第几个数字。 int countArrangement(int N) &#123; int *dp=new int[1&lt;&lt;N]; int res=0; for(int i=0;i&lt;(1&lt;&lt;N);i++) dp[i]=-1; res=dfs(N,dp,0,1); delete []dp; return res; &#125; int dfs(int N,int *dp,int state,int p) &#123; if(dp[state]!=-1) return dp[state]; int tmp=0; for(int i=1;i&lt;=N;i++) &#123; int s=1&lt;&lt;i-1; if((s&amp;state)==0) &#123; if((i%p==0||p%i==0)) &#123; if(p==N) return 1; tmp+=dfs(N,dp,state|s,p+1); &#125; &#125; &#125; // cout&lt;&lt;tmp&lt;&lt;endl; return tmp; &#125; 935. 骑士拨号器这道题目看起来不像是状压dp，就是让上一个情况递推到下一个，然后同时记录中间的结果。class Solution &#123; public: int a[10][5005]; const int C=pow(10,9)+7; int knightDialer(int N) &#123; vector&lt;int&gt; t(3,-1); vector&lt;vector&lt;int&gt; &gt; b(10,t); b[0][0]=4;b[0][1]=6; b[1][0]=6;b[1][1]=8; b[2][0]=7;b[2][1]=9; b[3][0]=4;b[3][1]=8; b[4][0]=3;b[4][1]=9;b[4][2]=0; b[6][0]=1;b[6][1]=7;b[6][2]=0; b[7][0]=2;b[7][1]=6; b[8][0]=3;b[8][1]=1; b[9][0]=2;b[9][1]=4; int res=0; for(int i=0;i&lt;10;i++) &#123; res=(fun(i,N-1,b)+res)%C; &#125; return res; &#125; int fun(int i,int N,vector&lt;vector&lt;int&gt;&gt; &amp;b) &#123; if(a[i][N]!=0) return a[i][N]; if(N==0) return 1; int tmp1=0; for(int t=0;t&lt;3;t++) &#123; int tmp=b[i][t]; if(tmp!=-1) tmp1=(fun(tmp,N-1,b)%C+tmp1%C)%C; &#125; a[i][N]=tmp1; return tmp1%C; &#125; &#125;; class Solution &#123; public: int a[8][1&lt;&lt;8]; int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) &#123; int len=seats.size(); if(len&lt;=0||seats[0].size()&lt;=0) return 0; int len1=seats[0].size(); vector&lt;int&gt; t(len1,-1); vector&lt;vector&lt;int&gt; &gt; tt(len,t);//这一行，以及上一行的状态 dfs(0,dp,0，0)//第几行，这一行的状态，由于只会往上和左右扩散，所以可以从一个方向走。 return res; &#125; int dfs(int len,vector&lt;vector&lt;int&gt; &gt; dp,int state，int state1) &#123; if(dp[len][state][state1]!=-1) return dp[len][state][state1]; int tmp=0; int rr=0; for(int i=0;i&lt;n;i++) &#123; int s1=state; int s2=state1; tmp=1&lt;&lt;i; if((i&amp;state)==0) &#123; s1=s1|tmp; if(i-1&gt;=0) &#123; s1=s1|(1&lt;&lt;i-1); s2=s2|(1&lt;&lt;i-1); &#125; if(i&lt;=len1) &#123; s1=s1|(1&lt;&lt;i+1); s2=s2|(1&lt;&lt;i+1); &#125; rr=max(rr,dfs(len,dp,s1,s2)); &#125; &#125; dp[len][s1][s2]=rr; return rr; &#125; &#125;;","path":"2020/07/29/算法/状压dp/"},{"title":"树形dp","text":"树形dp543. 二叉树的直径这里就是对于每棵树判断两种情况，是选择自己作为深度，祖宗节点作为根节点穿过最长，还是就是自己作为根节点穿过最长呢。于是只需要求子节点的最长的节点长度，然后最后把节点长度减一就可以了。 class Solution &#123; public: int res=0; int dfs(TreeNode* root) &#123; if(root==nullptr) return 0; int l=dfs(root-&gt;left); int r=dfs(root-&gt;right); res=max(res,l+r+1); return max(l,r)+1; &#125; int diameterOfBinaryTree(TreeNode* root) &#123; if(root==nullptr) return 0; int a=dfs(root); return res-1; &#125; &#125;; LeetCode 337. House Robber III (medium)这个在打家劫舍系列里面，动态规划里面，这里就不重复写了。 124. 二叉树中的最大路径和这个题目的思路主要是就是我们在每个经过的路径肯定有一个最高的节点。如果自己这个节点就是最高的节点。那么就是比较结果和左子树加右子树加节点的值。这个地方要注意 一个节点的情况实际上是已经包含的了。 接下来就是两个节点的情况。左子树或者右子树，取大于0 的最大值。然后加上节点值返回。 一开始我不理解三个节点的情况，两个节点的情况，一个节点的情况的区别，有可能还有负数，我比较混乱，所以就写得很繁琐，都列举出来了。 较繁琐代码，可以参考。击败97%&lt;!—hexoPostRenderEscape:class Solution &#123;public: int res=0; int maxval=-0x7fffffff-1; int dfs(TreeNode* root) &#123; if(root==nullptr) &#123; return 0; &#125; if(root-&gt;val&gt;maxval) maxval=root-&gt;val; int L=dfs(root-&gt;left); int R=dfs(root-&gt;right); if(L&lt;0) &#123; if(R&lt;0) &#123; res=max(res,root-&gt;val); return root-&gt;val&gt;0?root-&gt;val:0; &#125; else &#123; res= max(res,R+max(0,root-&gt;val)); return R+root-&gt;val&gt;0?R+root-&gt;val:0; &#125; &#125; else &#123; if(R&lt;0) &#123; res= max(res,L+max(0,root-&gt;val)); return L+root-&gt;val&gt;0?L+root-&gt;val:0; &#125; else &#123; if(root-&gt;val&gt;=0||root-&gt;val+L&gt;0||root-&gt;val+R&gt;0) res=max(res,L+R+root-&gt;val); else res=max(res,max(L,R)); int tmp=max(R,L)+root-&gt;val; return tmp&gt;0?tmp:0; &#125; &#125; &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; maxPathSum(&lt;span class=&quot;hljs-type&quot;&gt;TreeNode&lt;/span&gt;* root) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a=dfs(root); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(maxval&amp;lt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) return maxval; return res; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 简化代码。int res=-0x7fffffff-1; int dfs(TreeNode* root) &#123; if(root==nullptr) &#123; return 0; &#125; int L=dfs(root-&gt;left); int R=dfs(root-&gt;right); int l=max(0,L); int r=max(0,R); res=max(res,r+l+root-&gt;val); return max(l,r)+root-&gt;val; &#125; int maxPathSum(TreeNode* root) &#123; dfs(root); return res; &#125; 代码差不多只是稍微简化了一点点。也是97% LeetCode 1245. Tree Diameter这道题是被锁住的。 题目描述给定一棵无向树，返回它的直径：树中最长路径的 边 的数量。 树用一个数组给出，数组为 edges[i] = [u, v]，每个元素代表一条双向边连接结点 u 和 v。每个结点的编号为 {0, 1, …, edges.length}。 样例 输入：edges = [[0,1],[0,2]]输出：2解释：这棵树上最长的路径是 1 - 0 - 2，边数为 2。 输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]输出：4解释：这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。限制0 &lt;= edges.length &lt; 10^4edges[i][0] != edges[i][1]0 &lt;= edges[i][j] &lt;= edges.lengthedges 会形成一棵无向树。 遇到树的题目，多数要考虑到使用dfs或者bfs来解题。本题也不例外，从任意一点开始dfs整棵树，对于任意当前节点，它能组成的最大边长应该是从自身出发的所有路径中最长两条路径长度的和。因此，在每一步dfs中，我们需要记录下当前节点最长两条路径的长度，并求出和sum。同时返回最长的一条边的长度给上层dfs。全部dfs结束后，找到最大的sum即是结果。 之前我比较纠结的一点是为什么为什么走过来不会走回去，后来才发现，因为保证了不会走回头路，又是无环图所以一定不会走回去，最后写起来就和二叉树有点像。每次判断以当前节点为中间节点的路径和最长路径的大小。 int res=0; // 返回结果 public int treeDiameter(int[][] edges) &#123; // 利用边的信息构建出树的结构，即每个节点能和哪些节点相连接 List&lt;Integer&gt;[] tree = new List[edges.length+1]; // 初始化 for(int i=0;i&lt;tree.length;i++)&#123; tree[i] = new ArrayList&lt;&gt;(); &#125; // 构建树 for(int[] edge : edges)&#123; tree[edge[0]].add(edge[1]); tree[edge[1]].add(edge[0]); &#125; dfs(tree, 0, -1); // 开始dfs return res; &#125; // tree为树的结构图 // current为当前节点 // previous为前一个节点 // 返回值为：以当前节点为起点的一条最大路径长度 int dfs(List[] tree, int current, int previous)&#123; // 查看当前节点能与哪些节点连接 List&lt;Integer&gt; list = tree[current]; int max1=0; // 以当前节点为起点的一条最大路径长度 int max2=0; // 以当前节点为起点的一条次大路径长度 // 循环所有与当前节点相连的点 for(int next : list)&#123; // 防止走回头路 if(next != previous)&#123; // dfs得到下一个节点一条路径的最大长度 // 加一之后为当前节点一条路径的长度 int max = dfs(tree, next, current)+1; // 比较当路径长度与之前得到的max1，max2，并更新最大值 if(max&gt;=max1)&#123; max2=max1; max1=max; &#125;else if(max&gt;=max2)&#123; max2=max; &#125; // max1+max2得到当前节点最大边长,与返回结果比较，更新最大值 res=Math.max(res, max1+max2); &#125; &#125; // 返回当前节点一条路径的最大长度 return max1; &#125; [LeetCode] 333. Largest BST Subtree 最大的二分搜索子树Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it. Note:A subtree must include all of its descendants. Example: Input: [10,5,15,1,8,null,7] 10 / \\ 5 15 / \\ \\1 8 7 Output: 3Explanation: The Largest BST Subtree in this case is the highlighted one. The return value is the subtree’s size, which is 3.Follow up:Can you figure out ways to solve it with O(n) time complexity? Hint: You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity. 找最大的二叉搜索子树首先肯定是需要子树的范围, 因为我们要判断当前结点为根的树是否为二叉搜索树就要满足当前结点大于左子树的最大值, 小于右子树的最小值. 再次我们还需要知道子树是否为二叉搜索树以及其二叉搜索树的大小. 有了这些信息我们就可以判断以当前结点为根的二叉树是否为二叉搜索树了. 但是这题很容易写的比较复杂.&lt;!—hexoPostRenderEscape:class Solution &#123;public: vector&lt;int&gt; DFS(TreeNode* root, int&amp; ans) &#123; if(!root) return vector&lt;int&gt;&#123;0, INT_MAX, INT_MIN&#125;; auto left=DFS(root-&gt;left, ans), right=DFS(root-&gt;right, ans); if(root-&gt;val &gt; left[2] &amp;&amp; root-&gt;val &lt; right[1]) &#123; int Min =min(root-&gt;val, left[1]), Max =max(root-&gt;val, right[2]); ans = max(ans, left[0] + right[0] + 1); return vector&lt;int&gt;&#123;left[0] +right[0] +1, Min , Max&#125;; &#125; return vector&lt;int&gt;&#123;0, INT_MIN, INT_MAX&#125;; &#125; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; largestBSTSubtree(TreeNode* root) &amp;#123; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; DFS(root, ans); &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ans; &amp;#125; &lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/07/28/算法/树形dp/"},{"title":"区间dp","text":"图像转CT值CT值的单位是Hounsfield，简称为Hu，范围是-1024-3071。用于衡量人体组织对X射线的吸收率，设定水的吸收率为0Hu。 在DICOM图像读取的过程中，我们会发现图像的像素值有可能不是这个范围，通常是0-4096，这是我们常见到的像素值或者灰度值，这就需要我们在图像像素值（灰度值）转换为CT值。 首先，需要读取两个DICOM Tag信息，（0028|1052）：rescale intercept和（0028|1053）：rescale slope. 然后通过公式： Hu = pixel * slope + intercept 计算得到CT值。 衰减系数相关此外，临床上常用的X射线能量范围在80-140KeV左右，也比较固定。因此，三个因素中的2个固定了，剩下的一个就是物质密度。由此可见，医学CT通常是通过物质密度来对物质进行区分的。现在来看看典型值：在临床X射线能量范围内，水的线性衰减系数为0.2cm-1，肌肉为0.2~0.21cm-1，脂肪为0.18cm-1左右，空气在0左右，骨头在0.3~0.4cm-1左右。记这些值比较麻烦，远不如记100,200这种整数来得容易。观察这些值可以发现，这些值都在水附近，所以临床上通常使用某物质与水之间的相对值来衡量物质的衰减能力，即 （物质衰减能力-水衰减能力）/（水衰减能力-空气衰减能力）*1000， 其中水衰减能力在0.2左右，空气为0左右。为了纪念第一个发明CT机的科学家Housfield，我们将这个相对值的单位记为HU。而这个相对值即为CT值。这样一来，可以得出：空气的CT值为-1000HU左右，水是0HU，脂肪是-100HU左右，肌肉是50HU左右，骨头则是500~1000HU左右。这些值就好记多了。所以，结论是：1：在医学上，由于X射线能量比较固定，有效原子序数也比较固定，CT值就基本上刻画的是不同组织的密度差异性。2：如何测量？这是CT图像重建的范畴了。X射线扫描得到投影图像，根据投影图像反演出人体每点的线性衰减系数，带入上述公式，计算得到每一个点的CT值。（注意，上述所有的值都是一些粗略的近似，实际情况则需要实际考察。例如不同部位所使用的X射线能量不同等等。为了易于理解，上述表述也不尽严谨，欢迎讨论~） 转Hu值B. Window-leveling 算法: W/L 是专门为 CT 设计的。原理很简单：CT 图像里不同组织的密度 (用 Hounsfield 单位) 是在固定的值域， 与具体设备和成像软件没有关系。因此，要看头颅时， 我们只需将头颅的值域转换到 0-255 就行了。 CT W/L 不讲头颅值域的 min 和 max, 而说 max - min (即 window_width) 和 (max+min)/2 (即 window_center)。 我们还可以用原来的公式，只是 min 和 max 的算法不一样。 // 先算图像的最大和最小值min = (2window_center - window_width)/2.0 + 0.5;max = (2window_center + window_width)/2.0 + 0.5;for (i = 0; i &lt; nNumPixels; i++) disp_pixel_val = (pixel_val - min)*255.0/(double)(max - min); 请注意，CT 图像必须先转换成 Hounsfield 值再做 window-level。 这个转换包括将多余高位 bits 变成 0 (clipping), 和用 recale slope 和 rescale intercept 来做单位转换。 HU = pixel_val*rescale_slope + rescale_intercept","path":"2020/07/27/医学图像/Dicom医学图像相关内容/"},{"title":"区间dp","text":"区间dp是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态f(i,j)表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j) = max{f(i,k) + f(k+1, j) + cost}, cost 为将这两组元素合并起来的代价。 区间 DP 的特点： 合并：即将两个或多个部分进行整合，当然也可以反过来；特征：能将问题分解为能两两合并的形式；求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。一般用二维数组表示区间区间问题只需要考虑 区间头和区间尾 87. 扰乱字符串给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。 下图是字符串 s1 = “great” 的一种可能的表示形式。 great / \\ gr eat / \\ / \\g r e at / \\ a t在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。 例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。 rgeat / \\ rg eat / \\ / \\r g e at / \\ a t我们将 “rgeat” 称作 “great” 的一个扰乱字符串。 同样地，如果我们继续交换节点 “eat” 和 “at” 的子节点，将会产生另一个新的扰乱字符串 “rgtae” 。 rgtae / \\ rg tae / \\ / \\r g ta e / \\ t a我们将 “rgtae” 称作 “great” 的一个扰乱字符串。 给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。 dp[i][j][k][h] 表示 T[k..h]T[k..h] 是否由 S[i..j]S[i..j] 变来。由于变换必须长度是一样的，因此这边有个关系 j - i = h - kj−i=h−k ，可以把四维数组降成三维。dp[i][j][len]dp[i][j][len] 表示从字符串 SS 中 ii 开始长度为 lenlen 的字符串是否能变换为从字符串 TT 中 jj 开始长度为 lenlen 的字符串 class Solution &#123; public: bool isScramble(string s1, string s2) &#123; int len1=s1.size(); int len2=s2.size(); if(len1!=len2) return false; vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; res(len1+1,vector&lt;vector&lt;bool&gt; &gt;(len1+1,vector&lt;bool&gt;(len1+1,false))); for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len1;j++) &#123; res[i][j][1]=s1[i]==s2[j]; &#125; &#125; for(int i=2;i&lt;=len1;i++) &#123; for(int j=0;j&lt;=len1-i;j++) &#123; for(int k=0;k&lt;=len1-i;k++) &#123; for(int r=1;r&lt;i;r++) &#123; if(res[j][k][r]&amp;&amp;res[j+r][k+r][i-r]) &#123; res[j][k][i]=true; break; &#125; if(res[j][k+i-r][r]&amp;&amp;res[j+r][k][i-r]) &#123; res[j][k][i]=true; break; &#125; &#125; &#125; &#125; &#125; return res[0][0][len1]; &#125; &#125;; 312. 戳气球DP思路是这样的，就先别管前面是怎么戳的，你只要管这个区间最后一个被戳破的是哪个气球这最后一个被戳爆的气球就是 k 注意！！！！！k是这个区间 最后一个 被戳爆的气球！！！！！k是这个区间 最后一个 被戳爆的气球！！！！！ total=dp[i][k]+val[i] val[k] val[j]+dp[k][j] 注：val[i] 表示 i 位置气球的数字然后 (i,k) 和 (k,j) 也都是开区间 之间看这个方法的时候，为什么是开区间，如果选了闭区间怎么办呢，后面想到其实是不用闭区间的。因为我们是在区间左右拓展了一个1. 如果取的是1到10中的开区间，实际上是求的是2到9之间的结果的内容。如果非要闭区间，那么实际的结果应该在0到11之间。 int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); vector&lt;vector&lt;int&gt; &gt; res(len+2,vector&lt;int&gt; (len+2,0)); vector&lt;int&gt; s(len+2,0); s[0]=1; s[len+1]=1; for(int i=0;i&lt;len;i++) &#123; s[i+1]=nums[i]; &#125; for(int i=3;i&lt;=len+2;i++)//作为长度 &#123; for(int j=0;j&lt;=len+2-i;j++) &#123; for(int k=j+1;k&lt;j+i-1;k++) &#123; res[j][j+i-1]=max(res[j][k]+res[k][j+i-1]+s[j+i-1]*s[j]*s[k],res[j][j+i-1]); &#125; &#125; &#125; return res[0][len+1]; 546. 移除盒子这个题目挺难的，用的是区间dp加回溯法，讲道理不太会，下次看这个专题还是有必要重新做。 例如 [9, 5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]，对于一个区间，我判断这个区间的第一个连续色块，9，它后面与他相同的色块位置在6和11位置，那么对于9这个色块的处理有3种方法：1、自己直接干掉，消除他后面的，获得1+[5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]分2、留着，先把他到他后面第一个9的区间，即[5, 3, 5, 3, 3]干掉，然后再处理9+[9, 8, 8, 5, 3, 9]3、留着，但是跳过他后面第一个9的区间，即把[5, 3, 5, 3, 3, 9, 8, 8, 5, 3]都干掉之后，再去处理9+[9]那么可以看出来状态转移方程了，next[i]表示后面第一个与boxes[i]相等的位置，presame表示前面有几个数字与当前第一个位置的数字相等：dp(presame, i, j) = max(max[dp(0, i+1, nexti-1) + dp(presame+1, nexti, j) for every nexti in next[i]], (presame+1)^2 + dp(0, i+1, j)注意这里的presame会和当前的第一个位置数字一起去当做整体去处理。 int removeBoxes(vector&lt;int&gt;&amp; boxes) &#123; int n=boxes.size(); vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n,vector&lt;vector&lt;int&gt;&gt;(n,vector&lt;int&gt;(n+1,0))); return dfs(0,n-1,0,dp,boxes); &#125; int dfs(int l,int r,int k,vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt;&amp; dp,vector&lt;int&gt;&amp; boxes) &#123; if(r&lt;l) return 0; if(dp[l][r][k]!=0) return dp[l][r][k]; while(r&gt;l&amp;&amp;boxes[r]==boxes[r-1]) &#123; k++; r--; &#125; dp[l][r][k]=dfs(l,r-1,0,dp,boxes)+(k+1)*(k+1); for(int i=l;i&lt;r;i++) &#123; if(boxes[r]==boxes[i]) &#123; dp[l][r][k]=max(dp[l][r][k],dfs(l,i,k+1,dp,boxes)+dfs(i+1,r-1,0,dp,boxes)); &#125; &#125; return dp[l][r][k]; &#125; 877. 石子游戏这道题我们采用dp[i][j]来判断先手赢的数目，每次有两种选择选最前面的或者最后面的。然后需要减去下一次先手的结果，因为下一次先手是另外一个人的回合了。大于0就是true.bool stoneGame(vector&lt;int&gt;&amp; piles) &#123; int len=piles.size(); int sum=0; vector&lt;vector&lt;int&gt; &gt; res(len+1,vector&lt;int&gt; (len+1,0)); for(int i=0;i&lt;len;i++) &#123; res[i][i]=piles[i]; &#125; for(int i=2;i&lt;=len;i++) &#123; for(int j=0;j+i&lt;=len;j++) &#123; res[j][j+i-1]=max(piles[j]-res[j+1][j+i-1],piles[j+i-1]-res[j][j+i-2]); &#125; &#125; return res[0][len-1]&gt;0; &#125; 1000. 合并石头的最低成本这个题目四个循环包括的是区间长度从2到n，然后每个res[j][j+i-1][k]每个区间合并成k团的结果，可以考虑把前面合成k-1团，后面认成一团。最后求出每个区间合并成一团的结果。最后求出的值就是结果。 int mergeStones(vector&lt;int&gt;&amp; stones, int K) &#123; int len=stones.size(); if(!(len%(K-1)==1||K==2)) return -1; vector&lt;vector&lt;vector&lt;int&gt; &gt; &gt; res(len+1,vector&lt;vector&lt;int&gt;&gt; (len+1,vector&lt;int&gt; (len+1,1000000))); vector&lt;int&gt; sum(len+1,0); for(int i=1;i&lt;=len;i++) &#123; sum[i]=sum[i-1]+stones[i-1]; res[i-1][i-1][1]=0; &#125; for(int i=2;i&lt;=len;i++) &#123; for(int j=0;j+i&lt;=len;j++) &#123; for(int t=2;t&lt;=K;t++) &#123; for(int r=j;r&lt;=j+i-1;r++) &#123; res[j][j+i-1][t]=min(res[j][j+i-1][t],res[j][r][t-1]+res[r+1][i+j-1][1]); &#125; &#125; res[j][j+i-1][1]=min(res[j][j+i-1][1],sum[j+i]-sum[j]+res[j][j+i-1][K]); &#125; &#125; return res[0][len-1][1]; &#125;","path":"2020/07/27/算法/区间dp/"},{"title":"矩阵动态规划","text":"矩阵动态规划的思路方法方法都是用 dp(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 dp(i, j)dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积。 那么如何计算 dpdp 中的每个元素值呢？对于每个位置 (i, j)(i,j)，检查在矩阵中该位置的值： 如果该位置的值是 00，则 dp(i, j) = 0dp(i,j)=0，因为当前位置不可能在由 11 组成的正方形中； 如果该位置的值是 11，则 dp(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dpdp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下： dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1 很巧妙的方法 统计全为 1 的正方形子矩阵给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。 示例 1： 输入：matrix =[ [0,1,1,1], [1,1,1,1], [0,1,1,1]]输出：15解释：边长为 1 的正方形有 10 个。边长为 2 的正方形有 4 个。边长为 3 的正方形有 1 个。 class Solution &#123; public: int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int len=matrix.size(); if(len==0||matrix[0].size()==0) return 0; vector&lt;int&gt; t(matrix[0].size()+1,0); int num=0; vector&lt;vector&lt;int&gt;&gt; res1(len+1,t); for(int i=0;i&lt;len;i++) &#123; for(int j=0;j&lt;matrix[0].size();j++) &#123; if(matrix[i][j]==1) &#123; int r=min(res1[i][j+1],min(res1[i][j],res1[i+1][j]))+1; res1[i+1][j+1]=r; &#125; else &#123; res1[i+1][j+1]=0; &#125; num+=res1[i+1][j+1]; // cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;; &#125; // cout&lt;&lt;endl; &#125; return num; &#125; &#125;; 221. 最大正方形在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0 输出: 4 class Solution &#123; public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; int len=matrix.size(); if(len&lt;=0||matrix[0].size()&lt;=0) &#123; return 0; &#125; int maxsize=0; vector&lt;int&gt; t(matrix[0].size()+1,0); vector&lt;vector&lt;int&gt;&gt; res(len+1,t); for(int i=0;i&lt;len;i++) &#123; for(int j=0;j&lt;matrix[0].size();j++) &#123; if(matrix[i][j]==&#x27;1&#x27;) res[i+1][j+1]=min(min(res[i][j+1],res[i+1][j]),res[i][j])+1; else res[i+1][j+1]=0; //cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;; maxsize=max(maxsize,res[i+1][j+1]); &#125; //cout&lt;&lt;endl; &#125; return maxsize*maxsize; &#125; &#125;;","path":"2020/07/22/算法/矩阵动态规划/"},{"title":"排序算法稳定性","text":"堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。 (1)冒泡排序冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。 (2)选择排序选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。 (3)插入排序插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。 (4)快速排序快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。 (5)归并排序归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个元素(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。 (6)基数排序基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。 (7)希尔排序(shell)希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。 (8)堆排序我们知道堆的结构是节点i的孩子为2i和2i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。","path":"2020/07/21/算法/排序算法稳定性/"},{"title":"桶排序基数排序相关题目","text":"164. 最大间距桶排序第一种方法采用的是桶排序，方法很巧妙。我们可以知道比较排序最好都是nlogn的，所以不能使用，使用桶排序让我们忽略桶中的顺序，只比较桶之间的大小就可以获得On的复杂度。 那么怎么得到呢，可以得到max,min 然后如果有n个，取一个比平均距离小的内容，为（max-min）/（n）+1,其实也可以加三加四都可以，只需要保证桶内的距离比平均距离小，插值一定在桶间取到就可以，如果每个每个桶的大小对平均距离向下取整，那么相差最大的两个值一定不会在桶中。所以我们只需要记录桶的最大值和最小值，然后比较桶之间的距离就行了。 int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; maxnum(len,-1); vector&lt;int&gt; minnum(len,-1); int maxval=-1,minval=nums[0]; for(int i=0;i&lt;len;i++) &#123; if(nums[i]&gt;maxval) maxval=nums[i]; if(nums[i]&lt;minval) minval=nums[i]; &#125; int sizen=(maxval-minval)/(len)+1; for(int i=0;i&lt;len;i++) &#123; int t=(nums[i]-minval)/sizen; if(nums[i]&gt;maxnum[t]) maxnum[t]=nums[i]; if(minnum[t]==-1||nums[i]&lt;minnum[t]) minnum[t]=nums[i]; // cout&lt;&lt;minnum[t]&lt;&lt;&quot; &quot;&lt;&lt;maxnum[t]&lt;&lt;&quot; &quot;&lt;&lt;t&lt;&lt;endl; &#125; int res=0; int tmp=-1; for(int i=0;i&lt;len;i++) &#123; if(maxnum[i]==-1) continue; if(tmp==-1) &#123; tmp=maxnum[i]; continue; &#125; if(minnum[i]-tmp&gt;res) &#123; res=minnum[i]-tmp; // cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;minnum[i]&lt;&lt;&quot; &quot;&lt;&lt;tmp&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;endl; &#125; tmp=maxnum[i]; &#125; return res; &#125; 164. 最大间距基数排序基数排序这个是从低位到高位很适合，复杂度是d(n+k),d是位数，k是基数10.这个以前不理解为啥低位到高位可行，其实原因是因为这样是稳定的，例如一个44，41，52.个位数排41，52，44排好，然后排个位就是41，44，52，为什么41一定在前面呢，就是因为，个位的时候已经在前面了，所以要保持稳定性，下次还是在前面。 class Solution &#123; public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len=nums.size(); if(len&lt;2) return 0; vector&lt;int&gt; t(len); vector&lt;vector&lt;int&gt;&gt; res(10,t); int maxnum=-1; for(int i=0;i&lt;len;i++) &#123; maxnum=max(maxnum,nums[i]); &#125; int e=1; while(maxnum!=0) &#123; for(int i=0;i&lt;10;i++) res[i].clear(); for(int i=0;i&lt;len;i++) &#123; int t=nums[i]/e%10; res[t].push_back(nums[i]); &#125; int index=0; for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;res[i].size();j++) &#123; nums[index]=res[i][j]; index++; &#125; &#125; maxnum/=10; e*=10; &#125; int result=0; for(int i=1;i&lt;len;i++) &#123; result=max(result,nums[i]-nums[i-1]); &#125; return result; &#125; &#125;;","path":"2020/07/21/算法/桶排序基数排序相关题目/"},{"title":"C++中取INF","text":"int型是4个字bai节 一个字节8个位 0x7f7f7f7f 是十六进制du也就是4个0x7f ,一个0x7f 转化为二进制就zhi是 01111111因为是int型 第一个位是符号位dao ，因而在int 型中 0x7f7f7f7f也就是无穷大的意思通过 #define 将 “INF” 转化为符号常量 代表 0x7f7f7f7f","path":"2020/07/17/C++/C++中取INF/"},{"title":"计数排序基数排序和桶排序","text":"计数排序基数排序和桶排序 这三种方法我经常容易忘记，不太熟悉。总结一下。 计数排序原理很容易懂就是排序元素的范围我们知道，那么就可以将其放到一个这么大的数组中，然后直接每次从数组中取数丢进排序数组中，这个不是一个比较排序的方法。最坏时间复杂度为O(n+k),空间复杂度也为O(n+k) 空间复杂度容易理解，但是时间复杂度我一开始以为的是O(n),实际上这是不对的，因为需要考虑到n很小而k很大 n很大而k很小的情况，综合起来就是O(n+k). 桶排序假设:它使用了具有固定范围的“桶”。它假设每一个元素都会落在这些桶内。每一个桶的范围是固定的。如果桶的范围是1，则该算法就与计数排序很相似了，唯一的不同之处是，它存储的是元素本身而不是它们的计数。 算法： 假设有k个桶：B0, B1, … Bk-1 对于数组a中的每一个元素e： 当e属于Bi时，将其插入Bi中 对于B中的每一个桶b： sort b 令finalarray = {} 对于B中的每一个桶b： finalarray = concat(finalarray, b) 时间复杂度：O(n)，最坏情况O(n n)或者O(n logn)取决于其对桶使用的排序算法。最坏情况下所有元素都落入同一个桶内。 其时间复杂度还与桶的大小和范围有关。如果桶的大小和范围选择不当，可能使得所有元素都落入同一个桶中。如果元素均匀的分布在各个桶内，则时间复杂度就是O(n) 空间复杂度：O(n) 大体讲就是将数分到很多个桶中，每个桶中的排序复杂度很小，然后将数连起来。排序完成，最坏情况大家都在一个桶中效果就很差。 基数排序基数排序的主要思路是,将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次稳定排序(我们常用上一篇blog介绍的计数排序算法, 因为每个位可能的取值范围是固定的从0到9).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列. 基数排序的时间复杂度是O(n*k)，其中n是排序元素的底，如是十进制就是10，k是数字位数。","path":"2020/07/13/算法/计数排序基数排序和桶排序/"},{"title":"背包九讲","text":"背包九讲01背包问题有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci1，得到的价值是 Wi。求解将哪些物品装入背包可使价值总和最大。递推方程应该是res[i][V]=max(res[i-1][V-ci]+wi,res[i-1][V]); 可以用滚动数组优化成O(V)空间 这个空间优化的过程，应该逆序得到，顺序不可以。 res[V]=max(res[V-ci],res[V]); V=V……1； 还可以进行常数优化res[V]=max(res[V-ci],res[V]); $a_1$ $V=V……max(V-\\sum^{n}_{i+1}ci+1,ci)$ 为什么是循环到i+1就可以停下来呢？如果是ci较大，那么对于一维空间优化的情况下，表示的是res[i-1][V],对于继续向下循环是不会改变结果的。 如果是V-\\sum^{n}_{i+1}ci+1较大，说明剩下的空间已经不够装ci了，自然也没必要再继续了。 完全背包问题有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 这个题目一看很容易认为是贪心问题，但是这个物品是不能分的所以不是贪心的，需要注意。这个我们考虑的就是还是某个物品选不选，但是是可以再次选它的。 二维形式 res[i][V]=max(res[i-1][V],res[i][V-ci]+wi); 一维形式为res[V]=max(res[V],res[V-ci]+wi) v=1……V;在优化的情况下，体积大于V可以直接去掉。O(n) 另外对于任何的体积更大的，但是价值更低的，也可以优化掉。O(n^2) 还可以将体积相同的物品，都用其价值最大的代替。O(V+N)类似计数排序 for i……n if(store[V[i]]&lt;wi) store[V[i]]=wifor i ……v 把这些物品丢进去 多重背包问题有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超过背包容量，且价值总和最大。 这个首先有两个朴素的想法 01背包的想法这个想法是把M[i]个相同的物品看成很多个不同的物品，然后用01背包方法求解。 完全背包的想法这个方法就是对于任何一个物品，每次都有许多个选择，然后选取其中的k个进行空间优化之后和01背包的思路相同。复杂度也相同int mutibackpack()//类似完全背包的方法 &#123; for (int i = 0; i &lt;N; i++) &#123; for (int j = 1; j &lt;=M[i]; j++) &#123; for (int k = C[i]*j; k &lt;=V; k++) &#123; res[k] =max(res[k], res[k-j*C[i]]+j*W[i]); &#125; &#125; &#125; return res[V]; &#125; 二进制优化二进制思想： 假设有 1000 个苹果，现在要取n个苹果，如何取？朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。再假设有 1000 个苹果和10只箱子，利用箱子进行某些预工作，然后如何快速的取出n个苹果呢？So..可以在每个箱子中放 2^i (i&lt;=0&lt;=n)个苹果，也就是 1、2、4、8、16、32、64、128、256、489（n减完之前的数之后不足 2^i，取最后剩余的数），相当于把十进制的数用二进制来表示，取任意n个苹果时，只要推出几只箱子就可以了。 再次分析： 只看上面是不好理解的，比如：7的二进制 7 = 111, 它可以分解成 001, 010, 100. 这三个数可以组合成任意小于等于 7 的数，而且每种组合都会得到不同的数。再比如，13 = 1101, 则分解为 0001, 0010, 0100, 0110. 前三个数字可以组合成 7 以内任意一个数，每个数再加上0110(= 6) 之后可以组合成任意一个大于等于 6 小于等于 13 的数，所以依然能组成任意小于等于 13 的数，很明显 6,7 会多重复 1 次，但对于求解背包问题是没有影响的，基于这种思想把一种多件物品转换为，多件一种物品，然后用01背包求解即可。 这个想法可以视为从以前我们对于某种物品取它的n数量，会考虑n-1数量的情况，现在我们不是间隔为1进行考虑，而是用二进制的方法来考虑int mutibackpack2()//二进制优化 &#123; int ste = 1; int num; for (int i = 0; i &lt; N; i++) &#123; num = M[i]; while(num&gt;0) &#123; if(num&gt;ste) num -= ste; else &#123; ste = num; num -= ste; &#125; for (int k = C[i] * ste; k &lt;= V; k++) &#123; res[k] = max(res[k], res[k - ste * C[i]] + ste * W[i]); &#125; ste *= 2; &#125; &#125; return res[V]; &#125; 可行性问题多重背包可行性问题指的是：每种有若干件的物品能否填满给定容量的背包，此时不考虑价值最大问题 F(i,j)表示使用前i个物品，填充容量为jjj的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1. F[i-1][j]&gt;0res[i][j]=M[i] F[i][j-C[i]]&lt;=0 || j&lt;C[i]res[i][j]=-1 其他res[i][j]=res[i][j-C[i]]-1 int mutibackpack3()//res[i][j]表示前i中物品填满j大小的空间最大的剩余物品数量,进行了空间优化 &#123; res[0] = M[0]; for (int i = 0; i &lt; V; i++) &#123; res[V] = -1; &#125; for (int i = 0; i &lt; N; i++) &#123; for (int j = 0; j &lt; V; j++) &#123; if (res[j] &gt; 0) res[j] = M[i]; else if (res[j - C[i]] &lt;= 0 || j &lt; C[i]) res[j] = -1; else res[j] = res[j - W[i]] - 1; &#125; &#125; return res[V]; &#125; 单调队列求解这个比较难，暂时没写 混合背包问题01 背包与完全背包的混合考虑到 01 背包和完全背包中给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是 O(V N)。 再加上多重背包如果再加上最多可以取有限次的多重背包式的物品，那么利用单调队列，也可以给出均摊 O(V N) 的解法。但如果不考虑单调队列算法的话，用将每个这类物品分成 O(logMi) 个 01 背包的物品的方法也已经很优了。最清晰的写法是调用我们前面给出的三个过程。 二维费用的背包问题二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两种背包容量）分别为 V 和 U。物品的价值为 Wi。 算法可以写成res[i][j][k]=max(res[i-1][j][k],res[i][j-ci][k-di]+2i) 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以付出的最大件数费用为 U。换句话说，设 F[v, u] 表示付出费用 v、最多选 u 件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0 . . . V, 0 . . . U] 范围内寻找答案。 分组背包有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值 res[k][v]=max(res[k-1][v],res[k][v-c[i]]+wi),ci,wi 为组中的东西 依赖背包这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则策略有 2n + 1 个，为指数级。 考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于依赖背包中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。 再考虑对每组内的物品应用完全背包中的优化。我们可以想到，对于第 k 个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 k 的“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的物品组，其中费用为 v 的物品的价值为 Fk[v − Ck] + Wk，v 的取值范围是 Ck ≤ v ≤ V 。 也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，将主件 k 及其附件转化为 V − Ck + 1 个物品的物品组，就可以直接应用6的算法解决问题了。 在树形依赖的背包问题中，我们将每颗子树作为一个泛化物品来看。同样，我们可以对每个主件的附件集合进行处理，合成一个新的泛化物品。即对每个主件的附件集合做一次01背包，得到res[j],j为0……v-wi,wi为第i个主件的空间，表示该附件集合在分配体积为j的情况下该附件总和的最优值。 更一般的问题是：依赖关系以图论中“森林”3的形式给出。 也就是说，主件的附件仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物品”的思想。看完泛化物品后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。 泛化物品考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它费用 v，可得到价值 h[v]。一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w ·v c，其它函数值均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函数有 h(v) = w ·vc 仅当 v 被 c 整除且 vc ≤ n，其它情况函数值均为 0。 一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。 泛化物品的和如果给定了两个泛化物品 h 和 l，要用一定的费用从这两个泛化物品中得到最大的价值，这个问题怎么求呢？事实上，对于一个给定的费用 v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v，可以求得费用v 分配到 h 和 l 中的最大价值 f(v)。 f(v)=max(h(k)+l(v-k)) k=1……v 由泛化物品的定义可知：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。若问题的和为 s，则答案就是 s(0 . . . V ) 中的最大值。 搜索还是DP?在看到一道背包问题时，应该用搜索还是动态规划呢？ 首先，可以从数据范围中得到命题人意图的线索。如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考察动态规划了。 另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。","path":"2020/07/13/算法/背包九讲/"},{"title":"打家劫舍","text":"粉刷房子1这个题目leetcode需要会员，题干如下。假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[17,2,17],[16,16,5],[14,3,19]]输出: 10解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。 最少花费: 2 + 5 + 3 = 10。 选取第i个房子涂不同颜色的最小值public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs) &#123; int n=costs.size(); if(n==0) return 0; int a=costs[0][0],b=costs[0][1],c=costs[0][2]; int t1,t2,t3; for(int i=0;i&lt;n;i++) &#123; t1=a; t2=b; t3=c; a=min(b,c)+costs[i][0];//刷成红色的最大值 b=min(t1,t3)+costs[i][1]; c=min(t1,t2)+costs[i][2];//刷成蓝色 &#125; return min((min(a,b)),c); &#125; 粉刷房子2假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。 当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。 例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。 注意： 所有花费均为正整数。 示例： 输入: [[1,5,3],[2,9,4]]输出: 5解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5; 或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5. 这个题目如果用正常的思路，那么应该是对每个位置的房子，选取不同的颜色k，然后取其颜色不为k最小值。O(nkk). 会导致超时，复杂度过高。 可以优化每次选上一个的最短花费和次短花费。如果颜色和最短花费不一样，则选最短花费，否则选次短花费。这个地方应该注意一点，我之前很迷惑如果最短和次短都是和它一个颜色怎么办呢，后来才发现其实选的是在上一个位置颜色不同的最短花费和次短花费。这个地方比较巧妙，需要额外注意。 public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs,int k) &#123; int n=costs.size(); if(n==0||costs[0].size()==0) return 0; auto res=costs; int tmp1=0,tmp2=1; int a1=-1,a2=-1; for(int i=0;i&lt;n;i++) &#123; a1=-1; a2=-1; for(int j=0;j&lt;k;j++) &#123; if(j==tmp1) &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp1]+costs[i][j]); &#125; else &#123; res[i][j]=(i==0?costs[i][j]:res[i-1][tmp2]+costs[i][j]); &#125; if(a2&lt;0||res[i][j]&lt;res[i][a2]) &#123; a2=j; if(a2&lt;0||res[i][a2]&lt;res[i][a1]) &#123; swap(a2,a1); &#125; &#125; &#125; tmp1=a1; tmp2=a2; &#125; return res[n-1][tmp1]; &#125;","path":"2020/07/13/算法/粉刷房子/"},{"title":"打家劫舍","text":"打家劫舍1递推公式为d0[i]=d1[i-1]+price,d1[i]=max(d1[i-1],d0[i-1]);可以进行空间优化class Solution &#123; public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int a=nums[0]; int b=0; int len=nums.size(); int t; for(int i=1;i&lt;len;i++) &#123; t=a; a=b+nums[i]; b=max(b,t); &#125; return max(a,b); &#125; &#125;; 打家劫舍2只需要保证最后一个和第一个不会被同时取到，注意这个不是约瑟夫问题那样可以循环的。所以只需要求两次然后考虑删除第一个和删除最后一个的情况。 int rob(vector&lt;int&gt;&amp; nums) &#123;//不能来回偷 int len=nums.size(); if(len==0) return 0; if(len==1) return nums[0]; vector&lt;int&gt; res1; res1.assign(nums.begin()+1, nums.end()); vector&lt;int&gt; res2; res2.assign(nums.begin(),nums.end()-1); int a=res2[0]; int b=0; int t; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res2[i]; b=max(t,b); &#125; int res=max(a,b); a=res1[0]; b=0; for(int i=1;i&lt;len-1;i++) &#123; t=a; a=b+res1[i]; b=max(t,b); &#125; int tt=max(a,b); return max(res,tt); &#125; 打家劫舍3这个结构是树形的，相比数组的要难一些，所以第一种方法就是考虑根节点偷和不偷的情况，然后返回之，我第一次做是用的递归返回的是偷和随便偷不偷，这样是不行的，应该要明确状态。 vector&lt;int&gt; dp0(TreeNode* root) &#123; vector&lt;int&gt; res(2,0); if(root==nullptr) return res; vector&lt;int&gt; res1=dp0(root-&gt;left); vector&lt;int&gt; res2=dp0(root-&gt;right); res[0]=root-&gt;val+res1[1]+res2[1];//偷这个根节点的选项 res[1]=max(res1[0],res1[1])+max(res2[0],res2[1]);//不偷的选项 return res; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; vector&lt;int&gt; res=dp0(root); return max(res[0],res[1]); &#125; 事实上确实有一种考虑随便偷不偷的方法的。在区分偷不偷的时候，我们事实上考虑的是偷目前节点加上随便偷不偷孙子节点，以及不偷目前节点，随便偷不偷儿子节点。为了防止超时，用哈希表把求得的信息存起来。unordered_map&lt;TreeNode*,int&gt; m; int dp0(TreeNode* root,unordered_map&lt;TreeNode*,int&gt;&amp; m) &#123; int value=0; if(root==nullptr) return 0; if(m.count(root)) return m[root]; if(root-&gt;left!=nullptr) value+=dp0(root-&gt;left-&gt;left,m)+dp0(root-&gt;left-&gt;right,m); if(root-&gt;right!=nullptr) value+=dp0(root-&gt;right-&gt;left,m)+dp0(root-&gt;right-&gt;right,m); int t=max(root-&gt;val+value,dp0(root-&gt;right,m)+dp0(root-&gt;left,m)); m[root]=t; return t; &#125; int rob(TreeNode* root) &#123; if(root==nullptr) return 0; return dp0(root,m); &#125;","path":"2020/07/13/算法/打家劫舍/"},{"title":"股票买卖问题","text":"股票买卖问题1当前的最大收益只依赖于之前的最小买入价格。只需要记住到目前为止的最小值，然后可以得到每个位置的收益。O(n)class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int max=0; int len=prices.size(); if(len==0) return 0; int min=prices[0]; for(int i=0;i&lt;len;i++) &#123; if(prices[i]&gt;min) &#123; int t=prices[i]-min; if(max&lt;t) max=t; &#125; else &#123; min=prices[i]; &#125; &#125; return max; &#125; &#125;; 股票买卖问题2这个题目朴素的想法就是找到每个峰谷和峰顶，然后求差异获得利润。但是由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1 class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; int len=prices.size(); for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125; &#125;; 股票买卖问题3int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(3,0); vector&lt;int&gt; res2(3,0); for(int i=0;i&lt;3;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=2;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[2]; &#125; 股票买卖问题4买卖k次 当前处于第几天；已经交易的次数；手头是否持有股票；即根据手头是否持有股票，我们定义两个二维数组来定义状态： dp0[i][j]: 第i天结束，已有j次买卖，手头没有股票时的最大利润dp1[i][j]: 第i天结束，已有j次买卖，手头有股票时的最大利润因此，dp0[0][j]对于所有j都要初始化为0，而dp1[0][j]对于所有j都要初始化为-prices[i]。如果我们将dp0所有值都求出来了，那么很明显dp0[n-1][k]就是在最后一天结束时已进行k次交易且手头无股票时的最大收益，也即返回结果。 先看初始状态: 当i==0 &amp;&amp; j&gt;=0: dp0[0][j] = 0, dp1[0][j] = -prices[0];当i&gt;0 &amp;&amp; j==0: dp0[i][0] = 0, dp1[i][0] = max(dp1[i-1][0], -prices[i]);再来考虑状态转移方程，当i&gt;0且j&gt;0时有 dp0[i][j] = max(dp0[i-1][j], dp1[i-1][j-1] + prices[i]) # 保持 or 卖出dp1[i][j] = max(dp1[i-1][j], dp0[i-1][j] - prices[i]) # 保持 or 买入有了状态定义及转移方程，剩下就好办了。 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int k=2;//可以改变k值 int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; a(k+1,0); vector&lt;vector&lt;int&gt;&gt; res1(len,a);//没有股票在手中 vector&lt;vector&lt;int&gt;&gt; res2(len,a);//有股票在手中 int min=prices[0]; for(int i=0;i&lt;k;i++) res2[0][i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[i][0]=max(res2[i-1][0],-prices[i]); &#125; for(int i=1;i&lt;len;i++) &#123; for(int j=1;j&lt;=k;j++) &#123; res1[i][j]=max(res1[i-1][j],res2[i-1][j-1]+prices[i]); res2[i][j]=max(res1[i-1][j]-prices[i],res2[i-1][j]); &#125; &#125; return res1[len-1][k]; &#125; 但是这个效率不高，可以知道，当k&gt;2/n的时候。就是买卖无数次了。并且可以进行空间优化。int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0||k==0) return 0; if(k&gt;len/2) &#123; int result=0; for(int i=1;i&lt;len;i++) &#123; if(prices[i]&gt;prices[i-1]) result+=prices[i]-prices[i-1]; &#125; return result; &#125; vector&lt;int&gt; res1(k+1,0); vector&lt;int&gt; res2(k+1,0); int min=prices[0]; for(int i=0;i&lt;k;i++) res2[i]=-prices[0]; for(int i=1;i&lt;len;i++) &#123; res2[0]=max(res2[0],-prices[i]); for(int j=1;j&lt;=k;j++) &#123; res1[j]=max(res1[j],res2[j-1]+prices[i]); res2[j]=max(res1[j]-prices[i],res2[j]); &#125; &#125; return res1[k]; &#125; 股票买卖问题5这里需要注意的就是当不持股，不在冷冻期的可能就是，上一个是冷冻期，然后这一天啥也没干，还有可能就是直接就是上一天。int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; vector&lt;int&gt; res1(len,0);//不持股，不在冷冻期 vector&lt;int&gt; res2(len,0);//持股，不在冷冻期 res2[0]=-prices[0]; vector&lt;int&gt; res3(len,0);//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; res1[i]=max(res1[i-1],res3[i-1]); res2[i]=max(res1[i-1]-prices[i],res2[i-1]); res3[i]=res2[i-1]+prices[i]; &#125; return max(res3[len-1],res1[len-1]); &#125; 优化空间 int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int len=prices.size(); if(len==0) return 0; int res1=0;//不持股，不在冷冻期 int res2=-prices[0];//持股，不在冷冻期 int res3=0;//不持股，在冷冻期 for(int i=1;i&lt;len;i++) &#123; int a=res1; int b=res2; res1=max(a,res3); res2=max(a-prices[i],b); res3=b+prices[i]; &#125; return max(res3,res1); &#125; 股票买卖问题6也是和之前的类似，选取两个状态，持有股票，不持有股票，在卖出时还需要减去手续费。 int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int len=prices.size(); int res1=0; int res2=-prices[0]; int t; for(int i=0;i&lt;len;i++) &#123; t=res1; res1=max(res1,res2+prices[i]-fee); res2=max(res2,t-prices[i]); &#125; return res1; &#125;","path":"2020/07/12/算法/股票买卖问题/"},{"title":"动态规划题型总结","text":"因为动态规划毕竟要满足： 阶段性无后效性子问题重叠性因此，能够利用DP来解决的问题实际上是有限的，大部分题目都是针对现有的模型的一些变种，改改题目描述，或者加点限制条件。所以要想攻克DP题目，最根本的就是要充分理解几个常见的DP模型。而要充分理解常见经典DP模型，就需要通过大量的做题和总结，而且二者不可偏废。通过做题进行思考和量的积累，通过总结加深理解和融会贯通进而完成质的提升。 动态规划是求解一个最优化问题，而最核心的思想就是： 分而治之想办法记录下中间的计算结果避免重复计算解一道DP题目，先问自己几个问题： 我需要最少哪些数据，然后经过一些比较就能得出最终结果？这些数据的求解是否可以用同样的方法分而治之？过程中的运算结果如何保存复用？当然以上内容看起来比较抽象，虽然它深刻地揭露了动态规划的本质，但是如果临场要去想明白这些问题，还是有些难度。如果只是针对比赛和面试，就像前面说的，DP题型是有限的。只要刷的题目足够多，总结出几个经典模型，剩下的都是些变种+优化而已。 一般来说，动态规划可以分成4个大类: 线性DP数位dp概率dp等区间DP树型DP背包线性DP就是阶段非常线性直观的模型，比如：最长（上升|下降）序列，最长公共子序列(LCS)等，也有一些简单的递推，甚至都算不上是经典模型。 线性dp最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。相关题目比如： 300. 最长上升子序列，裸题，但是要击败100%的话，需要单调队列优化。 354. 俄罗斯套娃信封问题，这道题还是hard。之前的最长上升序列是一维的，这道题是二维的上升序列，满足Ax&lt;Bx且Ay&lt;By，才可以构成上升序列。那么我们可以根据x进行排序，然后对y求解最长上升子序列。但是这里有个地方需要注意，因为x必须要严格升序，排序之后可能存在(1,1) (1,2) (1,3) (2,4)这样的序列，如果对y进行求解上升序列，会得到4，但是实际应该只是2。为了避免这个问题，在排序时，如果x相等，则y按照降序排列，就可以规避这个问题。 合唱队形，这道题是要求一个形如1 3 4 7 9 8 6 5 2这样的子序列。先上升再下降，最后求最长的长度。其实解决办法也很简单，先从左到右求出所有的最长上升序列asc[i]，再从右到左求出所有的最长上升序列reverseAcc[i]，最大值就是max(asc[i]+reverseAcc[i])。对算法要能够灵活运用。 LCS 最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。相关题目： 1143. Longest Common Subsequence：这道题就是裸的LCS 583. Delete Operation for Two Strings：两个字符串要删除成一样的，所以先找出最长公共序列，然后剩下的都删了。 718. Maximum Length of Repeated Subarray：这道题其实本质上不是LCS，它是寻找最长子数组，而不是子序列（子数组要求连续）。需要搞清它们的区别。找子数组就更简单了，因为必须连续，所以f[i][j] = f[i-1][j-1]+1 : 0 ? S[i]==T[j]。通过倒序枚举能够把空间优化为O(N)。 1092. Shortest Common Supersequence：这道题是hard，实际上也不算很hard。其实就是找到最长公共子序列，然后，对于A字符串，把除了LCS以外的字符插入到对应的位置；对于B字符串也做同样的操作。这道题大家需要掌握一个新姿势，就是除了求最长公共子序列有多长，还要会打印最长公共子序列（follow up：打印所有可能的最长公共子序列）。同时，要把剩余的字符插入到对应的位置其实可以想办法把原字符串按照LCS切分成k+1段，比如对于字符串A abcxdef，其lcs为bde，那么我们可以把原字符串切成4段 a bcx d ef，同样对于B字符串，也能切成4段，然后对应插入构成新字符串即可，需要注意的就是，从第1段开始，第一个字符是lcs字符，所以只插一次。 股票买卖问题 Best Time to Buy and Sell Stock：当前的最大收益只依赖于之前的最小买入价格。因此只需要一个变量保存截至目前的最低价即可，每次更新最大收益。 Best Time to Buy and Sell Stock II：由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1。 可以买卖两次股票三个状态，已经买卖2次，持有 不持有股票，第k天为结束天 可以买卖k次股票三个状态，已经买卖k次，持有 不持有股票，第k天为结束天 卖出股票之后有冷冻期选择三个状态，持有股票，不持有股票，处于冷冻期 卖出股票之后有手续费选择两个状态，持有股票，不持有股票 打家劫舍粉刷房子背包九讲图形问题区间dp树形dp","path":"2020/07/12/算法/动态规划/"},{"title":"1143. 最长公共子序列","text":"最长公共子序列最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有: f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。 class Solution &#123; public://使用了2N的空间的动态优化 int longestCommonSubsequence(string text1, string text2) &#123; int len1=text1.size(); int len2=text2.size(); vector&lt;int&gt; a1(len2+1,0); vector&lt;int&gt; a2(len2+1,0); int flag=2; for(int i=0;i&lt;len1;i++) &#123; for(int j=0;j&lt;len2;j++) &#123; if(text1[i]==text2[j]) &#123; if(flag==2) a2[j+1]=a1[j]+1; else a1[j+1]=a2[j]+1; &#125; else &#123; if(flag==2) a2[j+1]=max(a2[j],a1[j+1]); else a1[j+1]=max(a2[j+1],a1[j]); &#125; &#125; flag=-flag; &#125; if(flag==2) return a1[len2]; else return a2[len2]; &#125; &#125;;","path":"2020/07/12/算法/1143.最长公共子序列/"},{"title":"300. 最长上升子序列","text":"最长上升序列最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。 说单调队列优化之前必须明白一个贪心策略。因为要求的是最长上升序列，那么很显然长度为k的上升序列的最大值（最后一个数）越小越好，这样后面的数才有更大的概率比它大。如果我们记录下来不同长度的上升序列的最后一个数能达到的最小值，那么对于后续每个数t，它要么能放到某个长度为y的序列之后，组成长度为y+1的上升序列，要么放到某个长度为x的序列后面，把长度为x+1的序列的最大值替换成t。同时我们可以发现，如果x&lt;y，那么长度为x序列的最后一个数一定比长度为y的序列最后一个数小。因此这个上升序列我们可以用一个数组来维护（所谓的单调队列），数组下标就代表序列长度。opt[i]=t表示长度为i的上升序列最后一个数最小是t。那么当我们在面对后续某个数x时，可以对单调队列opt进行二分，把它插到对应的位置。因此总体复杂度就是NlogN。 class Solution &#123; public: // int lengthOfLIS(vector&lt;int&gt;&amp; nums) // &#123;//dp，不用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) // int len=nums.size(); // if(len==0) // return 0; // vector&lt;int&gt; res(len,0); // res[0]=1; // int result=1; // for(int i=1;i&lt;len;i++) // &#123; // int maxnum=1; // for(int j=0;j&lt;i;j++) // &#123; // if(res[j]+1&gt;maxnum&amp;&amp;nums[j]&lt;nums[i]) // maxnum=res[j]+1; // &#125; // res[i]=maxnum; // if(res[i]&gt;result) // result=res[i]; // &#125; // return result; // &#125; int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;//dp，用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i]) int len=nums.size(); if(len==0) return 0; vector&lt;int&gt; res; for(int i=0;i&lt;len;i++) &#123; if(res.size()==0||res[res.size()-1]&lt;nums[i]) res.push_back(nums[i]); else //if(res[res.size()-1]&lt;nums[i]) &#123; int p=BinSearch(res,nums[i]); res[p]=nums[i]; &#125; &#125; return res.size(); &#125; int BinSearch(vector&lt;int&gt;&amp; a,int b) &#123; int len=a.size(); int l=0,r=len-1; int mid=l+(r-l)/2; while(a[mid]!=b) &#123; if(r==l) return r; if(a[mid]&lt;b) &#123; l=mid+1; &#125; else &#123; r=mid; &#125; mid=mid=l+(r-l)/2; &#125; return mid; &#125; &#125;;","path":"2020/07/12/算法/300. 最长上升子序列/"},{"title":"65. 有效数字","text":"题目使用有穷自动机来解决，画出DFA就可以很好的解决。有穷自动机可见 代码如下：100%内存100%速度&lt;!—hexoPostRenderEscape:class Solution &#123;public: bool isNumber(string s) &#123; int sta; if(s.size()&lt;=0) return false; if(isdigit(s[0])) sta=2; else if(s[0]==&#x27;.&#x27;) sta=4; else if(s[0]==&#x27; &#x27;) sta=1; else if(s[0]==&#x27;-&#x27;||s[0]==&#x27;+&#x27;) sta=3; else return false; for(int i=1;i&lt;s.size();i++) &#123; switch(sta) &#123; case 1: if(isdigit(s[i])) sta=2; else if(s[i]==&#x27;.&#x27;) sta=4; else if(s[i]==&#x27; &#x27;) sta=1; else if(s[i]==&#x27;-&#x27;||s[i]==&#x27;+&#x27;) sta=3; else return false; break; case 2: if(isdigit(s[i])) sta=2; else if(s[i]==&#x27;.&#x27;) sta=5; else if(s[i]==&#x27;e&#x27;) sta=7; else if(s[i]==&#x27; &#x27;) sta=6; else return false; break; case 3: if(isdigit(s[i])) sta=2; else if(s[i]==&#x27;.&#x27;) sta=4; else return false; break; case 4: if(isdigit(s[i])) sta=5; else return false; break; case 5: if(isdigit(s[i])) sta=5; else if(s[i]==&#x27;e&#x27;) sta=7; else if(s[i]==&#x27; &#x27;) sta=6; else return false; break; case 6: if(s[i]==&#x27; &#x27;) sta=6; else return false; break; case 7: if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;) sta=8; else if(isdigit(s[i])) sta=9; else return false; break; case 8: if(isdigit(s[i])) sta=9; else return false; break; case 9: if(isdigit(s[i])) sta=9; else if(s[i]==&#x27; &#x27;) sta=6; else return false; break; &#125; &#125; cout&lt;&lt;sta; if(sta==2||sta==5||sta==9||sta==6) return true; else return false; &amp;#125; &#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/07/03/算法/[LeetCode] 65. 有效数字/"},{"title":"验证集和测试集的区别","text":"验证集和测试集 类别 验证集 测试集 是否被训练到 否 否 作用 用于调整超参数 用于验证泛化能力 使用次数 多次使用，以不断调参 仅仅一次使用 缺陷 模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够 测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集 互相转化 验证集具有足够泛化性（一般来说，如果验证集足够大到包括大部分非训练集时，也等于具有足够泛化性了） 验证集具有足够泛化性时，测试集就没有存在的必要了 类比 校内答辩（如果校内答辩比多校联合答辩还有泛化性说服力，那么就没有必要再搞个多校联合答辩了） 多校联合答辩 附言说到底：验证集是一定需要的；如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。","path":"2020/07/03/深度学习/验证集和测试集的区别/"},{"title":"166. 分数到小数","text":"166. 分数到小数这道题我认为需要注意的有几个地方 第一个地方在于除法如何计算，这里我选择的方法是当被除数相同的时候认为是循环小数。 第二个地方在于结果可能有负数，负数的求模和正数有所不同，需要注意。负数求模是a-(a/b)*b的，有个时候因此会有正负的区分。 第三个地方在于数字溢出的问题，a=-2147483648, b=-1,a*b是会溢出的，因为会先转成一个整形的数，因此需要转一下long. 第四个地方是在判断两个数是否是同号的时候最好采用异或的方法，而不要采用相乘符号的方法，这样会导致溢出，还有一个我以前没注意的地方就是异或等位运算的优先级是要低于等于符号的，因此最好加上括号。 代码如下class Solution &#123; public: string fractionToDecimal(int numerator, int denominator) &#123; long a1=long(numerator)%denominator; long a2=long(numerator)/denominator; if(a1==0) return to_string(a2); else &#123; int i=0; int quo=abs(a2); string res=&quot;&quot;; if((numerator^denominator)&lt;0) &#123; res=res+&quot;-&quot;; i++; &#125; res=res+to_string(quo)+&quot;.&quot;; i+=to_string(quo).size()-1; unordered_map&lt;int,int&gt; map; numerator=abs(a1); while(numerator!=0) &#123; numerator=abs(numerator); if(map.find(numerator)==map.end()) &#123; map[numerator]=i; i++; &#125; else &#123; string tmp=res.substr(map[numerator]+2); string tmp1=res.substr(0,map[numerator]+2); res=tmp1+&quot;(&quot;+tmp+&quot;)&quot;; return res; &#125; long ttt=numerator; ttt*=10; long a=abs(ttt/denominator); long b=abs(ttt%denominator); res=res+to_string(a); numerator=b; &#125; return res; &#125; &#125; &#125;;","path":"2020/06/12/算法/166. 分数到小数/"},{"title":"设计模式","text":"设计模式学习[toc] 设计模式和原则单一职责的原则简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑更改的时候就不需要修改很多东西，更容易维护。 开闭原则就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。 里氏替换原则简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变 如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。 接口隔离原则接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。 要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 依赖倒置原则依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 在实际编程中只要遵循以下4点，就能在项目中满足这个规则。每个类尽量提供接口或抽象类，或者两者都具备。变量的声明类型尽量是接口或者是抽象类。任何类都不应该从具体类派生。使用继承时尽量遵循里氏替换原则。 创建型模式","path":"2020/06/03/设计模式/设计模式/"},{"title":"ART算法实现与理解","text":"Code这两个图显示了算法的原理，整体的几何意义也较为容易理解 import numpy as np def ART_My( A, b, X0, e0): e=e0+1 i=0 while(e&gt;e0): tmp=((A[i]@X0-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i]))) X=X0-np.reshape(tmp,(-1,1)) e=np.linalg.norm(X-X0) X0=X i=(i+1)%np.shape(A)[0] print(e) return X0 if __name__==&quot;__main__&quot;: A=np.array([[3,1],[1,5]]) b=np.array([[1],[1]]) e0=0.000001 X0=np.array([[0],[0]]) X=ART_My(A,b,X0,e0) print((X))","path":"2020/06/03/医学图像/ART算法实现与理解/"},{"title":"函数间隔和几何间隔","text":"对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。 SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。","path":"2020/05/21/深度学习/函数间隔和几何间隔/"},{"title":"大端和小端","text":"字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下Big-endian：高位字节存入低地址，低位字节存入高地址Little-endian：低位字节存入低地址，高位字节存入高地址一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。 因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序","path":"2020/05/20/C++/大端和小端/"},{"title":"218. 天际线问题","text":"问题的求解方法一其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。 接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。 如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。 但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。 扫描线移到[2 10]关键点时，10要大于rpre的，可以满足； 扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足； 扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足； 接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。 这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。这个问题的求解方法的重点在于合并两个点，合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。 在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(buildings.length==0) return res; return divide(buildings,0,buildings.length-1); &#125; public List&lt;List&lt;Integer&gt;&gt; divide(int [][]buildings,int l,int r) &#123; List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(r==l) &#123; res.add(Arrays.asList(buildings[l][0],buildings[l][2])); res.add(Arrays.asList(buildings[l][1],0)); return res; &#125; int a=l+(r-l)/2; List&lt;List&lt;Integer&gt;&gt; res1=divide(buildings,l,a); List&lt;List&lt;Integer&gt;&gt; res2=divide(buildings,a+1,r); int l1=0; int r1=0; int lh=0,rh=0; int leftX, leftY, rightX, rightY; while(l1&lt;res1.size()||r1&lt;res2.size()) &#123; if(l1&gt;=res1.size()) res.add(res2.get(r1++)); else if(r1&gt;=res2.size()) res.add(res1.get(l1++)); else &#123; leftX = res1.get(l1).get(0); // 不会出现null，可以直接用int类型 leftY = res1.get(l1).get(1); rightX = res2.get(r1).get(0); rightY = res2.get(r1).get(1); if(leftX&gt;rightX)//每次选择一个较小的 &#123; if(rightY&gt;lh) res.add(res2.get(r1)); else if(rh&gt;lh) &#123; res.add(Arrays.asList(rightX,lh)); &#125; rh=rightY; r1++; &#125; else if(leftX&lt;rightX) &#123; if(leftY&gt;rh) res.add(res1.get(l1)); else if(lh&gt;rh) res.add(Arrays.asList(leftX,rh)); lh=leftY; l1++; &#125; else &#123; int h=Math.max(lh,rh); if(leftY&gt;=rightY&amp;&amp;leftY!=h) &#123; res.add(res1.get(l1)); &#125; else if(leftY&lt;=rightY&amp;&amp;rightY!=h)//只要不汇聚到最高点就没问题 &#123; res.add(res2.get(r1)); &#125; lh=leftY; rh=rightY; l1++; r1++; &#125; &#125; &#125; return res; &#125; &#125; 这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，然后每次和最大的节点进行比较，不同就加入节点。这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。 class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings) &#123; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;List&lt;Integer&gt;&gt;(); Set&lt;Pair&lt;Integer,Integer&gt;&gt; pairs=new TreeSet&lt;&gt;((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue()); for(int[] bu:buildings) &#123; pairs.add(new Pair&lt;&gt;(bu[0],-bu[2])); pairs.add(new Pair&lt;&gt;(bu[1],bu[2])); &#125; PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); int prev = 0; // 遍历 for (Pair&lt;Integer, Integer&gt; pair : pairs) &#123; if (pair.getValue() &lt; 0) queue.offer(-pair.getValue()); // 左端点 高度入堆 else queue.remove(pair.getValue()); // 右端点 高度出堆 Integer cur = queue.peek() == null ? 0 : queue.peek(); // 获取最大堆的当前顶点，当null时置为0 if (prev != cur) &#123; res.add(new ArrayList&lt;Integer&gt;() &#123; &#123; add(pair.getKey()); add(cur); &#125;&#125;); prev = cur; &#125; &#125; return res; &#125; &#125;","path":"2020/05/20/算法/218. 天际线问题/"},{"title":"为啥那么C++pop不返回值","text":"书上的解释也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。 这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素 在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。 按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下， 因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。 从异常上看这么使用 Stack stack; stack.push(object); Object obj=stack.pop() ; 当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的， 假设这时候发生异常，丢生的栈顶元素就回不去了。 而在java中pop（）是有返回值的源码是这么写的 int i = size(); Object object = peek(); removeElementAt(i - 1); return (E)object; 实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，","path":"2020/05/20/C++/为什么C++pop不返回值/"},{"title":"145. 二叉树的后序遍历","text":"方法后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。 所以方法有三种： 开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); Set&lt;TreeNode&gt; set=new HashSet&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(!set.contains(tmp)&amp;&amp;tmp.right!=null) &#123; treenode=tmp.right; set.add(tmp); &#125; else &#123; res.add(tmp.val); stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; TreeNode last=null; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; stack.push(treenode); treenode=treenode.left; &#125; else &#123; TreeNode tmp=stack.peek(); if(tmp.right!=null&amp;&amp;tmp.right!=last) &#123; treenode=tmp.right; &#125; else &#123; res.add(tmp.val); last=tmp; stack.pop(); &#125; &#125; &#125; return res; &#125; &#125; 只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙 public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pop(); if (cur == null) &#123; continue; &#125; if (!stack.isEmpty() &amp;&amp; cur == stack.peek()) &#123; stack.push(cur.right); stack.push(cur.right); stack.push(cur.left); stack.push(cur.left); &#125; else &#123; list.add(cur.val); &#125; &#125; return list; &#125; 可以转换成一个逆的前序遍历来实现public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); Stack&lt;TreeNode&gt; stack=new Stack&lt;TreeNode&gt;(); TreeNode treenode=root; while(!stack.isEmpty()||treenode!=null) &#123; if(treenode!=null) &#123; res.add(treenode.val); stack.add(treenode); treenode=treenode.right; &#125; else &#123; treenode=stack.pop().left; &#125; &#125; Collections.reverse(res); return res; &#125;","path":"2020/05/19/算法/145. 二叉树的后序遍历/"},{"title":"232. 用栈实现队列","text":"双栈实现队列，思路较为简单 ···class MyQueue { private Stack stack1; private Stack stack2; /* Initialize your data structure here. / public MyQueue() { stack1=new Stack(); stack2=new Stack(); } /** Push element x to the back of queue. */ public void push(int x) &#123; stack1.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; if(stack2.isEmpty()) &#123; StackMove(stack1,stack2); &#125; int res=stack2.peek(); stack2.pop(); return res; &#125; /** Get the front element. */ public int peek() &#123; if(stack2.isEmpty()) &#123; StackMove(stack1,stack2); &#125; int res=stack2.peek(); return res; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); &#125; public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2) &#123; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; int a=stack1.peek(); stack2.push(a); stack1.pop(); &#125; &#125; &#125; } /** Your MyQueue object will be instantiated and called as such: MyQueue obj = new MyQueue(); obj.push(x); int param_2 = obj.pop(); int param_3 = obj.peek(); boolean param_4 = obj.empty();*/···","path":"2020/05/19/算法/232. 用栈实现队列/"},{"title":"225. 用队列实现栈","text":"队列实现栈主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。&lt;!—hexoPostRenderEscape:class MyStack &#123;&lt;/span&gt; private Queue&lt;Integer&gt; quene=new LinkedList&lt;Integer&gt;(); private int mytop=0; /* Initialize your data structure here. / public MyStack() &lt;/span&gt;&#123; &#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Push element x onto stack. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123; quene.offer(x); mytop=x; &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Removes the element on top of the stack and returns that element. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;i++) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=quene.poll(); quene.offer(a); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;) mytop=a; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; quene.poll(); &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Get the top element. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!quene.isEmpty()) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mytop; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-comment&quot;&gt;/** Returns whether the stack is empty. */&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;; &amp;#125; &#125; /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/19/算法/225. 用队列实现栈/"},{"title":"linux短横线的区别","text":"linux短横线的区别rm -vf *** tar -xzvf ***.tar.gz gcc --version rm --help 从上面命令我们可以看出，绝大数命令有以下的规则： ① 参数前单杠的表明后面的参数是字符形式； ② 参数前双杠的则表明后面的参数是单词形式 tar xzvf ***.tar.gz tar -xzvf ***.tar.gz 两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下： ① 参数前有横的是System V风格。 ② 参数前没有横的是BSD风格。 System V和BSD两种风格的区别主要是： 系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。 System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。","path":"2020/05/18/操作系统/linux短横线的区别/"},{"title":"224. 基本计算器","text":"方法1和方法二：只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。&lt;!—hexoPostRenderEscape:方法一：class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 int t=0; int flag=1;//正在记录数字 for(int i=0;i&lt;s.length();i++) &#123; Character ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); System.out.println(t); flag=1; t=0; &#125; if(Character.isDigit(ch)) &#123; flag=0; int num=(int)(ch-&#x27;0&#x27;); t=t*10+num; &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)||ch.equals(&#x27;(&#x27;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#x27;)&#x27;)) &#123; op1.push(CalFormula(op1,op2)); &#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; op1.push(t); &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(t); flag=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;; t=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; CalFormula(op1,op2); &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; CalFormula(Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op1 , Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op2) &amp;#123; Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op3=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt;();//数字栈 Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op4=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt;();//字符栈 &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;!op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;)) &amp;#123; op3.push(op1.peek()); op1.pop(); op4.push(op2.peek()); op2.pop(); // &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(op2.peek()); &amp;#125; op3.push(op1.peek()); op1.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;)) op2.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op4.isEmpty()) &amp;#123; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=op3.peek(); op3.pop(); &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b=op3.peek(); op3.pop(); &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=op4.peek(); op4.pop(); op3.push(cal(c,a,b)); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op3.peek(); &amp;#125; &lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cal(&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt; ch,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num1) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(ch.equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;)) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num-num1; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num+num1; &amp;#125; &#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt; 方法2： class Solution &#123; public int calculate(String s) &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 Integer t=0; StringBuffer nu=new StringBuffer(&quot;&quot;); int flag=1;//正在记录数字 StringBuffer a=new StringBuffer(s); String str=a.reverse().toString(); for(int i=0;i&lt;str.length();i++) &#123; Character ch=str.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); flag=1; nu=new StringBuffer(&quot;&quot;); &#125; if(Character.isDigit(ch)) &#123; nu.append(ch); flag=0; &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)||ch.equals(&#x27;)&#x27;)) &#123; op2.push(ch); &#125; else if(ch.equals(&#x27;(&#x27;)) &#123; CalFormula(op1,op2); &#125; &#125; if(flag==0) &#123; t=Integer.parseInt(nu.reverse().toString()); op1.push(t); &#125; return CalFormula(op1,op2); &#125; public int CalFormula(Stack &lt;Integer&gt; op1 , Stack&lt;Character&gt; op2) &#123; Stack &lt;Integer&gt; op3=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op4=new Stack&lt;Character&gt;();//字符栈 while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#x27;)&#x27;)) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,a,b)); &#125; if(!op2.isEmpty()&amp;&amp;op2.peek().equals(&#x27;)&#x27;)) op2.pop(); return op1.peek(); &#125; public int cal(Character ch,Integer num,Integer num1) &#123; if(ch.equals(&#x27;-&#x27;)) return num-num1; else return num+num1; &#125; &#125; 方法三采用一种双栈的方法，解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。 使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符从左往右扫描，遇到操作数入栈 stack0遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1遇到左括号，直接入栈 stack1。遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。 第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。&lt;!—hexoPostRenderEscape:class Solution &#123;&lt;/span&gt; public int calculate(String s)&lt;/span&gt; &lt;/span&gt; &#123; Stack &lt;Integer&gt; op1=new Stack &lt;Integer&gt;();//数字栈 Stack&lt;Character&gt; op2=new Stack&lt;Character&gt;();//字符栈 HashMap&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); map.put(&#x27;+&#x27;,1); map.put(&#x27;-&#x27;,1); map.put(&#x27;(&#x27;,-1); Integer t=0; int flag=1; Character ch; for(int i=0;i&lt;s.length();i++) &#123; ch=s.charAt(i); if(flag==0&amp;&amp;!Character.isDigit(ch)) &#123; op1.push(t); t=0; flag=1; &#125; if(Character.isDigit(ch)) &#123; flag=0; t=t*10+(int)(ch-&#x27;0&#x27;); &#125; else if(ch.equals(&#x27;-&#x27;)||ch.equals(&#x27;+&#x27;)) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!(map.get(op2.peek())&lt;map.get(ch))) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.push(ch); &#125; else if(ch.equals(&#x27;(&#x27;)) &#123; flag=1; op2.push(ch); &#125; else if(ch.equals(&#x27;)&#x27;)) &#123; flag=1; while(!op2.isEmpty()&amp;&amp;!op2.peek().equals(&#x27;(&#x27;)) &#123; int a=op1.peek(); op1.pop(); int b=op1.peek(); op1.pop(); Character c=op2.peek(); op2.pop(); op1.push(cal(c,b,a)); &#125; op2.pop(); &#125; &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123; op1.push(t); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty()) &amp;#123; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op1.pop(); &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op1.pop(); Character c=op2.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); op2.pop(); op1.push(cal(c,b,a)); &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;(); &amp;#125; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Character ch,Integer num,Integer num1)&lt;/span&gt;&lt;/span&gt; &#123; if(ch.equals(&#x27;-&#x27;)) return num-num1; else return num+num1; &#125;&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/算法/224. 基本计算器/"},{"title":"统计学习方法-第九章EM算法及其推广","text":"第九章EM算法及其推广9.1 import numpy as np y=[1,1,0,1,0,0,1,0,1,1] pai=0.46 p=0.55 q=0.67 theta=2 while(theta&gt;0.0001): u_next=[] for i in range(len(y)): a=pai*(p**y[i])*((1-p)**(1-y[i])) b=(1-pai)*(q**y[i])*((1-q)**(1-y[i])) u_next.append(a/(a+b)) pai_next=0 p_next=0 q_next=0 tmp=0 pai_next=np.mean(u_next) p_next = sum(np.multiply(u_next,y))/sum(u_next) tmp=[1-u_next[i] for i in range(len(y))] q_next = sum(np.multiply(tmp,y))/sum(tmp) print(pai_next) print(p_next) print(q_next) print(&quot;\\n&quot;) theta=abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q) pai=pai_next p=p_next q=q_next 求得&lt;!—hexoPostRenderEscape:0.4618628351139190.53459500378501120.6561346417857326 0.461862835113919070.53459500378501120.6561346417857326&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/深度学习/统计学习方法课后作业/"},{"title":"神经网络初始化与xavier初始化","text":"xavier初始化 深度学习初始化总结","path":"2020/05/18/深度学习/神经网络初始化与xavier初始化/"},{"title":"矩阵的范数","text":"关于矩阵的范数的一些总结 一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说 核范数代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。 ||X||_*=\\sum_{i}^{}\\sigma_i(x)F范数即为就是对应元素的平方和再开方。f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，","path":"2020/05/18/深度学习/矩阵的范数/"},{"title":"矩阵求导","text":"参考文章","path":"2020/05/18/深度学习/矩阵求导/"},{"title":"在hexo博客中写数学公式","text":"这个网站值得借鉴","path":"2020/05/18/文档相关/在hexo博客中写数学公式/"},{"title":"图像的k空间","text":"关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像具体可见下面两篇博客k空间k空间","path":"2020/05/18/医学图像/图像的k空间/"},{"title":"矩阵的TV最小化","text":"在一个图像处理问题中如何有效的去除图像的噪声可以求解这样一个问题最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。","path":"2020/05/18/医学图像/TV最小化/"},{"title":"softmax和SVM损失函数","text":"softmax可以参考softmax可以参考 softmax可以参考主要要理解熵的原理，以及交叉熵。以及softmax的正则化的内容 SVM损失函数可以参考SVM损失函数可以参考主要是要比正确分类的类别多出一个边界出来","path":"2020/05/18/深度学习/softmax和SVM损失函数/"},{"title":"Numpy中矩阵与向量的加法","text":"在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。&lt;!—hexoPostRenderEscape:import numpy as np x = np.array([[1, 2, 3], [4, 5, 6]]) array([[1, 2, 3],[4, 5, 6]])y = np.array([1, 2]) array([1, 2])z = np.array([1, 2, 3]) array([1, 2, 3])x + y 会报错x + z array([[2, 4, 6],[5, 7, 9]])&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;","path":"2020/05/18/深度学习/numpy矩阵加法/"},{"title":"matlab并行","text":"parfor matlab用法matlab会弄出几个虚拟的小pc，一个算i=1:30部分循环,一个算i=50:80部分循环,再来一个算i=90:120部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i=1算到i=100，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算1+2+3...+100就可以用parfor，但是如果计算斐波那契数列的前100个数字，那就不能用parfor了。","path":"2020/05/18/医学图像/matlab并行/"},{"title":"makedown数学公式写法","text":"此网站可以查看公式写法","path":"2020/05/18/文档相关/makedown数学公式写法/"},{"title":"conda 安装 pytorch","text":"关于conda安装pytorch的一些问题的总结 使用conda安装pytorch较为简单在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是conda install pytorch torchvision cpuonly -c pytorch 但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像更换镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ 测试是否安装成功import torch 成功后代表安装成功 更多信息: 我的博客","path":"2020/05/18/深度学习/conda 安装 pytorch/"},{"title":"使用github+hexo部署博客","text":"可见这篇博客 更多信息: 我的博客","path":"2020/05/18/文档相关/github+hexo博客搭建/"},{"title":"图像生成","text":"可以参考这个博客图像生成cs231 同时这个人还总结了cs231的很多内容，可以都参考一下","path":"2020/05/18/深度学习/cs231图像生成/"}],"categories":[],"tags":[]}