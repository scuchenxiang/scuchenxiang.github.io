<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mit6.824 lab实现</title>
    <link href="/2022/04/06/%E5%88%86%E5%B8%83%E5%BC%8F/6.824%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/04/06/%E5%88%86%E5%B8%83%E5%BC%8F/6.824%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p>首先是选举，raft必须保证大部分机器可用。</p><p>以下是一些raft的基础的内容，三种角色，leader，candidate，follower。</p><h2 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h2><p>对于每个机器，一开始是follower，然后每隔一段时间如果没有收到Leader的心跳，那么任期+1，变为candidate，投票给自己，然后启动新的协程发起选举（如果在这过程中任期被改变或者role被改变（？？需不需要变为leader），那么选举结束），向其他的机器发送RPC，请求它们投票。</p><p>如果收到的reply的任期比我更大，那么转变为follower，更新任期。（需要保存磁盘）</p><p>如果收到投票给我的结果，并且我还是candidate，那么直接票数+1，超过半数的票，变为leader，并且初始化nextIndex为最后一条日志的索引值+1（代表下一条需要复制给server的日志索引，索引0代表快照）（需要保存磁盘）</p><h2 id="requestVoteRPC实现"><a href="#requestVoteRPC实现" class="headerlink" title="requestVoteRPC实现"></a>requestVoteRPC实现</h2><p>如果当收到来自其他server的选举请求的时候，如果对方任期更旧直接拒绝投票。</p><p>如果任期更新，那么更新自己的任期，并且转变为follower。（需要保存磁盘）</p><p>如果我的日志更新（比较日志任期和索引）那么也拒绝投票。</p><p>如果我的日志没有更新，同时我还没投票或者已经投了它（说明之前返回的RPC丢失了），那么投票给他，更新任期，刷新心跳（保存磁盘）</p><p>否则（说明已经投了别人），拒绝投票。</p><h2 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h2><p>leader每隔一段时间sleep之后开始处理事务，<br>查看nextIndex中的日志，如果index比leader快照的日志还旧，就发起InstallSnapshotRPC请求。</p><h3 id="1-应对InstallSnapshotRPC请求的回复"><a href="#1-应对InstallSnapshotRPC请求的回复" class="headerlink" title="1.应对InstallSnapshotRPC请求的回复"></a>1.应对InstallSnapshotRPC请求的回复</h3><p>如果对方任期更新，那么更新任期，转为follower，然后（保存磁盘），否则更新nextIndex为快照的最后一条日志号+1.</p><h3 id="1-1-InstallSnapshotRPC请求"><a href="#1-1-InstallSnapshotRPC请求" class="headerlink" title="1.1 InstallSnapshotRPC请求"></a>1.1 InstallSnapshotRPC请求</h3><p>当收到来自leader 的安装快照RPC的时候，首先肯定检查任期，任期太旧直接拒绝然后回复，然后变为follower（防止此时为candidate）。如果我的快照比leader发来的快照更新，那么就直接返回，不需要安装。否则，把对应的leader发来的快照以及我比leader快照更新的信息，打包到一起变为server的log，然后应用leader快照到状态机，然后更新commitIndex,快照数据（保存到磁盘）。</p><h3 id="2-应对AppendEntriesRPC请求的回复"><a href="#2-应对AppendEntriesRPC请求的回复" class="headerlink" title="2.应对AppendEntriesRPC请求的回复"></a>2.应对AppendEntriesRPC请求的回复</h3><p>否则就发送日志和心跳，这个时候要把从nextIndex到自己日志的最后一条日志复制给对方，然后附加自己，commitIndex（已经提交的索引号），之前已经已经发送的最后一条日志的索引和任期，以及自己的任期。发起AppendEntriesRPC请求</p><p>如果收到AppendEntriesRPC回复，如果对方拒绝，如果是因为对方的任期更新，那么更新任期，变为follower（需要保存磁盘），如果是因为日志号冲突了，那么更新自己的nextIndex（需要保存磁盘），然后返回。</p><p>如果复制的日志太老了早就复制过了，那么直接返回</p><p>如果没有，那么更新nextindex，matchIndex(每个服务器已经复制的最高索引),</p><p>（检查已经提交的日志索引如果大于等于已经复制到其他的服务器的索引，直接返回（这个时候说明已经提交了，后面再做没有必要））</p><p>（检查fig8的情况，如果复制的日志的任期和当前的任期不一致，那么不能提交，直接返回（后面也没必要了））</p><p>对于每个server，如果已经复制的日志索引（matchIndex）已经大于想要提交的日志索引,那么计数值+1，如果超过半数，那么就直接提交，应用到状态机，更新已经提交的索引号（需要保存磁盘）。</p><h3 id="2-1AppendEntriesRPC请求"><a href="#2-1AppendEntriesRPC请求" class="headerlink" title="2.1AppendEntriesRPC请求"></a>2.1AppendEntriesRPC请求</h3><p>首先肯定检查任期，如果leader的任期太旧，直接拒绝。否则，先转变为follower，更新任期，刷新心跳。</p><p>如果leader已经发送的最后一条日志索引比server的快照的最后一条还旧，说明发来的日志有一部分是重复的，直接返回。</p><p>如果leader已经发送的最后一条日志记录和server的冲突了，同时leader的lastcopyindex大于快照日志索引小于server最大的日志索引直接回退到这个任期的第一条日志（说明下一次leader从这个任期的第一条开始发）。如果同时leader的lastcopyindex大于server最大的日志索引，那么直接返回快照的最大索引+1。然后返回结果。</p><p>前面保证了lastcopyIndex在lastSnapshotIndex与lastLogIndex之间，然后追加日志（如果追加的日志比lastLogIndex小就不用追加）。</p><p>从那么从server发过来的commitIndex到leader的commitindex，应用到状态机。</p><h2 id="Go-语言在这里的特性，Goroutine"><a href="#Go-语言在这里的特性，Goroutine" class="headerlink" title="Go 语言在这里的特性，Goroutine"></a>Go 语言在这里的特性，Goroutine</h2><p>这个的用法在于比如说一开始每次机器都会有两个协程不断循环检查自己是follower，以及是leader的情况</p><p>follower：当发现leader给自己的心跳超时的时候，就开启协程开始选举，在这个协程开启n个协程来请求其他的机器给自己投票，每个请求投票的协程依据情况处理。</p><p>leader：每次经过一定的时间，对于每一个follower的机器，发现follower的机器太旧的时候，就启动一个发送快照的协程来处理，否则启动一个发送心跳和日志的协程来处理。</p><h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="Gob的小问题"><a href="#Gob的小问题" class="headerlink" title="Gob的小问题"></a>Gob的小问题</h2><p>Gob这个包序列化数据的时候，需要知道具体的类型，才可以将它正确的反序列化回来。我们在Start()中传入的参数是interface{}类型，所以如果不进行一些预先的安排，那么在follower中不能将OpArgs反序列出来。所以在StartKVServer()中需要调用gob.Register来注册一下</p><p>只有leader可以处理客户端的请求，如果其他角色接收到了请求，会重定向到leader。（这个实际上代码没这么写，我看大家都是如果不是leader就换下一个直到找到leader）。</p><p>客户端发起请求，然后</p><h2 id="监听raft状态机以及如何去重保持幂等性"><a href="#监听raft状态机以及如何去重保持幂等性" class="headerlink" title="监听raft状态机以及如何去重保持幂等性"></a>监听raft状态机以及如何去重保持幂等性</h2><p>对于每隔监听raft状态机的协程，如果发现是快照的命令，那么就读取快照，如果是op（如get，putappend）就首先去重，如果不是重复的命令就在kvdb中存下来，如果是重复的就不用做了，保持了幂等性，这个地方为什么不在RPC响应那里做呢，那里实际上有可能执行完之后，鉴定到raft状态机的命令，但是返回的resChan丢失了，这样就客户端就得不到结果了，因为会重发，但是重发总是被过滤。</p><p>对于返回给RPC的消息管道，用一个map管道数组来代替，然后每次使用之前防止有空的已有的消息，每次先清空。因为这个管道会有读写的情况，索引了一把锁来同步互斥。然后每次处理完OP如果发现日志太大就保存一下快照。</p><p>这里有一个关键点是对于重复的命令如何去重，去重采用的是应用到raft日志之后，达成一致性之后，如果没重复就写入到kvstorage中，如果重复了那么就跳过。</p><p>如果知道是不是重复的命令呢，要在kv中保存clientId到SeqNumId的一个map，SeqNumId记录的是已经执行的最大的命令号。小于等于的视为重复。一开始seqnum初始化为0.然后递增。</p><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>这里的RPC主要是get，put，append的RPC请求，比较简单，每次收到先执行raft的start函数，如果不是leader，直接返回结果，如果是，等待来自reschan的消息，如果消息超时，也返回对应的结果，如果没超时并且返回的Op和我们执行的一致就返回ok的结果。</p><h2 id="如何加锁"><a href="#如何加锁" class="headerlink" title="如何加锁"></a>如何加锁</h2><p>对于整体的函数，每次进入加一把大锁就行，然后对于reschan每次读的时候加锁，同时每次处理完OP如果发现日志太大（大于某个比例）就保存一下快照。</p><h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><pre><code>每次server启动就读取快照，每次收到来自raft状态机的消息，如果是快照类的，就读取快照。（读写快照时也需要加大锁）</code></pre><h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><p>lab4是基于lab2实现的基于raft协议的分片的key-value存储，主要包括ctrler节点和分片的group的服务端，还有客户端。</p><h3 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h3><p>把所有数据按照Key Hash然后取模10,把数据切分成10片.每一片称为一个Shard, 其中包括一组键值对</p><h3 id="ShardServer-Group"><a href="#ShardServer-Group" class="headerlink" title="ShardServer (Group)"></a>ShardServer (Group)</h3><p>每个Group都是一个Raft集群, 通过Raft保证这组服务器上的数据一致性. 一组服务器负责几个Shard的读写请求.整个集群由N个Group组成</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>客户端, 发起读写请求.</p><h3 id="Shardctrler"><a href="#Shardctrler" class="headerlink" title="Shardctrler"></a>Shardctrler</h3><p>是集群中的协调者, 他负责调整Shard在集群间的分配, 以及集群路由的查询工作.</p><p>扩容: 新加入了一组服务器Group3, 需要将针对某个Shard的历史数据和后续的读写请求由Group1交给Group3负责以扩容集群.</p><p>缩容: 需要下线Group3, 需要将Group3负责的Shard历史数据和后续读写请求交给其他Group负责.扩缩容操作后需要保证Group间的负载均衡</p><p>路由查询: 假设Client 需要 Put(key:”name”, value: “L” ), “name”这个key存储在Shard1上. 需要Client根据从ShardMaster获取到的配置来确认向哪个Group发起写请求.</p><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>由ShardCtrler维护, 客户端和ShardServer拉取的配置, 其中包括的所有服务器分组地址以及集群路由信息. 每次集群动作的变更都会引起Config Version的更新.</p><p>每个组的服务器的配置信息以及每个分片到组的对应关系，以及每个group包含的server，称为配置。配置都保存在服务器中，每次对配置进行修改操作，最新的配置会复制一份副本，然后修改，然后被追加到原本的配置集合中。同时配置号加一。</p><h3 id="Recoverable"><a href="#Recoverable" class="headerlink" title="Recoverable"></a>Recoverable</h3><p>快照和Raft中的状态要及时落盘,每一台服务器都要能够在故障后重启恢复</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>需要能立刻读到之前完成的写请求(这个需要每次读请求向全体发起心跳，得到响应后发现自己仍然还是leader，或者使用租约)</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Shard在Group间的分布要尽可能均衡, 可以通过一致性哈希或者其他方法来实现</p><h2 id="multiRaft"><a href="#multiRaft" class="headerlink" title="multiRaft"></a>multiRaft</h2><p>我们使用 Raft 一致性算法来确保在机器发生故障时数据也能保持一致。在大多数使用 Raft 的系统中，如 etcd 和 Consul，整个系统只有一个 Raft 共识组。然而，在 CockroachDB 中，数据被分成不同的范围，每个范围都有自己的共识组。这意味着每个节点都可能参与成千上万个共识组。这就提出了一些独特的挑战，我们通过在 Raft 之上引入一层 MultiRaft 来解决这些问题。</p><p>简单来说，MultiRaft 是在整个系统中，把所管理的数据按照一定的方式切片，每一个切片的数据都有自己的副本，这些副本之间的数据使用 Raft 来保证数据的一致性，在全局来看整个系统中同时存在多个 Raft-Group<br>单个 Raft-Group 在 KV 的场景下存在一些弊端:</p><p>(1) 系统的存储容量受制于单机的存储容量（使用分布式存储除外）。</p><p>(2) 系统的性能受制于单机的性能（读写请求都由Leader节点处理）。</p><p>MultiRaft 需要解决的一些核心问题：</p><p>(1) 数据何如分片。</p><p>(2) 分片中的数据越来越大，需要分裂产生更多的分片，组成更多 Raft-Group。</p><p>(3) 分片的调度，让负载在系统中更平均（分片副本的迁移，补全，Leader 切换等等）。</p><p>(4) 一个节点上，所有的 Raft-Group 复用链接（否则 Raft 副本之间两两建链，链接爆炸了）。</p><p>(5) 如何处理 stale 的请求（例如 Proposal 和 Apply 的时候，当前的副本不是 Leader、分裂了、被销毁了等等）。</p><p>(6) Snapshot 如何管理（限制Snapshot，避免带宽、CPU、IO资源被过度占用）。</p><h1 id="lab4a-实现过程和lab3很像"><a href="#lab4a-实现过程和lab3很像" class="headerlink" title="lab4a(实现过程和lab3很像):"></a>lab4a(实现过程和lab3很像):</h1><p>Shard ctrler负责管理所有的组，决定每个组负责存储哪些分片，以及响应用户对组的增加（Join）、删除（Leave）、移动（Move）和查询（Query）操作。与Lab 3中实现的简易分布式Key-Value存储系统类似，Shard Ctrler同样分为服务器和客户端。其框架与Lab 3完全相同，区别仅在需要处理的请求的语义不同。Lab 3中需要处理Get、Put以及Append，本节则处理Join、Leave、Move和Query操作。</p><p>每个组的服务器配置信息以及分片到组的对应关系，称为配置（config）。历史上的所有配置均保留在服务器中，每次对配置进行修改操作（即Join、Leave以及Move操作）时，最新的配置会被复制一份，然后再进行修改，同时其序号（Num）增加一。用户可以通过Query查询最新配置，或历史上某一个特定配置。</p><p>shardctrler负责管理这些group，决定每个组存储哪些分片，响应用户对组的join（增加），删除（leave），移动（shard move）和查询（config query）。</p><p>这个客户的程序就是，对于已知的server，不断循环去遍历请求(query,move,join,leave)<br>如果对方不是leader或者返回不对，就休息一段时间，选下一个机器，<br>其中msgid是随机生成的，ckid也是随机生成的</p><h2 id="RPC处理"><a href="#RPC处理" class="headerlink" title="RPC处理"></a>RPC处理</h2><p>服务端收到来自客户端的RPC之后就交给下层的raft进行处理（这里要判断是不是leader），然后准备一个消息接受的管道，接受来自消息完成的通知，然后返回给客户端，如果超时就返回超时信息。（每次处理完要注意删除管道）</p><h2 id="监听raft状态机提交的信息"><a href="#监听raft状态机提交的信息" class="headerlink" title="监听raft状态机提交的信息"></a>监听raft状态机提交的信息</h2><p>每次完成之后监听raft状态机的信息，这里要去重，然后和lab3的区别主要是Op的不同，主要分为leave，query，move，join，每次执行对应的函数</p><p>具体实现为：</p><p>join操作，参数为一系列的组的配置信息，首先复制一个新的配置副本，然后新增配置号，然后将组的配置添加到配置副本中，然后进行重平衡算法。</p><p>Leave操作，参数是一些组的编号，首先复制一个新的配置副本，然后新增配置号，然后将配置中这些组删除，将属于这些组的分片暂时设置为0，然后进行重平衡算法。执行完该操作后，服务器要求至少剩余一个组。</p><p>move操作，参数是移动的分片和目标的组，首先复制一个新的配置副本，然后新增配置号，然后更新目标分片到目标组中，这个接口是为了调试和测试用的</p><p>query操作，查询任意时期的配置，没有指定的函数（query每次都是在底层的raft命令中发现这个命令之后就直接返回对应的config就可以）</p><p>query可以查询最新的配置或者历史上某一个特定的配置。</p><h3 id="重平衡算法"><a href="#重平衡算法" class="headerlink" title="重平衡算法"></a>重平衡算法</h3><p>在对配置进行修改后，每个组存储的分片数量可能会变得不均匀，因此需要进行重平衡。重平衡的目标是使得每个组存储的分片数量变得均匀（数量的最大值与最小值之差别太大），并且重新达到平衡的过程中被移动的分片的数量最少。</p><p>对于配置，如果只有一个group，肯定所有的shard都在这上面。</p><p>对于配置，如果只有0个group，此时什么都没有，shard也应该为空</p><p>如果shard的数目大于group的数目，那么求出每个group平均分配的最小数目，以及剩余的余数数目，</p><p>此时分四种情况讨论，<br>如果group的shard和avg一样，continue，</p><p>如果group的shard大于avg，并且remain=0，将多于avg的shard的group置为0，小于的补上</p><p>如果group的shard大于avg，并且remain&gt;0，将多于avg+remain的shard的group置为0，<br>如果group的shard小于avg，从group为0的那些shard选一些补到avg，如果还不足avg，还需要循环一次,因为此时的有可能其他分片还没有空出来<br>这个最严重的情况下，会导致某一个group最大为avg+remain</p><p>如果shard_num&lt;group_num,那么就把多于一个shard的group的多的shard拿出来，<br>shard还没选group的拿出来分别分配到一个都没有的group中。</p><p>这个重平衡算法的优点在于移动次数比较少，但是最坏情况可能最大最小差距为avg,reamin的shard都在一个机器上</p><p>这个重平衡算法还有可以优化的地方，</p><p>还有一种平衡机制是这样的，这种会更平衡一些，</p><p>对于一个配置，重平衡算法首先通过分片到组的对应关系计算出每个组存储的分片的列表，然后将这些组按照其存储的分片数量从大到小排序。为了确保Shard Master所有服务器执行相同的操作，当某两个组的分片数量一致时，编号更小的组排在更前。排序后，算法计算每个组平衡后应当存储的分片数量。假设共有ngroups个组，nshards个分片，那么前nshards % ngroups个组存储nshards / ngroups + 1个分片，剩下的组存储nshards / ngroups个分片。接着算法遍历每个组，将分片数量多于预期的组的多余分片取出并统一暂存。最后，算法遍历每个组，将暂存的多余分片分配至分片数量少于预期的组。算法总计需要一次对组的排序、两次对组的遍历以及其中的分片复制操作，总体时间复杂度为O(ngroups * log(ngroups) + nshards)。</p><h3 id="运行的流程："><a href="#运行的流程：" class="headerlink" title="运行的流程："></a>运行的流程：</h3><p>当客户端发起group的加入，离开，移动，或者查询任意配置的时候，<br>server执行join（例如）函数，然后执行runcmd函数（在这里将加入reqId，随机值）<br>然后执行waitcmd函数，交给底层的raft提交日志，如果非leader，或者超时，返回，如果没有这些问题，就等待收到的回复，这个回复是这样的流程（当server收到raft的信息的时候，同时处理完相关的函数，然后向msgnotify返回信息），当收到返回的msgnotify信息的时候，删除通道的数据，返回rpc对应的结果</p><p>即服务端两个线，一条是RPC接收到客户端信息的时候，交给底层的raft日志处理不断监听结果，同时一方面，一个apply不断从raft applymsg信息中查看是否达成一致性，是就进行处理返回msgnotify结果信息。<br>实现总体架构和lab3类似，分为客户端和服务端，每次客户端向服务端发送请求，如果不是leader就换server重试，然后道）。同时客户端还有一个</p><h1 id="lab4b："><a href="#lab4b：" class="headerlink" title="lab4b："></a>lab4b：</h1><h2 id="lab4b的challenge"><a href="#lab4b的challenge" class="headerlink" title="lab4b的challenge"></a>lab4b的challenge</h2><p>背景: Group1 在 V1 负责 Shard0, Shard1 的读写, 但是在 V2 后 Shard0 由 Group2 负责读写请求, 需要Group1 将Shard0 的历史数据安全的发送给Group2.所有时间必须保持线性一致性.</p><p>需要进行针对Shard的Garbage Collection, Group1在迁移Shard0 结束后及时的清理掉Shard0以释放空间.</p><p>Group1 在升级到 V2后, 仍负责Shard1的读写请求, 所以迁移Shard0的过程不能影响Shard1的读写请求</p><p>一开始客户端尝试旧的group，如果收到wrongGroup回复，那么就查询新配置，再查询。<br>服务器中如果这个shard是自己管理的，同时需要这个shardversion和本地的配置号是一样的，因为如果不一样说明肯定正在传输，这个时候返回InTransit错误，</p><h2 id="一些设计思想："><a href="#一些设计思想：" class="headerlink" title="一些设计思想："></a>一些设计思想：</h2><p>本节的核心设计思想为，服务器存储的分片可以分为实际存储数据的分片和不实际存储数据的分片引用(即正在传输)。分片引用存储该分片实际数据的来源（配置序号以及分片编号），表示服务器正在等待其他组的服务器将此分片迁移至当前服务器。这一设计允许服务器将配置更新与分片迁移操作分离，配置更新时仅需快速更新分片引用，而分片数据则可以后续独立传送。一旦某一分片数据传送（迁移）完成，服务器可立即开始处理对该分片的请求，而无需等待其他正在传送的分片数据（对应TestChallenge2Unaffected及TestChallenge2Partial）。</p><p>在实际的生产系统中，不同 raft 组的成员可能存在于一个物理节点上，而且一般情况下都是一个物理节点拥有一个状态机(一批数据)，不同 raft 组使用不同地命名空间或前缀来操作同一个状态机。<br>系统的运行方式：一开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。</p><p>对于集群内部，我们需要保证所有分片能够较为均匀的分配在所有 raft 组上，还需要能够支持动态迁移和容错。</p><p>对于集群外部，我们需要向用户保证整个集群表现的像一个永远不会挂的单节点 KV 服务一样，即具有线性一致性。</p><p>所有涉及修改集群分片状态的操作都应该通过 raft 日志的方式去提交，这样才可以保证同一 raft 组内的所有分片数据和状态一致。</p><p>数据迁移的实现为 pull 还是 push？这里实现成了 pull 的方式。</p><p>在 6.824 的框架下，涉及状态的操作都需要 leader 去执行才能保持正确性，否则需要添加一些额外的同步措施，而这显然不是 6.824 所推荐的。因此配置更新，分片迁移，分片清理和空日志检测等逻辑都只能由 leader 去检测并执行。</p><p>首先，每个 raft 组的 leader 需要有一个协程去向 shardctrler 定时拉取最新配置，一旦拉取到就需要提交到该 raft 组中以更新配置。此外，为了防止集群的分片状态被覆盖，从而使得某些任务永远被丢弃，因此一旦存在某一分片的状态不是默认状态，配置更新协程就会停止获取和提交新配置直至所有分片的状态都为默认状态为止。</p><h2 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a>客户端：</h2><p>与lab3类似，客户端的seqNum初始化为0，然后每次递增，保证命令号不重复，put 或者append或者get</p><p>每次请求，对于每个key，获取它所处的shard，对于shard的第一个字符转成正整数然后对分片的个数取模得到shard号码，然后从config中找到负责这个shard的group，对其的每个server，进行请求，</p><p> 如果成功，或者没有这个key，返回reply，如果group错误或者正在传输中，退出对这个group的请求，过一会再次查配置对group上的server进行请求。</p><p>同时每隔一段时间向ctrler节点查询最新配置</p><h2 id="RPC请求"><a href="#RPC请求" class="headerlink" title="RPC请求"></a>RPC请求</h2><h3 id="PullShard"><a href="#PullShard" class="headerlink" title="PullShard:"></a>PullShard:</h3><p>如果对方想拉shard，同时我的配置号比他的更新，就把shard给他，否则返回false</p><h3 id="DeleteShard："><a href="#DeleteShard：" class="headerlink" title="DeleteShard："></a>DeleteShard：</h3><p>如果我的对应的shard的配置号比RPC参数发过来的配置号更旧，说明确实可以删除，<br>那么就向底层的raft写入同步删除shard的命令DeleteShardOp，（需要判断是否为leader），并且等待reschan对应命令的管道信息，如果不是正在传输的状态，reply的结果那么就为success，超时或者其他情况返回reply false</p><h3 id="get"><a href="#get" class="headerlink" title="get:"></a>get:</h3><p>应对客户端发起的get请求，先交给底层的raft进行处理，然后等待reschan通道结果，这里的实现和lab3和lab4a的实现基本一样，主要区别在于返回的错误种类更多，可能是正在传输，可能是group错误。</p><h3 id="PutAppend"><a href="#PutAppend" class="headerlink" title="PutAppend"></a>PutAppend</h3><p>应对客户端发起的putappend请求，先交给底层的raft进行处理，然后等待reschan通道结果，</p><h2 id="pollconfig协程"><a href="#pollconfig协程" class="headerlink" title="pollconfig协程"></a>pollconfig协程</h2><p>服务端自己每隔一定时间会发起拉取配置的请求（pollconfig），如果发现有新配置（每次配置号加一查新配置），说明我们应该更新配置了，这个时候如果还有pullmap需要拉取或者删除就等下更新，如果有原来是这个group的shard，现在的配置号变了，也暂时不更新。否则就向底层raft写入更新配置（shardConfigOp）的命令。</p><h2 id="pollshard协程"><a href="#pollshard协程" class="headerlink" title="pollshard协程"></a>pollshard协程</h2><p>服务端每隔一段时间会处理拉取shard的命令（pollshard）（处理pullmap），然后如果发现pullmap的valid是true（需要拉取shard）发起pullshard RPC，返回的reply如果成功，就向raft写入PullShardOp的命令</p><h2 id="applyDb协程"><a href="#applyDb协程" class="headerlink" title="applyDb协程"></a>applyDb协程</h2><p>一个不断获取底层raft的状态机的信息，如果为快照的命令，那么就读取快照信息<br>如果不是那么就看日志的command是哪种命令，</p><h3 id="ShardConfigOp"><a href="#ShardConfigOp" class="headerlink" title="ShardConfigOp"></a>ShardConfigOp</h3><p>这个时候说明我们已经拿到新配置了，然后这个时候也表明在raft group中完成共识了，这个时候就具体更新配置，如果原来就是这个group的shard就只更新shard配置号，原来不是这个group的shard的，就添加需要pullmap的信息，后续进行拉取。同时正式更新配置。</p><h3 id="PullShardOp命令"><a href="#PullShardOp命令" class="headerlink" title="PullShardOp命令"></a>PullShardOp命令</h3><p>（PullShardOp这里必须要求op.ver是当前配置号减一，为什么是这样呢，因为正常操作就是我们config更新了，然后配置号加一，然后拉取配置）</p><p>这个时候说明我们已经拿到shard了，然后这个时候也表明在raft group中完成共识了，这个时候就是具体更新内容的时候了，更新了对应shard的kvdb即（存储信息），以及clientseqNum,并且将kv.pullMap的valid设置为false（表明已经拉取好了shard）（因为这里就是说组把一个shard交给了另外一个组，所以需要删除），同时更新对应分片的shardsVerNum</p><h3 id="DeleteShardOp"><a href="#DeleteShardOp" class="headerlink" title="DeleteShardOp"></a>DeleteShardOp</h3><p>这个时候说明可以删除，这个时候也表明在raft group中完成共识了，这个时候就是具体删除内容的时候了，如果是删除shard的命令DeleteShardOp，如果请求我们删除的配置号不比我们旧，删除shard和clientseqnum，否则不删除（可能正在传输中），这里要返回reschan结果</p><h3 id="RemovePullMapOp"><a href="#RemovePullMapOp" class="headerlink" title="RemovePullMapOp"></a>RemovePullMapOp</h3><p>如果是删除pullmap的命令RemovePullMapOp，那么就删除对应的pullmap</p><h3 id="get-put-append"><a href="#get-put-append" class="headerlink" title="get,put,append"></a>get,put,append</h3><p>在执行Get、Put以及Append时，服务器会首先检查请求的Key对应的分片在当前配置下是否由本服务器负责，若不由本服务器负责，则直接返回组错误响应。若确实由本服务器负责，则若shard的版本号与kv的配置号不一样，说明正在传输，返回正在传输的结果，如果一致，在对应的数据库中更新，返回reschan结果。</p><h2 id="思路详解"><a href="#思路详解" class="headerlink" title="思路详解"></a>思路详解</h2><p>定时拉取配置，整体的过程是pollConfig会定时调用写raft命令，然后再applyDb中达成一致后具体应用</p><p>定时拉取shard的会定时检查pullmap需要拉取的，如果需要就调用pullshardRPC，然后写入拉取shard的命令</p><p>如果pullmap拉取完了说明对方需要删除，那么就调用deleteShardRPC，在对应raft写入删除shard的命令</p><p>如果deleteshardRPC删除成功需要写入删除pullmap的命令</p><p>apply针对达成一致性的命令进行处理，这里处理的时候需要注意去重，以及修改pullmap，以及可能正在传输。</p><p>发现有新配置（每次配置号加一查新配置），必须保证上次的配置更新好才能更新下次的（即pullmap为空）</p><p>PullShardRPC中只需要config号更大或者一样，就可以把shard给对方，同时还要给shardVersion号，而且在raft达成一致性之后需要check这个shardversion是否刚好为当前的config号减一，</p><p>deleteShardRPC需要本地的shardversion号小于等于对方的config号</p><p>并且raft达成一致性之后需要shard的config号小于等于执行op的配置号（对方的请求RPC的配置号）</p><p>这里当配置是旧配置的时候一定是访问到的之前的group，此时如果配置更新了，说明正在传输配置给新group，或者要删除这个shard，这个时候这个shard的服务就暂停了，让客户端更新一下配置。然后访问新的group，如果我还是旧配置是可以提供服务的。</p><h2 id="正在传输的情况有哪几种？"><a href="#正在传输的情况有哪几种？" class="headerlink" title="正在传输的情况有哪几种？"></a>正在传输的情况有哪几种？</h2><p>Get、put、append中有可能，只要配置号不一样不是默认的情况就是正在传输</p><h2 id="challenge的服务"><a href="#challenge的服务" class="headerlink" title="challenge的服务"></a>challenge的服务</h2><p>1.当副本组失去碎片的所有权时，该副本组应消除其数据库中丢失的键。它是浪费的，以保持它不再拥有的价值，不再为请求提供服务。但是，这会给迁移带来一些问题。假设我们有两个组，G1和G2，并且有一个新的配置C，它将Shard S从G1移动到G2。如果G1从其数据库中擦除S中的所有键，当它转换为C时，G2如何在尝试移动到C时获得数据？</p><p>这个使用deleteshard 和deletepullmap来提供，当pullshard完成之后，会标记pullmap迁移完成，发现迁移完成接收者会发起deleteshardRPC请求，使其删除这个shard，当删除shardRPC完成之后就写入deletepullmap的操作，达成一致性后删除pullmap。</p><p>2.当配置迁移的时候，不是迁移的分片应该可以提供服务。</p><p>在迁移配置的时候，即使配置更新正在迁移，但是旧的shard的的group是可以提供服务的，这里我们可以看如果这个时候都是旧的配置，那么说明还没更新配置，那么shardversion和config号是一样的，如果更新了配置，那么都是新配置，也都是一致的，是可以提供服务的。</p><p>3.虽然上面的优化是好的，但我们仍然可以做得更好。例如，在转换到C时，一些副本组G3需要从G1的碎片S1，并且来自G2的碎片S2。我们真的希望G3立即开始在收到必要的状态后开始提供碎片，即使它仍在等待其他一些碎片。例如，如果G1关闭，G3仍应开始在从G2接收到G2的适当数据后为S2服务的请求，尽管过渡到尚未完成。</p><p>当收到一部分的分片的时候，客户端查询新的配置，发现shardversioon号和config号是一致的，都是新的号，可以提供服务。</p><h1 id="加锁的情况"><a href="#加锁的情况" class="headerlink" title="加锁的情况"></a>加锁的情况</h1><p>规则 1：当您有多个 goroutine 使用的数据，并且至少有一个 goroutine 可能会修改数据时，goroutine 应该使用锁来防止同时使用数据。Go race 检测器非常擅长检测违反此规则的情况（尽管它对下面的任何规则都没有帮助）比如修改任期啥的</p><p>规则 2：每当代码对共享数据进行一系列修改时，如果其他 goroutine 查看 sequence 中间的某个数据，则可能会出现故障，您应该对整个 sequence 临界区使用锁。</p><p>规则 3：每当代码执行一系列共享数据读取（或读写）时，如果另一个 goroutine 在该 sequence 中途修改数据了，则会出现故障，您应该在整个 sequence 使用锁。</p><p>规则 4：在执行任何可能等待的操作时保持锁定通常不是一个好主意：读取 channel、发送 channel、等待 timer、调用 time.sleep () 或发送 RPC (并等待回复)。其中一个原因是，可能希望其他 goroutine 在等待期间能够继续执行代码。另一个原因是避免死锁。设想两个 peer 在持有锁的同时相互发送 RPC；两个 RPC 处理程序都需要接收 peer 的锁；两个 RPC 处理程序都无法完成，因为它需要等待的 RPC 调用持有的锁。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mit6.824 lab实现</title>
    <link href="/2022/04/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B0%E5%BB%BA%20MD_AUTO_FILE%20%E6%96%87%E4%BB%B6/"/>
    <url>/2022/04/05/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%96%B0%E5%BB%BA%20MD_AUTO_FILE%20%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p>首先是选举，raft必须保证大部分机器可用。</p><p>以下是一些raft的基础的内容，三种角色，leader，candidate，follower。</p><h2 id="follower"><a href="#follower" class="headerlink" title="follower"></a>follower</h2><p>对于每个机器，一开始是follower，然后每隔一段时间如果没有收到Leader的心跳，那么任期+1，变为candidate，投票给自己，然后启动新的协程发起选举（如果在这过程中任期被改变或者role被改变（？？需不需要变为leader），那么选举结束），向其他的机器发送RPC，请求它们投票。</p><p>如果收到的reply的任期比我更大，那么转变为follower，更新任期。（需要保存磁盘）</p><p>如果收到投票给我的结果，并且我还是candidate，那么直接票数+1，超过半数的票，变为leader，并且初始化nextIndex为最后一条日志的索引值+1（代表下一条需要复制给server的日志索引，索引0代表快照）（需要保存磁盘）</p><h2 id="requestVoteRPC实现"><a href="#requestVoteRPC实现" class="headerlink" title="requestVoteRPC实现"></a>requestVoteRPC实现</h2><p>如果当收到来自其他server的选举请求的时候，如果对方任期更旧直接拒绝投票。</p><p>如果任期更新，那么更新自己的任期，并且转变为follower。（需要保存磁盘）</p><p>如果我的日志更新（比较日志任期和索引）那么也拒绝投票。</p><p>如果我的日志没有更新，同时我还没投票或者已经投了它（说明之前返回的RPC丢失了），那么投票给他，更新任期，刷新心跳（保存磁盘）</p><p>否则（说明已经投了别人），拒绝投票。</p><h2 id="leader"><a href="#leader" class="headerlink" title="leader"></a>leader</h2><p>leader每隔一段时间sleep之后开始处理事务，<br>查看nextIndex中的日志，如果index比leader快照的日志还旧，就发起InstallSnapshotRPC请求。</p><h3 id="1-应对InstallSnapshotRPC请求的回复"><a href="#1-应对InstallSnapshotRPC请求的回复" class="headerlink" title="1.应对InstallSnapshotRPC请求的回复"></a>1.应对InstallSnapshotRPC请求的回复</h3><p>如果对方任期更新，那么更新任期，转为follower，然后（保存磁盘），否则更新nextIndex为快照的最后一条日志号+1.</p><h3 id="1-1-InstallSnapshotRPC请求"><a href="#1-1-InstallSnapshotRPC请求" class="headerlink" title="1.1 InstallSnapshotRPC请求"></a>1.1 InstallSnapshotRPC请求</h3><p>当收到来自leader 的安装快照RPC的时候，首先肯定检查任期，任期太旧直接拒绝然后回复，然后变为follower（防止此时为candidate）。如果我的快照比leader发来的快照更新，那么就直接返回，不需要安装。否则，把对应的leader发来的快照以及我比leader快照更新的信息，打包到一起变为server的log，然后应用leader快照到状态机，然后更新commitIndex,快照数据（保存到磁盘）。</p><h3 id="2-应对AppendEntriesRPC请求的回复"><a href="#2-应对AppendEntriesRPC请求的回复" class="headerlink" title="2.应对AppendEntriesRPC请求的回复"></a>2.应对AppendEntriesRPC请求的回复</h3><p>否则就发送日志和心跳，这个时候要把从nextIndex到自己日志的最后一条日志复制给对方，然后附加自己，commitIndex（已经提交的索引号），之前已经已经发送的最后一条日志的索引和任期，以及自己的任期。发起AppendEntriesRPC请求</p><p>如果收到AppendEntriesRPC回复，如果对方拒绝，如果是因为对方的任期更新，那么更新任期，变为follower（需要保存磁盘），如果是因为日志号冲突了，那么更新自己的nextIndex（需要保存磁盘），然后返回。</p><p>如果复制的日志太老了早就复制过了，那么直接返回</p><p>如果没有，那么更新nextindex，matchIndex(每个服务器已经复制的最高索引),</p><p>（检查已经提交的日志索引如果大于等于已经复制到其他的服务器的索引，直接返回（这个时候说明已经提交了，后面再做没有必要））</p><p>（检查fig8的情况，如果复制的日志的任期和当前的任期不一致，那么不能提交，直接返回（后面也没必要了））</p><p>对于每个server，如果已经复制的日志索引（matchIndex）已经大于想要提交的日志索引,那么计数值+1，如果超过半数，那么就直接提交，应用到状态机，更新已经提交的索引号（需要保存磁盘）。</p><h3 id="2-1AppendEntriesRPC请求"><a href="#2-1AppendEntriesRPC请求" class="headerlink" title="2.1AppendEntriesRPC请求"></a>2.1AppendEntriesRPC请求</h3><p>首先肯定检查任期，如果leader的任期太旧，直接拒绝。否则，先转变为follower，更新任期，刷新心跳。</p><p>如果leader已经发送的最后一条日志索引比server的快照的最后一条还旧，说明发来的日志有一部分是重复的，直接返回。</p><p>如果leader已经发送的最后一条日志记录和server的冲突了，同时leader的lastcopyindex大于快照日志索引小于server最大的日志索引直接回退到这个任期的第一条日志（说明下一次leader从这个任期的第一条开始发）。如果同时leader的lastcopyindex大于server最大的日志索引，那么直接返回快照的最大索引+1。然后返回结果。</p><p>前面保证了lastcopyIndex在lastSnapshotIndex与lastLogIndex之间，然后追加日志（如果追加的日志比lastLogIndex小就不用追加）。</p><p>从那么从server发过来的commitIndex到leader的commitindex，应用到状态机。</p><h2 id="Go-语言在这里的特性，Goroutine"><a href="#Go-语言在这里的特性，Goroutine" class="headerlink" title="Go 语言在这里的特性，Goroutine"></a>Go 语言在这里的特性，Goroutine</h2><p>这个的用法在于比如说一开始每次机器都会有两个协程不断循环检查自己是follower，以及是leader的情况</p><p>follower：当发现leader给自己的心跳超时的时候，就开启协程开始选举，在这个协程开启n个协程来请求其他的机器给自己投票，每个请求投票的协程依据情况处理。</p><p>leader：每次经过一定的时间，对于每一个follower的机器，发现follower的机器太旧的时候，就启动一个发送快照的协程来处理，否则启动一个发送心跳和日志的协程来处理。</p><h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><p>Gob的小问题<br>Gob这个包序列化数据的时候，需要知道具体的类型，才可以将它正确的反序列化回来。我们在Start()中传入的参数是interface{}类型，所以如果不进行一些预先的安排，那么在follower中不能将OpArgs反序列出来。所以在StartKVServer()中需要调用gob.Register来注册一下</p><p>只有leader可以处理客户端的请求，如果其他角色接收到了请求，会重定向到leader。</p><h1 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h1><h3 id="Shard"><a href="#Shard" class="headerlink" title="Shard"></a>Shard</h3><p>把所有数据按照Key Hash然后取模10,把数据切分成10片.每一片称为一个Shard, 其中包括一组键值对</p><h3 id="ShardServer-Group"><a href="#ShardServer-Group" class="headerlink" title="ShardServer (Group)"></a>ShardServer (Group)</h3><p>每个Group都是一个Raft集群, 通过Raft保证这组服务器上的数据一致性. 一组服务器负责几个Shard的读写请求.整个集群由N个Group组成</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>客户端, 发起读写请求.</p><h3 id="Shardctrler"><a href="#Shardctrler" class="headerlink" title="Shardctrler"></a>Shardctrler</h3><p>是集群中的协调者, 他负责调整Shard在集群间的分配, 以及集群路由的查询工作.</p><p>扩容: 新加入了一组服务器Group3, 需要将针对某个Shard的历史数据和后续的读写请求由Group1交给Group3负责以扩容集群.</p><p>缩容: 需要下线Group3, 需要将Group3负责的Shard历史数据和后续读写请求交给其他Group负责.扩缩容操作后需要保证Group间的负载均衡</p><p>路由查询: 假设Client 需要 Put(key:”name”, value: “L” ), “name”这个key存储在Shard1上. 需要Client根据从ShardMaster获取到的配置来确认向哪个Group发起写请求.</p><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>由ShardMaster维护, 客户端和ShardServer拉取的配置, 其中包括的所有服务器分组地址以及集群路由信息. 每次集群动作的变更都会引起Config Version的更新.</p><h3 id="Recoverable"><a href="#Recoverable" class="headerlink" title="Recoverable"></a>Recoverable</h3><p>快照和Raft中的状态要及时落盘,每一台服务器都要能够在故障后重启恢复</p><h3 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h3><p>需要能立刻读到之前完成的写请求(这个需要每次读请求向全体发起心跳，得到响应后发现自己仍然还是leader，或者使用租约)</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Shard在Group间的分布要尽可能均衡, 可以通过一致性哈希或者其他方法来实现</p><h2 id="multiRaft"><a href="#multiRaft" class="headerlink" title="multiRaft"></a>multiRaft</h2><p>我们使用 Raft 一致性算法来确保在机器发生故障时数据也能保持一致。在大多数使用 Raft 的系统中，如 etcd 和 Consul，整个系统只有一个 Raft 共识组。然而，在 CockroachDB 中，数据被分成不同的范围，每个范围都有自己的共识组。这意味着每个节点都可能参与成千上万个共识组。这就提出了一些独特的挑战，我们通过在 Raft 之上引入一层 MultiRaft 来解决这些问题。</p><p>简单来说，MultiRaft 是在整个系统中，把所管理的数据按照一定的方式切片，每一个切片的数据都有自己的副本，这些副本之间的数据使用 Raft 来保证数据的一致性，在全局来看整个系统中同时存在多个 Raft-Group<br>单个 Raft-Group 在 KV 的场景下存在一些弊端:</p><p>(1) 系统的存储容量受制于单机的存储容量（使用分布式存储除外）。</p><p>(2) 系统的性能受制于单机的性能（读写请求都由Leader节点处理）。</p><p>MultiRaft 需要解决的一些核心问题：</p><p>(1) 数据何如分片。</p><p>(2) 分片中的数据越来越大，需要分裂产生更多的分片，组成更多 Raft-Group。</p><p>(3) 分片的调度，让负载在系统中更平均（分片副本的迁移，补全，Leader 切换等等）。</p><p>(4) 一个节点上，所有的 Raft-Group 复用链接（否则 Raft 副本之间两两建链，链接爆炸了）。</p><p>(5) 如何处理 stale 的请求（例如 Proposal 和 Apply 的时候，当前的副本不是 Leader、分裂了、被销毁了等等）。</p><p>(6) Snapshot 如何管理（限制Snapshot，避免带宽、CPU、IO资源被过度占用）。</p><h2 id="Lab-4A-and-4b-ShardCtrler"><a href="#Lab-4A-and-4b-ShardCtrler" class="headerlink" title="Lab 4A and 4b(ShardCtrler)"></a>Lab 4A and 4b(ShardCtrler)</h2><p>Shard Master负责管理所有的组，决定每个组负责存储哪些分片，以及响应用户对组的增加（Join）、删除（Leave）、移动（Move）和查询（Query）操作。与Lab 3中实现的简易分布式Key-Value存储系统类似，Shard Master同样分为服务器和客户端。其框架与Lab 3完全相同，区别仅在需要处理的请求的语义不同。Lab 3中需要处理Get、Put以及Append，本节则处理Join、Leave、Move和Query操作。</p><p>每个组的服务器配置信息以及分片到组的对应关系，称为配置（config）。历史上的所有配置均保留在服务器中，每次对配置进行修改操作（即Join、Leave以及Move操作）时，最新的配置会被复制一份，然后再进行修改，同时其序号（Num）增加一。用户可以通过Query查询最新配置，或历史上某一个特定配置。上述修改操作具体实现为：</p><p>在实际的生产系统中，不同 raft 组的成员可能存在于一个物理节点上，而且一般情况下都是一个物理节点拥有一个状态机，不同 raft 组使用不同地命名空间或前缀来操作同一个状态机。<br>系统的运行方式：一开始系统会创建一个 shardctrler 组来负责配置更新，分片分配等任务，接着系统会创建多个 raft 组来承载所有分片的读写任务。此外，raft 组增删，节点宕机，节点重启，网络分区等各种情况都可能会出现。</p><p>对于集群内部，我们需要保证所有分片能够较为均匀的分配在所有 raft 组上，还需要能够支持动态迁移和容错。</p><p>对于集群外部，我们需要向用户保证整个集群表现的像一个永远不会挂的单节点 KV 服务一样，即具有线性一致性。</p><p>所有涉及修改集群分片状态的操作都应该通过 raft 日志的方式去提交，这样才可以保证同一 raft 组内的所有分片数据和状态一致。<br>在 6.824 的框架下，涉及状态的操作都需要 leader 去执行才能保持正确性，否则需要添加一些额外的同步措施，而这显然不是 6.824 所推荐的。因此配置更新，分片迁移，分片清理和空日志检测等逻辑都只能由 leader 去检测并执行。<br>数据迁移的实现为 pull 还是 push？其实都可以，个人感觉难度差不多，这里实现成了 pull 的方式。</p><p>首先，每个 raft 组的 leader 需要有一个协程去向 shardctrler 定时拉取最新配置，一旦拉取到就需要提交到该 raft 组中以更新配置。此外，为了防止集群的分片状态被覆盖，从而使得某些任务永远被丢弃，因此一旦存在某一分片的状态不是默认状态，配置更新协程就会停止获取和提交新配置直至所有分片的状态都为默认状态为止。</p><p>lab4是基于lab2实现的基于raft协议的分片的key-value存储，主要包括ctrler节点和分片的group的服务端，还有客户端。</p><h1 id="lab4a"><a href="#lab4a" class="headerlink" title="lab4a:"></a>lab4a:</h1><p>shardctrler负责管理这些group，决定每个组存储哪些分片，响应用户对组的join（增加），删除（leave），移动（shard move）和查询（config query）。</p><p>实现总体架构和lab3类似，分为客户端和服务端，然后服务端对底层的raft完成一致性的命令进行处理，客户端每次不断请求服务。</p><p>每个组的服务器的配置信息以及每个分片到组的对应关系，以及每个group包含的server，称为配置。配置都保存在服务器中，每次对配置进行修改操作，最新的配置会复制一份副本，然后修改，然后被追加到原本的配置集合中。同时配置号加一。</p><p>query可以查询最新的配置或者历史上某一个特定的配置。</p><p>具体实现为：</p><p>join操作，参数为一系列的组的配置信息，首先复制一个新的配置副本，然后新增配置号，然后将组的配置添加到配置副本中，然后进行重平衡算法。</p><p>Leave操作，参数是一些组的编号，首先复制一个新的配置副本，然后新增配置号，然后将配置中这些组删除，将属于这些组的分片暂时设置为0，然后进行重平衡算法。执行完该操作后，服务器要求至少剩余一个组。</p><p>move操作，参数是移动的分片和目标的组，首先复制一个新的配置副本，然后新增配置号，然后更新目标分片到目标组中，这个接口是为了调试和测试用的</p><p>query操作，查询任意时期的配置，没有指定的函数（query每次都是在底层的raft命令中发现这个命令之后就直接返回对应的config就可以）</p><h3 id="重平衡算法"><a href="#重平衡算法" class="headerlink" title="重平衡算法"></a>重平衡算法</h3><p>在对配置进行修改后，每个组存储的分片数量可能会变得不均匀，因此需要进行重平衡。重平衡的目标是使得每个组存储的分片数量变得均匀（数量的最大值与最小值之差别太大），并且重新达到平衡的过程中被移动的分片的数量最少。</p><p>对于配置，如果只有一个group，肯定所有的shard都在这上面。</p><p>对于配置，如果只有0个group，此时什么都没有，shard也应该为空</p><p>如果shard的数目大于group的数目，那么求出每个group平均分配的最小数目，以及剩余的余数数目，</p><p>此时分四种情况讨论，<br>如果group的shard和avg一样，continue，</p><p>如果group的shard大于avg，并且remain=0，将多于avg的shard的group置为0，</p><p>如果group的shard大于avg，并且remain&gt;0，将多于avg+remain的shard的group置为0，<br>如果group的shard小于avg，从group为0的那些shard选一些补到avg，如果还不足avg，还需要循环一次,因为此时的有可能其他分片还没有空出来<br>这个最严重的情况下，会导致某一个group最大为avg+remain</p><p>如果shard_num&lt;group_num,那么就把多于一个shard的group的多的shard拿出来，<br>shard还没选group的拿出来分别分配到一个都没有的group中。</p><p>这个重平衡算法的优点在于移动次数比较少，但是最坏情况可能最大最小差距为avg,reamin的shard都在一个机器上</p><p>这个重平衡算法还有可以优化的地方，</p><p>还有一种平衡机制是这样的，这种会更平衡一些，</p><p>对于一个配置，重平衡算法首先通过分片到组的对应关系计算出每个组存储的分片的列表，然后将这些组按照其存储的分片数量从大到小排序。为了确保Shard Master所有服务器执行相同的操作，当某两个组的分片数量一致时，编号更小的组排在更前。排序后，算法计算每个组平衡后应当存储的分片数量。假设共有ngroups个组，nshards个分片，那么前nshards % ngroups个组存储nshards / ngroups + 1个分片，剩下的组存储nshards / ngroups个分片。接着算法遍历每个组，将分片数量多于预期的组的多余分片取出并统一暂存。最后，算法遍历每个组，将暂存的多余分片分配至分片数量少于预期的组。算法总计需要一次对组的排序、两次对组的遍历以及其中的分片复制操作，总体时间复杂度为O(ngroups * log(ngroups) + nshards)。</p><h2 id="server相关的实现："><a href="#server相关的实现：" class="headerlink" title="server相关的实现："></a>server相关的实现：</h2><p>对于每个server一开始初始化每个元素，然后启动apply协程，这个协程中，不断接收来自raft的状态机管道信息，如果信息中的msg非快照类的，同时这个请求没有重复，<br>没重复就执行join函数，leave函数，move函数，query函数，（这四个函数就相当于上述的操作）同时向msgnotify写入管道信息</p><p>4个RPC函数：<br>这四个最后都是执行waitcmd函数，对于每个命令执行在底层的raft中添加命令，然后等待msgnotify结果<br>根据是否是leader，是否超时，返回对应的msgnotify</p><p>客户端：</p><p>这个客户的程序就是，对于已知的server，不断循环去遍历请求(query,move,join,leave)<br>如果对方不是leader或者返回不对，就休息一段时间，选下一个机器，<br>其中msgid是随机生成的，ckid也是随机生成的</p><p>运行的流程：</p><p>当客户端发起group的加入，离开，移动，或者查询任意配置的时候，<br>server执行join（例如）函数，然后执行runcmd函数（在这里将加入reqId，随机值）<br>然后执行waitcmd函数，交给底层的raft提交日志，如果非leader，或者超时，返回，如果没有这些问题，就等待收到的回复，这个回复是这样的流程（当server收到raft的信息的时候，同时处理完相关的函数，然后向msgnotify返回信息），当收到返回的msgnotify信息的时候，删除通道的数据，返回rpc对应的结果</p><p>即服务端两个线，一条是RPC接收到客户端信息的时候，交给底层的raft日志处理不断监听结果，同时一方面，一个apply不断从raft applymsg信息中查看是否达成一致性，是就进行处理返回msgnotify结果信息。</p><p>lab4b：</p><p>客户端：<br>put 或者append或者get</p><p>每次请求，对于每个key，获取它所处的shard，然后对负责这个shard的group上的每个server，进行请求，<br> 如果成功，或者没有这个key，返回reply，如果group错误或者正在传输中直接退出这一次对这个group的请求，<br>同时每隔一段时间向ctrler节点查询最新配置</p><p>server：</p><p>本节的核心设计思想为，服务器存储的分片可以分为实际存储数据的分片和不实际存储数据的分片引用。分片引用存储该分片实际数据的来源（配置序号以及分片编号），表示服务器正在等待其他组的服务器将此分片迁移至当前服务器。这一设计允许服务器将配置更新与分片迁移操作分离，配置更新时仅需快速更新分片引用，而分片数据则可以后续独立传送。一旦某一分片数据传送（迁移）完成，服务器可立即开始处理对该分片的请求，而无需等待其他正在传送的分片数据（对应TestChallenge2Unaffected及TestChallenge2Partial）。</p><p>一开始启动三个协程</p><p>applydb：</p><p>一个不断获取底层raft的状态机的信息，如果为快照的命令，那么就读取快照信息<br>如果不是那么就看日志的command是哪种命令，</p><p>如果是更新配置的命令，如果原来就是这个group的shard就只更新shard配置号，原来不是这个group的shard的，就添加需要pullmap的信息，后续进行拉取</p><pre><code class="hljs crmsh">分片服务器在启动时会启动一个goroutine负责更新配置，其定期利用Shard <span class="hljs-literal">Master</span>客户端向Shard <span class="hljs-literal">Master</span>轮询最新的配置，并获取当前配置之后的所有新配置。然后，其调用Raft协议的<span class="hljs-literal">Start</span>接口来将分片组服务器当前配置之后的所有新配置逐一加入Raft日志（log）中。当这些日志（新配置）被Raft协议提交（commit）后，便会出现在applyCh。此时，分片组服务器会进行配置更新，配置更新一般会导致每个组负责的分片的情况发生变化，</code></pre><p>如果是拉取shard的命令PullShardOp，实际上更新了对应shard的kvdb即（存储信息），以及clientseqNum,并且将kv.pullMap的valid设置为false（表明已经拉取了shard了），同时更新shardsVerNum</p><p>如果是删除shard的命令DeleteShardOp，如果请求我们删除的配置号不比我们旧，删除shard和clientseqnum，否则不删除（可能正在传输中），返回reschan结果</p><p>如果是删除pullmap的命令RemovePullMapOp，那么就删除对应的pullmap</p><p>如果是get，put，append命令，若shard的版本号与kv的配置号不一样，说明正在传输，返回正在传输的结果，如果一致，在对应的数据库中更新，返回reschan结果</p><p>在执行Get、Put以及Append时，服务器会首先检查请求的Key对应的分片在当前配置下是否由本服务器负责，若不由本服务器负责，则直接返回组错误响应。若确实由本服务器负责，则服务器继续按照规定的语义执行，并产生返回值。其中，若被访问的分片由本服务器负责但尚为引用，服务器不会阻塞，其会返回分片正在传输的响应，期望客户端一段时间后重试。</p><p>pollconfig:</p><p>每隔一段时间就向ctrler节点请求新的配置，如果请求到了新配置，同时如果不需要拉取shard，没有正在传输的config，就向raft添加ShardConfigOp更新配置的命令(表示更新config)</p><p>pollshard:</p><p>每隔一段时间，就对pullmap中的还没拉取的shard进行拉取（此时pullmap valid为true），给出args参数，call RPC进行拉取shard，对于返回的reply，如果成功，<br>向raft写入拉取shard的命令（同时要将给出的reply的参数放入命令中）</p><p>如果（此时pullmap valid为false），说明需要删除，给出args参数，call RPC进行deleteshard，对于返回的reply，如果成功，也向底层raft写入removePullmap(即删除pullmap)的命令</p><p>4个RPC函数：</p><p>对于kvdb相关的RPC:</p><p>PullShard:如果对方想拉shard，同时我的配置号比他的更新，就把shard给他，否则返回false</p><p>DeleteShard：如果我的对应的shard的配置号比RPC参数发过来的配置号更旧，说明确实可以删除，<br>此时让底层的raft进行同步删除shard的命令DeleteShardOp，如果是leader，并且reschan对应命令的管道信息不是正在传输的状态，reply的结果那么就为success，超时或者其他情况返回reply false</p><p>get:<br>应对客户端发起的get请求，先交给底层的raft进行处理，然后等待reschan通道结果</p><p>PutAppend<br>应对客户端发起的putappend请求，先交给底层的raft进行处理，然后等待reschan通道结果，</p><p>这里的流程主要为：</p><p>（每一个kv还记录了每一个shard的版本配置号）</p><p>客户端发起get、put、append，然后服务端的Get，putappend的RPC函数收到后交给底层的raft提交，等待结果，applydbd等待到raft的提交结果之后，就进行kvdb的更新，然后返回结果，然后结束。（这里处理的时候可能会发现shard还在传输，会返回正在传输）</p><p>服务端自己每隔一定时间会发起拉取配置的请求（pollconfig），如果发现有新配置，那么就向底层raft写入更新配置的命令，applydbd等待到raft的提交结果之后，就对这个命令进行处理，原来就是这个group的shard现在还是的就只更新shard配置号，原来不是这个group的shard的，就添加需要pullmap的信息，后续进行拉取，原来是现在不是的暂时不删除</p><p>服务端每隔一段时间会处理拉取shard的命令（pollshard），然后如果发现pullmap的valid是true发起pullshard RPC，返回的reply如果成功，就向raft写入拉取shard的命令，applydbd等待到raft的提交结果之后（PullShardOp）（PullShardOp这里必须要求op.ver是当前配置号减一，为什么是这样呢，因为正常操作就是我们config更新了，然后配置号加一，然后拉取配置），更新信息，然后设置pullmap的valid是false（因为这里就是说组把一个shard交给了另外一个组，所以需要删除）</p><p>如果发现pullmap的valid是false发起deleteshard RPC，在deleteshardRPC中向底层raft写入DeleteShardOp，applydbd等待到raft的提交结果之后，处理结果然后返回（这里可能会发现这个shard已经被更新了，不是原来的shard就返回还在传输），如果返回的这个结果成功，那么再向底层的raft写入removePullmap命令，applydbd等待到raft的提交结果之后，返回结果然后返回。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>effective C++笔记</title>
    <link href="/2022/04/04/C++/effective%20C++%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/04/C++/effective%20C++%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>3.尽可能使用const<br><pre><code class="hljs actionscript">当non-<span class="hljs-keyword">const</span>和<span class="hljs-keyword">const</span>实现相同逻辑时，non-<span class="hljs-keyword">const</span>对象可以调用<span class="hljs-keyword">const</span>成员函数，这样可以缩减代码量。另外注意<span class="hljs-keyword">const</span>对象不能调用non-<span class="hljs-keyword">const</span>成员函数，编译报错：discards qualifiers。</code></pre></p><p>4.确定对象使用前被初始化<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript">　在构造函数的初始化列表中的才算是初始化，而构造函数的内容是在初始化列表之后执行的，已经不算是初始化操作。在初始化列表中进行初始化，调用的是<span class="hljs-built_in">string</span>的拷贝构造函数，而在构造函数中进行赋值的话，调用的是：默认构造函数+赋值函数，调用默认构造的原因是，调用构造函数之前会先对成员进行初始化（这也就是为什么在构造函数中进行的操作不能称之为初始化操作），而对于大多数类，默认构造函数+赋值函数的效率是小于只调用拷贝构造函数的。</code></pre></p><p><span class="hljs-number">1.</span>因此最好是在初始化列表中进行初始化操作。<br>　　<span class="hljs-number">2.</span>内置类型要手动初始化，不同的平台不能保证对内置类型进行初始化&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>5.C++默认编写并调用的函数</p><pre><code class="hljs plain">编译器默认实现的函数：默认构造、析构、拷贝构造、赋值函数。</code></pre><p>6.不想使用默认生成的函数，可以明确拒绝</p><pre><code class="hljs actionscript">默认的构造可以被其他构造替换，拷贝构造和赋值函数如果不想被外面调用可以将其声明为<span class="hljs-keyword">private</span>。</code></pre><p>8.别让异常逃离析构函数</p><pre><code class="hljs arduino">绝不要让析构函数抛出异常，应该让用户自己处理可能发生异常的操作。这个应该说是提供给用户接口来<span class="hljs-built_in">close</span>东西，如果用户没有这么做，可以在析构函数中<span class="hljs-keyword">try</span>，<span class="hljs-keyword">catch</span>.</code></pre><p>9.不要在构造和析构函数调用virtual函数</p><pre><code class="hljs cpp">　　由于父类的构造函数发生在子类之前，而此时子类的成员变量等并未初始化，因此在父类的构造函数中调用<span class="hljs-keyword">virtual</span>函数，绝对不会调用子类的方法，即使现在你在创建一个子类对象。换句话说，在构造函数中调用的<span class="hljs-keyword">virtual</span>函数，都会下降到父类类型，即都不是<span class="hljs-keyword">virtual</span>函数，因为一进入析构函数，子类对象就不存在了，默认就是调用父类的函数。</code></pre><p>10.令operator=返回reference to *this 并 11处理自我赋值</p><pre><code class="hljs kotlin">赋值操作返回*<span class="hljs-keyword">this</span>的引用。在shardptr以及很多相关的类型都是这样的。返回引用比临时变量要少几次构造析构，效率高。</code></pre><p> 13.以对象管理资源</p><pre><code class="hljs plain">在构造中获得资源并在析构函数中释放资源（RAII）</code></pre><p>14.在资源管理类中小心copy行为<br><pre><code class="hljs angelscript">    在RAII对象中进行复制的时候，可能会导致出现双重释放。这个解决办法有几种，一个是禁止对象赋值。一个是使用引用计数，最后一个释放的时候才真的释放资源，使用shard_ptr包装，或者使用深拷贝，资源复制一份，或者直接转移所有权，向<span class="hljs-built_in">auto</span>_ptr一样。</code></pre></p><p>条款 15：在资源管理类中提供对原始资源的访问</p><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>    RAII 类应该提供访问其所管理的原始资源的方法，例如条款 <span class="hljs-number">14</span> 中提到的 shared_ptr 中的 <span class="hljs-keyword">get</span> 方法。<span class="hljs-number">16.</span>成对的使用<span class="hljs-built_in">new</span>和<span class="hljs-keyword">delete</span><span class="hljs-number">1</span>　　使用<span class="hljs-built_in">new</span>申请内存，必须使用<span class="hljs-keyword">delete</span>释放内存，使用<span class="hljs-built_in">new</span> [] 申请内存，必须使用<span class="hljs-keyword">delete</span> []释放内存<span class="hljs-number">17</span>以单独的语句将newed对象置入shared_ptr<span class="hljs-number">1.</span>    意思为不要写下类似<span class="hljs-keyword">Function</span>(shared_ptr&lt;<span class="hljs-keyword">Class</span>&gt;(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Class</span>), x())，其中<span class="hljs-keyword">Function</span>和x为函数，<span class="hljs-keyword">Class</span>是一个类。原因在于shared_ptr的构造分为<span class="hljs-number">3</span>，<span class="hljs-built_in">new</span> <span class="hljs-keyword">class</span>, 构建shard_ptr对象，然后调用fuction，这个顺序在编译器中是不确定的，如果是先<span class="hljs-built_in">new</span>然后调用fuction， 构建shard_ptr对象，如果第二步出现异常，指针丢失，可能导致内存泄漏。</code></pre><p>20.以pass-by-reference-const替换pass-by-value</p><pre><code class="hljs csharp">　　主要考虑两点：　　<span class="hljs-number">1</span>效率问题，pass-<span class="hljs-keyword">by</span>-<span class="hljs-keyword">value</span>会导致很多临时对象的产生和销毁，就会多调用几次构造和析构，因此效率更低<span class="hljs-number">2</span> 对象切割问题，pass-<span class="hljs-keyword">by</span>-<span class="hljs-keyword">value</span>的方式将一个子类对象传入一个参数类型父类的函数，那么拷贝的对象将被切割成只有父类对象被保留，调用方法会调用父类的方法而不是子类。<span class="hljs-keyword">const</span>引用可以解决这个问题，因为引用本质上也是指针，就和多态是一样的　　另外，内置类型，STL迭代器和函数对象一般采用pass-<span class="hljs-keyword">by</span>-<span class="hljs-keyword">value</span>，因为其复制代价很小</code></pre><p>21.不要返回临时对象的引用</p><pre><code class="hljs actionscript">　　不要返回一个临时对象的引用　　不要返回在堆上分配的对象的引用，因为这违背了<span class="hljs-keyword">new</span>和<span class="hljs-keyword">delete</span>成对出现的原则，这样的方式是很不合理的，很容易导致内存泄漏。也不要返回一个<span class="hljs-keyword">static</span>对象的引用，因为<span class="hljs-keyword">static</span>可能同时被很多地方需要，是存在于静态变量区的，比如重载*之后，a*b==c*d,永远都是<span class="hljs-literal">true</span>，因为他们都指向那一个位置。 　　所以对于这种问题，最好的解决方法就是不返回引用就OK了。</code></pre><p>24.若所有参数皆需类型转换，那么请采用non-member函数</p><pre><code class="hljs angelscript">　　文中举了一个有理数Rational运算的例子，在类中加入一个operator*(<span class="hljs-keyword">const</span> Rational&amp; other)的函数，可以实现类似 rational * <span class="hljs-number">2</span>的操作，其中<span class="hljs-number">2</span>是个<span class="hljs-built_in">int</span>，但是因为rational有一个以<span class="hljs-built_in">int</span>为参数的构造，因此编译器帮你执行了隐式类型转换。但是反过来写<span class="hljs-number">2</span> * rational的时候，编译就报错了。因为<span class="hljs-number">2</span>是个<span class="hljs-built_in">int</span>，并没有operator*这个函数。但是为什么这样写就没有执行隐式类型转换呢？这又引出一个问题：隐士类型转换的合格条件是什么？答案是：必须是参数列中的参数才是隐士类型转换的有效参与者，类的执行者也就是<span class="hljs-string">&#x27;.&#x27;</span>前面的那个对象（<span class="hljs-keyword">this</span>指向的对象，比如说rational.func()中的rational是类执行者，相当于他是函数的调用人，地位较高，不能参与隐式类型转换），这就解释了为什么<span class="hljs-number">2</span>放在前面是不行的。解决此种问题的方法是提供一个non-mem的operator*(Rational a, Rational b)即可。</code></pre><p>25.写一个不抛出异常的swap函数（有点没看懂）</p><pre><code class="hljs avrasm">一般写<span class="hljs-keyword">swap</span>最普通的方法就是利用中间变量，temp = a<span class="hljs-comment">;a = b;b = temp，这种方法对于内置类型没任何问题，内置类型上的赋值绝对不会抛出异常，并且效率很高。但是如果a,b不是内置类型，就会调用类的copy构造函数和assign函数，并且必须是深拷贝。这样如果类的成员较多就会造成交换的效率很低，特别是针对pimpl实现方法，即成员中包含指针（即资源）时。更好的做法就是直接交换指针就可以了，相当于交换了两个int(指针都是4字节的)，这就比拷贝这个指针指向的资源要快得多。</span>　　如何实现呢？只要将<span class="hljs-keyword">swap</span>都转换成内置类型的<span class="hljs-keyword">swap</span>就可以了，做法就是在类中提供一个public的<span class="hljs-keyword">swap</span>(T&amp; b)函数（T为一个类），将每个成员进行交换（如果成员中包含其他非内置对象，调用这个对象的<span class="hljs-keyword">swap</span>函数即可）。然后提供一个non-member的<span class="hljs-keyword">swap</span>(T&amp; a, T&amp; b)重载函数，在函数内部调用类中的a.swap(b)，就可以像如下方式实现交换两个对象的操作：<span class="hljs-keyword">swap</span>(a, b)。　　注意：　　<span class="hljs-number">1</span>在类内的<span class="hljs-keyword">swap</span>交换内置类型时要调用<span class="hljs-keyword">std</span>命名空间内的<span class="hljs-keyword">swap</span>函数，必须使用using <span class="hljs-keyword">std</span>::<span class="hljs-keyword">swap</span>，否则就变成递归函数了　　<span class="hljs-number">2</span>另外文中说在<span class="hljs-keyword">std</span>命名空间内不能加入新东西，比如重载<span class="hljs-keyword">swap</span>函数，但是经博主测试是可以在<span class="hljs-keyword">std</span>内重载<span class="hljs-keyword">swap</span>函数的（g++版本为<span class="hljs-number">5.4</span><span class="hljs-number">.0</span>）。</code></pre><p>　　<br> 26.尽可能延后变量定义得时间</p><pre><code class="hljs routeros">　　1因为变量（对类而言）的定义，需要承担一次构造函数的时间，在函数结束后还可能承担一次析构函数的时间，假如该变量未被使用，那么构造函数和析构函数的时间就白白浪费了，尤其是在可能发生异常的函数中，假如你过早的定义变量，然后在你使用这个变量之前抛出了异常，那么这个变量的构造函数就没有意义而且降低效率。所以应该尽可能延后变量定义得时间，只有真正使用这个变量的时候才定义它　　2条款4讲过，copy construction的效率 &gt;<span class="hljs-built_in"> default </span>construction +assign function，所以最好的做法是直接调用copy construction函数对变量直接进行初始化，而不是先定义，再赋值　　3对于有循环的情况，假设一个n次的循环，如图所示：　　 　　那么方法A的代价：1次构造+1次析构+n次赋值　　方法B的代价：n次构造+n次析构　　如果n较大，那么应该选择方法A，如果n较小，可以选择方法B。</code></pre><p>27.尽量避免转型</p><pre><code class="hljs cpp">　　<span class="hljs-number">1</span>最好使用C++<span class="hljs-number">4</span>个新式的类型转换函数，因为这很容易辨识，代码可读性提高Static cast ：常规转换，可以将子类指针转换为父类指针，<span class="hljs-keyword">dynamic_cast</span> 将父类指针转换为子类指针，<span class="hljs-keyword">reinterpret_cast</span> 可以转指针成为一个<span class="hljs-keyword">int</span>，<span class="hljs-keyword">const_cast</span> 转<span class="hljs-keyword">const</span>到非<span class="hljs-keyword">const</span>类型　　<span class="hljs-number">2</span>尽量避免使用<span class="hljs-keyword">dynamic_cast</span>，因为这种转换效率很低，一般用虚函数的方式来避免转型</code></pre><p>28.避免返回一个指针、引用或者迭代器指向类内的成员</p><pre><code class="hljs actionscript">　　原因是如果返回了成员的引用或者指针，就可以通过这个引用或者指针修改雷内的<span class="hljs-keyword">private</span>成员，这样是不合理的（这样的话成员就相当于<span class="hljs-keyword">public</span>的了），这一点可以通过给函数的返回类型加<span class="hljs-keyword">const</span>修饰符来防止内部成员变量被修改。但是还有一种情况是，如果获得的类内的一个成员的引用或指针，但是在使用之前，对象被释放了，那么这个引用或指针就变成了野指针了，必然会导致core dump错误。所以应该避免返回类内成员的指针或引用。</code></pre><p>30.inline 函数</p><pre><code class="hljs cpp">　　<span class="hljs-keyword">inline</span>只是一种申请，编译器会根据具体情况来决定一个函数是否可以是<span class="hljs-keyword">inline</span>得，比如递归函数、<span class="hljs-keyword">virtual</span>函数、代码较多的函数，即使你声明了<span class="hljs-keyword">inline</span>关键字，编译器也不会将此类函数视为<span class="hljs-keyword">inline</span>的函数。　　</code></pre><p>31.编译依存关系降低至最低<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs stata">理解此条款关键是要理解C++的编译方式，具体可以参考：https:<span class="hljs-comment">//www.cnblogs.com/jerry19880126/p/3551836.html文中说的很详细。理解了文中的意思，再回头看这个条款就清晰多了。其关键点如下：</span></code></pre></p><p>　　1 关于前置声明的一个限制是：编译器必须在编译时确定类的大小，即分配多少内存。因此如果你前置声明一个类<span class="hljs-keyword">class</span> <span class="hljs-keyword">TEST</span>，然后在后面试图创建一个<span class="hljs-keyword">TEST</span>的对象<span class="hljs-keyword">TEST</span> <span class="hljs-keyword">test</span>，那么这个代码是不会通过编译的，因为编译器不确定要给<span class="hljs-keyword">test</span>分配多少内存。那怎么规避这个问题呢？答案就是指针，典型的pimpl方式，因为指针的字节数是固定的（相对于平台，一般就是4或者8字节）。例如下面的代码就是可以通过编译的。</p><h1 id="include-lt-iostream-gt"><a href="#include-lt-iostream-gt" class="headerlink" title="include &lt;iostream&gt;"></a><span class="hljs-keyword">include</span> &lt;iostream&gt;</h1><p>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-keyword">TEST</span>;<br><span class="hljs-keyword">class</span> AA&#123;<br>    public:<br>        <span class="hljs-keyword">TEST</span><em> aa;<br>        <span class="hljs-comment">//TEST&amp; b; //引用不可以，因为引用必须在初始化列表中进行初始化</span><br>        void T(<span class="hljs-keyword">TEST</span>&amp; tt) &#123;<br>        &#125;<br>        void wdt(<span class="hljs-keyword">TEST</span></em> tt) &#123;<br>        &#125;<br>        void PP() &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;AA::PP()&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        AA() &#123;&#125;<br>        ~AA() &#123;&#125;<br>&#125;;</p><p>int main() &#123;<br>    AA aa;<br>    aa.PP();<br>    <span class="hljs-keyword">return</span> 0;<br>&#125;</p><p>　可见，前置声明一个<span class="hljs-keyword">TEST</span>类，并没有对应的类的实现，在另外一个类A中声明一个<span class="hljs-keyword">TEST</span><em>的成员，包括在函数中使用<span class="hljs-keyword">TEST</span></em> 或者 <span class="hljs-keyword">TEST</span>&amp;类型的参数都没问题。但是在用这两个函数的时候还是要有<span class="hljs-keyword">TEST</span>的定义和实现，那么这个时候怎么办，就是再创建一个<span class="hljs-keyword">TEST</span>.<span class="hljs-keyword">h</span>和<span class="hljs-keyword">TEST</span>.<span class="hljs-keyword">cc</span>，然后在A.<span class="hljs-keyword">cc</span>中#<span class="hljs-keyword">Include</span><span class="hljs-string">&quot;TEST.H&quot;</span>(假如<span class="hljs-keyword">class</span> A也单独创建一个A.<span class="hljs-keyword">cc</span>和A.<span class="hljs-keyword">h</span>)，这样当<span class="hljs-keyword">TEST</span>中的内容有所改变的时候，只有<span class="hljs-keyword">TEST</span>.<span class="hljs-keyword">cc</span>和A.<span class="hljs-keyword">cc</span>被重新编译。所有使用<span class="hljs-keyword">class</span> A和<span class="hljs-keyword">class</span> <span class="hljs-keyword">TEST</span>的地方都不会被重新编译。假如使用这两个类的地方特别多，那么这样就可以减少很多文件的编译了。<br>　　2. 上面利用指针是一种实现方法，另一种就是Interface <span class="hljs-keyword">class</span>，即类中全部都是pure virtual函数，这样的类在使用的时候只能是以指针的形式出现，这样就同样达到了减少编译依赖的效果。<br>　　③当然这两种方式都存在一定的代价：指针方式的实现要多分配指针大小的内存，每次访问都是间接访问。接口形式的实现方式要承担虚函数表的代价以及运行时的查找表的代价。但是一般这两种实现对资源和效率的影响通常不是最关键的，因此可以放心的使用，类似tensorflow源码中就大量使用这种方式降低编译依赖。&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>33.名称遮掩问题</p><pre><code class="hljs cpp">　　子类会遮掩父类同名的函数，即使参数不一样也被遮掩了。可以使用类名作用域决定调用父类还是子类的函数,<span class="hljs-keyword">using</span> base:: fun1;</code></pre><p>34.接口继承与实现继承</p><pre><code class="hljs kotlin">　　理解接口继承和实现继承的区别，纯虚函数、非纯虚函数和普通函数在这两方面的区别：纯虚函数只指定接口继承、非纯虚函数指定接口继承并存在默认的实现继承、普通函数指定接口继承及强制实现继承。就是如果父类是普通函数非虚函数，那么是强制实现继承，子类的行为就和父类的一样，如果是纯虚函数说明只是一个接口，父类必须实现。如果是非纯虚函数，即virtual void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;然后在类外定义它，这样子类必须实现，同时父类还有默认的行为。</code></pre><p>35.考虑virtual函数以外的选择、</p><pre><code class="hljs cpp">可以将<span class="hljs-keyword">virtual</span>函数变为<span class="hljs-keyword">private</span>和<span class="hljs-keyword">protected</span>的，然后用puclic的函数调用它，提供给他人。NVI方法。可以将<span class="hljs-keyword">virtual</span>函数替换为函数指针成员变量。Strategy设计模式。</code></pre><p>36.不要重新定义继承来的non-virtual函数</p><pre><code class="hljs dns">　　non-virtual在实现上是静态绑定的，调用父类还是子类的函数完全取决于指针或者对象的类型，不管<span class="hljs-keyword">A</span>指针指向的是<span class="hljs-keyword">A</span>的对象还是B的对象，总是调用<span class="hljs-keyword">A</span>的方法，B指针总是B类的方法。</code></pre><p>37.不要重新定义重写函数（virtual）的默认参数</p><pre><code class="hljs verilog">　　默认参数都是静态绑定的，即你的指针是什么类型，默认参数就是什么类型。而<span class="hljs-keyword">virtual</span>函数是动态绑定的，在运行期才决定调用哪个函数。所以如果你在父类<span class="hljs-keyword">class</span> Father有一个<span class="hljs-keyword">virtual</span>函数并带有默认参数，例如<span class="hljs-keyword">void</span> p(<span class="hljs-keyword">int</span> <span class="hljs-keyword">default</span> = <span class="hljs-number">100</span>)，在子类重写这个函数，然后换了新的默认参数为<span class="hljs-keyword">default</span> = <span class="hljs-number">10</span>，在你以多态的方式调用p的时候：Father* f = <span class="hljs-keyword">new</span> Son; f-&gt;p();这种情况p的默认参数为<span class="hljs-number">100</span>而非<span class="hljs-number">10</span>。因为f指针的静态类型为Father，而动态类型为Son。所以如果你的函数必须包含默认参数，不要这样写，解决方法是将带有默认参数的函数改为non-<span class="hljs-keyword">virtual</span>函数，内部再调用一个<span class="hljs-keyword">virtual</span>函数。因为non-<span class="hljs-keyword">virtual</span>函数是从来不应该被重写的（条款<span class="hljs-number">36</span>，覆盖问题）</code></pre><p>39.私有继承</p><pre><code class="hljs actionscript">　　子类继承父类的方式决定了在子类中父类函数的属性，一般规则就是所有属性都按照继承方式对其。比如采用<span class="hljs-keyword">protected</span>继承方式，那么父类中的<span class="hljs-keyword">public</span>成员在子类都升级为<span class="hljs-keyword">protected</span>，其他保持不变。如果采用<span class="hljs-keyword">private</span>继承方式，父类中的所有成员全部变为<span class="hljs-keyword">private</span>，特殊之处之一是父类中原本就是<span class="hljs-keyword">private</span>的成员不可继承，即在子类中也无法使用父类的<span class="hljs-keyword">private</span>成员。</code></pre><p>40.多重继承 </p><pre><code class="hljs plain">　　会导致歧义性，需要虚继承。</code></pre><p>41.隐式接口和编译器多态</p><pre><code class="hljs d">　　<span class="hljs-keyword">class</span>的继承和<span class="hljs-keyword">template</span>都支持接口和多态。只不过<span class="hljs-keyword">class</span>实现的接口是显示的，就是说一定能直接找到这个接口的实现代码。而<span class="hljs-keyword">template</span>实现的接口，只能模糊的知道接口的特征，一般间接能找到实现的代码。比如我们用<span class="hljs-keyword">template</span>函数T w，w.size(),表明w必须实现size（）接口。用不同的参数具体化模板会导致调用不同的函数，就是编译器多态。用继承实现的多态属于运行期多态、模板实现的多态则是编译期多态。</code></pre><p>42.了解typename</p><pre><code class="hljs cpp">　　<span class="hljs-number">1.</span> 在声明<span class="hljs-keyword">template</span>参数时，<span class="hljs-class"><span class="hljs-keyword">class</span>和<span class="hljs-title">typename</span>可互换。</span><span class="hljs-class">　　2. <span class="hljs-title">typename</span>的第二个用处是告诉编译期某一个嵌套从属类型是类型，最典型的就是<span class="hljs-title">STL</span>中容器的迭代器类型，例如：<span class="hljs-title">T</span>:</span>:iterator(T是个容器的类型，例如：<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;)，这个时候就要在T::iterator前面加一个<span class="hljs-keyword">typename</span>，告诉编译器这是一个类型，否则编译器不能确定这是什么，因为有可能iterator是个静态变量或者某一<span class="hljs-keyword">namespace</span>下的变量。　　③类的继承列表和初始化列表中的类型不需要<span class="hljs-keyword">typename</span>指定类型，因为继承的一定是个类，而初始化列表一定是调用父类的构造或者初始化某个成员。</code></pre><p>43.调用基类模板成员</p><pre><code class="hljs stata">　　当一个类的基类包含模板参数时，需要通过this-&gt;的方式调用基类内的函数，例如 <span class="hljs-keyword">class</span> F: public S&lt;C&gt;，在F中的成员函数中调用S中的成员函数this-&gt;<span class="hljs-keyword">test</span>()，而直接写<span class="hljs-keyword">test</span>()无法通过编译，原因是因为C是个模板没有办法确定类S的具体长相，或者说无法确定S中一定有<span class="hljs-keyword">test</span>函数，即使你写的所有C都包含<span class="hljs-keyword">test</span>函数，但是在编译器看来它是不确定这个问题的，因此无法通过编译。　　解决办法是：1. 使用this-&gt;<span class="hljs-keyword">test</span>，这样做告诉编译器假设这个<span class="hljs-keyword">test</span>已经被继承了。2. 使用using声明式：using S&lt;C&gt;::<span class="hljs-keyword">test</span>告诉编译期这个<span class="hljs-keyword">test</span>位于S内。相当于必须手动通知编译器这个函数是存在的。</code></pre><p>44.将与template参数无关的代码抽离到模板外</p><pre><code class="hljs plain">　　原因是模板会根据具体类型具象化不同的代码，如果将与模板无关的代码也放入模板函数或者类中，那么就会生成重复的代码，就会导致代码膨胀的问题，函数模板中与参数无关的代码可以包装成单独的函数。类模板中与参数无关的模板可以放到父类中。</code></pre><p>45.运用成员函数模板接受所有兼容类型</p><pre><code class="hljs cpp">　　文中以<span class="hljs-built_in">shared_ptr</span>为例讲解了使用成员函数模板实现智能指针不同类型间的转换，以及如何避免任意类型之间的相互转换，这种函数可称为泛化拷贝构造函数。另外泛化拷贝构造不同于默认拷贝构造函数。如果没有自己没有编写赋值构造函数和拷贝构造函数，那么泛化拷贝构造函数不会阻止编译器生成默认的赋值构造和拷贝构造。</code></pre><p>46.需要类型转换时请为模板定义非成员函数</p><pre><code class="hljs cpp">　 　条款<span class="hljs-number">24</span>中Rational函数仅以<span class="hljs-keyword">int</span>为例，说明了隐士类型转换的合格参与者的条件，并提出了非成员函数的解决方法。现在将其扩展为<span class="hljs-keyword">template</span>形式：<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-keyword">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; rhs) &#123;……&#125;　　发现在调用的时候无法通过编译，即以下代码无法通过编译：    <span class="hljs-function">Rational&lt;<span class="hljs-keyword">int</span>&gt;   <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;Rational&lt;<span class="hljs-keyword">int</span>&gt;    ret = oneHalf*<span class="hljs-number">2</span>;　　相比于条款<span class="hljs-number">24</span>，换成模板之后为什么就无法通过编译了呢？原因在于模板的运行需要进行模板推算，即<span class="hljs-keyword">operator</span>*函数的两个参数类型的T要根据传入的参数类型进行确认，第一个参数因为是oneHalf，其本身就是Rational&lt;<span class="hljs-keyword">int</span>&gt;类型，因此第一个参数的类型中的T很容易进行推理，但是第二个传入的参数是<span class="hljs-keyword">int</span>，如何根据这个<span class="hljs-keyword">int</span>参数推导出第二个参数的类型T呢？显然编译器无法进行推理，条款<span class="hljs-number">24</span>能推理的原因是进行了隐士类型转换，或者说Rational的构造函数中有一个以<span class="hljs-keyword">int</span>为参数的构造函数，但是<span class="hljs-keyword">template</span>在进行参数推到的过程中从不将隐士类型转换函数考虑在内，这也是合理的因为你没法根据参数类型推导出模板参数，这个Ratinal的例子貌似看起来可以，因为构造函数的参数类型是<span class="hljs-keyword">const</span> T&amp; 但是假如其构造参数类型是个固定类型，比如说<span class="hljs-keyword">float</span>，那么难道模板参数能永远是<span class="hljs-keyword">float</span>么。因此编译器不考虑隐士类型转换也是有道理的。　　那么这个问题怎么解决呢，该如何让这个模板函数的参数能进行隐式类型转换，答案就是：先具象化这个函数，相当于先确定T，然后就可以进行隐士类型转换了，做法是在类中声明一个非成员函数，这该如何做到呢，答案就是友元函数，在类中定义的友元函数都被视为非成员函数，对于本例该像如下方式声明：<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&amp; lhs, <span class="hljs-keyword">const</span> Rational&amp; rhs) &#123;   <span class="hljs-keyword">return</span>  (lhs.numrator()*rhs.numrator()/lhs.denominator()*rhs.denominator()); &#125;　　由于此函数是在模板类的内部，因此当oneHalf对象生成之后，T就被确定为<span class="hljs-keyword">int</span>，那么<span class="hljs-keyword">operator</span>*函数的参数和返回值中的T也均是确定的了。　　另外，由于此函数的功能过于简单，因此可直接将其实现放入类中（<span class="hljs-keyword">inline</span>的），假如类的功能很复杂，那么一般都采用调用类外的某一个功能函数，这时候代码这样实现：<span class="hljs-keyword">friend</span> <span class="hljs-keyword">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-keyword">const</span> Rational&lt;T&gt;&amp; rhs) &#123;      <span class="hljs-keyword">return</span>  DoMultiply&lt;T&gt;(lhs, rhs); &#125;　　这样写实际和上面的写法是一样的，当T被确定为<span class="hljs-keyword">int</span>时，会生成一份Rational&lt;<span class="hljs-keyword">int</span>&gt;的类，具象化出里面的函数，这样就能确定调用的是T为<span class="hljs-keyword">int</span>的<span class="hljs-keyword">operator</span>*函数，然后在另一个模板函数内实现其操作，本例来说就是DoMultiply函数。</code></pre><p>47.traits编程技巧</p><pre><code class="hljs cpp">　　traits是用来获取参数类型信息，因为有时候需要根据参数类型信息做不同的处理，下面这篇博客中列举了两个简单的例子，https:<span class="hljs-comment">//blog.csdn.net/my_business/article/details/7891687（其实可以使用typeid进行简单的实现，但是这种做法效率低，因为typeid需要配个if使用，if是在运行期才决定的，而traits可以在编译器就进行类型的判别，效率更高），文中以STL迭代器相关函数中的advance为例，advance函数原型为：</span>看到这里大家可能都会发现这里 <span class="hljs-keyword">if</span> (TypeTraits &lt;T&gt;::__IsPODType().Get()) 这句其实是最关键的，用这句来区别调用的是哪个方法。但是这句里面的 __IsPODType()和Get()是哪里来的呢？<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">TrueType</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">FalseType</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;这个是TypeTraits的模板本体，默认__IsPODType为_FalseType.当它为内置类型的特化时  __IsPODType为_TureType<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Tp</span>&gt;</span><span class="hljs-class"><span class="hljs-title">struct</span> <span class="hljs-title">TypeTraits</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">typedef</span> __FalseType   __IsPODType;&#125;;<span class="hljs-comment">//从这开始都是特化版本（类型萃取的开始）</span><span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeTraits</span>&lt; char&gt;</span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">typedef</span> __TrueType     __IsPODType;&#125;;<span class="hljs-keyword">template</span> &lt;&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TypeTraits</span>&lt; unsigned char &gt;</span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">typedef</span> __TrueType     __IsPODType;&#125;;为了类型萃取，我们把所有的内置类型进行特化， 当然这里我只是把内置类型特化的前两个拿了出来，当T为内置类型 时 让 _IsPODType为_TureType，所以 <span class="hljs-keyword">if</span> (TypeTraits &lt;T&gt;::__IsPODType().Get())表达为真，走的是<span class="hljs-built_in">realloc</span>的方法主要使用的是模板特化的方法。通过一个<span class="hljs-class"><span class="hljs-keyword">struct</span>将不同的类型<span class="hljs-title">typedef</span>定义成一个类型，然后使用模板特化编译的时候获取到真实的类型，然后调用实际的方法。</span></code></pre><p>48.模板元编程</p><pre><code class="hljs haxe">　　采用模板编程的好处是：<span class="hljs-number">1.</span> 可将工作由运行期移动到编译器完成，造成更高的执行效率（占用内存小，运行速度快）和更早的侦测错误<span class="hljs-number">2.</span> 编码更加简洁；坏处：<span class="hljs-number">1.</span> 编译时间长<span class="hljs-number">2.</span> 代码不易理解八.定制<span class="hljs-keyword">new</span><span class="hljs-type"></span>和delete（条款<span class="hljs-number">49</span>~<span class="hljs-number">52</span>） 　　这章讲了<span class="hljs-keyword">new</span><span class="hljs-type"></span>和delete的一些高级用法：set_new<span class="hljs-type">_handler</span>、operator <span class="hljs-keyword">new</span><span class="hljs-type"></span>/delete的重载及应该遵循的规则、placement <span class="hljs-keyword">new</span><span class="hljs-type"></span>。一般情况下较少会重载<span class="hljs-keyword">new</span><span class="hljs-type"></span>，所以倒不如了解<span class="hljs-keyword">new</span><span class="hljs-type"></span>/delete的基础知识更好</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>explicit</title>
    <link href="/2022/04/04/C++/explicit/"/>
    <url>/2022/04/04/C++/explicit/</url>
    
    <content type="html"><![CDATA[<p>explicit使用注意事项: </p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、 <span class="hljs-keyword">explicit</span> 关键字只能用于类内部的构造函数声明上。 <span class="hljs-number">2.</span> 在C++中，<span class="hljs-keyword">explicit</span>关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换</code></pre><p><a href="https://zhuanlan.zhihu.com/p/42086263">可以参考这篇文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>explicit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程入门</title>
    <link href="/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/socket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hiyu.space/2021/02/28/C-socket%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/#more">socket编程入门</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>计算机网络</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GDB入门</title>
    <link href="/2022/04/04/C++/GDB%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/04/C++/GDB%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="http://c.biancheng.net/view/8189.html">GDB打断点的方式</a></p><p><a href="https://www.hiyu.space/2021/02/24/GDB%E5%85%A5%E9%97%A8/#more">GDB入门</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>GDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++11新特性</title>
    <link href="/2022/04/04/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/04/04/C++/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hiyu.space/2021/01/25/C-11%E6%96%B0%E7%89%B9%E6%80%A7/#more">C++11新特性</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>智能指针</tag>
      
      <tag>完美转发</tag>
      
      <tag>移动语义</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL知识点整理</title>
    <link href="/2022/04/04/C++/C++%20STL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/04/04/C++/C++%20STL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hiyu.space/2021/01/24/C-STL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#more">C++STL知识点整理</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用命令</title>
    <link href="/2022/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.hiyu.space/2021/02/09/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86-Linux%E7%AF%87/#more">linux常用命令</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>malloc new free delete 区别</title>
    <link href="/2022/04/04/C++/malloc%20new%20delete%20free%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/04/C++/malloc%20new%20delete%20free%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="malloc-free和new-delete的区别"><a href="#malloc-free和new-delete的区别" class="headerlink" title="malloc/free和new/delete的区别"></a>malloc/free和new/delete的区别</h1><pre><code class="hljs http">共同点：都是从堆上申请空间。并且需要用户手动释放不同点：<span class="hljs-attribute">malloc和free是函数，new和delete是操作符</span><span class="hljs-attribute"></span><span class="hljs-attribute">malloc申请的空间不会初始化，new可以</span><span class="hljs-attribute"></span><span class="hljs-attribute">malloc申请空间时，需要手动计算空间的大小并传递，new只需要在其后边跟上空间的类型即可</span><span class="hljs-attribute"></span><span class="hljs-attribute">malloc的返回值是void*，在使用时必须强转，new不需要，因为new后跟的是空间的类型</span><span class="hljs-attribute"></span><span class="hljs-attribute">malloc在申请失败后返回的是NULL,因此使用时必须判空，new不需要，但是new需要捕获异常</span><span class="hljs-attribute"></span><span class="hljs-attribute"></span><span class="hljs-attribute">申请自定义类型对象时，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理</span><span class="hljs-attribute"></span><span class="hljs-attribute">new/delete比malloc和free的效率稍微低点，因为new/delete的底层封装了malloc/free</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++单例设计模式</title>
    <link href="/2022/04/04/C++/C++%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/04/C++/C++%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="最推荐的懒汉式单例-magic-static-——局部静态变量"><a href="#最推荐的懒汉式单例-magic-static-——局部静态变量" class="headerlink" title="最推荐的懒汉式单例(magic static )——局部静态变量"></a>最推荐的懒汉式单例(magic static )——局部静态变量</h1><pre><code class="hljs routeros"><span class="hljs-comment">#include &lt;iostream&gt;</span>class Singleton &#123;public:  static Singleton&amp; GetInstance() &#123;    static Singleton intance;    return intance;  &#125;  ~Singleton() = default;private:  Singleton() = default;  Singleton(const Singleton&amp;) = delete;  Singleton&amp; operator=(const Singleton&amp;) = delete;&#125;;非局部静态变量一般在main执行之前的静态初始化过程中分配内存并初始化，可以认为是线程安全的；全局变量、文件域的静态变量和类的静态成员变量在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量（一般为函数内的静态变量）在第一次使用时分配内存并初始化。这里的变量包含内置数据类型和自定义类型的对象。局部静态变量在编译时，编译器的实现一般是在初始化语句之前设置一个局部静态变量的标识来判断是否已经初始化，运行的时候每次进行判断，如果需要初始化则执行初始化操作，否则不执行。这个过程本身不是线程安全的。C++11标准针规定了局部静态变量初始化需要保证线程安全如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。这是最推荐的一种单例实现方式：通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性);不需要使用共享指针，代码简洁；注意在使用的时候需要声明单例的引用 Single&amp; 才能获取对象。</code></pre><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CSingleton</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    CSingleton()&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;单例对象创建！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;;    CSingleton(<span class="hljs-keyword">const</span> CSingleton &amp;);    CSingleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> CSingleton &amp;);    ~CSingleton()&#123; <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;单例对象销毁！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>; &#125;;    <span class="hljs-keyword">static</span> CSingleton myInstance; <span class="hljs-comment">// 单例对象在这里！</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">static</span> CSingleton* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;                <span class="hljs-keyword">return</span> &amp;myInstance;    &#125;&#125;;CSingleton CSingleton::myInstance;只有一个对象创建，且线程安全。</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAII</title>
    <link href="/2022/04/04/C++/RAII/"/>
    <url>/2022/04/04/C++/RAII/</url>
    
    <content type="html"><![CDATA[<p>RAII<br>Resource Acquisition Is Initialization的缩写，即资源获取即初始化，当对象创建的时候获取资源，对象析构的时候释放资源</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>RAII</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++引用和指针区别</title>
    <link href="/2022/04/04/C++/C++%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/04/C++/C++%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weikangc/article/details/49762929">引用和指针区别</a></p><p>引用</p><p>可以认为是T *const 指针</p><p>指向的地址是不可变的，在c++中认为是别名。在使用的时候会自动解引用。使用引用可以避免拷贝的问题，引用相比指针更容易使用，引用应该避免为空。</p><pre><code class="hljs angelscript">  <span class="hljs-number">1.</span> 都是地址的概念；    指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。★ 区别：    <span class="hljs-number">1.</span> 指针是一个实体，而引用仅是个别名；    <span class="hljs-number">2.</span> 引用使用时无需解引用（*），指针需要解引用；    <span class="hljs-number">3.</span> 引用只能在定义时被初始化一次，之后不可变；指针可变；    引用“从一而终” ^_^    <span class="hljs-number">4.</span> 引用没有 <span class="hljs-keyword">const</span>，指针有 <span class="hljs-keyword">const</span>，<span class="hljs-keyword">const</span> 的指针不可变；    <span class="hljs-number">5.</span> 引用不能为空，指针可以为空；    <span class="hljs-number">6.</span> “sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的地址）的大小；    typeid（T） == typeid（T&amp;） 恒为真，sizeof（T） == sizeof（T&amp;） 恒为真，但是当引用作为成员时，其占用空间与指针相同（没找到标准的规定）。    <span class="hljs-number">7.</span> 指针和引用的自增（++）运算意义不一样；</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>auto 用法</title>
    <link href="/2022/04/04/C++/Auto%E7%94%A8%E6%B3%95/"/>
    <url>/2022/04/04/C++/Auto%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs scss"><span class="hljs-attribute">auto</span>关键字用法主要用在自动类型推断上，以及函数返回值用<span class="hljs-attribute">auto</span>变量来接受。<span class="hljs-attribute">Auto</span>不能推断CV类型，函数参数和模板参数不能够声明为<span class="hljs-attribute">auto</span><span class="hljs-attribute">Auto</span> 变量类型指向数组的时候，默认是指针类型，除非用引用。<span class="hljs-attribute">Auto</span>变量必须初始化<span class="hljs-attribute">Auto</span>不能够用以类型转换<span class="hljs-attribute">Auto</span>一排变量。其类型必须是一样的<span class="hljs-attribute">Auto</span>不能和其他类型结合使用用<span class="hljs-attribute">auto</span>声明在堆上的变量必须初始化</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>auto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++智能指针介绍shard_ptr,weakptr,unique_ptr</title>
    <link href="/2022/04/04/C++/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/04/04/C++/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>智能指针主要有三种，shard_ptr,weakptr,unique_ptr</p><pre><code class="hljs http">需要的情形主要是，防止new之后忘记delete，多次delete，使用以及释放的对象需要include&lt;memory&gt;Shard_ptr 表面是指针，实际上是对象，拥有对对象的指针，计数值，当计数值为0时候，会自动释放内存，但是会出现循环引用的问题，避免用一个原始指针初始化多个智能指针出现多次释放资源的情况。Weak_ptr可以用shard_ptr来初始化，他是弱引用，主要是用来协作shard_ptr来 进行的，没有重载operator*和-&gt;，不占计数值，在循环引用出现的情况中将一个初始化为weak_ptr可以避免循环引用的情况，在需要对象的所有权时，可以将其转换为shard_ptr来使用，获得对象的所有权<span class="hljs-attribute">Unique_ptr主要是获得对对象的独占权，不可以赋值，可以用移动语义，move转移所有权。</span><span class="hljs-attribute"></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++智能指针实现</title>
    <link href="/2022/04/04/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/04/04/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>智能指针的C++实现</p><p><a href="https://zhuanlan.zhihu.com/p/64543967">实现参考1</a></p><p><a href="https://www.cnblogs.com/wxquare/p/4759020.html">实现参考2</a></p><p><a href="https://cloud.tencent.com/developer/article/1688444">实现参考3</a></p><pre><code class="hljs arduino">智能指针实现：<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shard_Ptr</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">private</span>:        <span class="hljs-keyword">size_t</span> * pCount;        T * pPtr;    <span class="hljs-keyword">private</span>:        <span class="hljs-built_in">release</span>()        &#123;            <span class="hljs-keyword">if</span>(--(*pCount)==<span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">delete</span> pCount;                <span class="hljs-keyword">delete</span> pPtr;            &#125;        &#125;    <span class="hljs-keyword">public</span>:        Shard_Ptr(T* ptr=<span class="hljs-literal">nullptr</span>): pCount(<span class="hljs-keyword">new</span> <span class="hljs-keyword">size_t</span>(<span class="hljs-number">1</span>)),pPtr(ptr)&#123;&#125;        ~Shard_Ptr()        &#123;            <span class="hljs-built_in">release</span>();        &#125;        Shard_Ptr(<span class="hljs-keyword">const</span> Shard_Ptr&lt;T&gt;&amp; ptr): pCount(ptr.pCount),pPtr(ptr.pPtr)        &#123;              addRefCount();        &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addRefCount</span><span class="hljs-params">()</span></span><span class="hljs-function">        </span>&#123;            (*pCount)++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">useCount</span><span class="hljs-params">()</span></span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">return</span> (*pCount);        &#125;        <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span></span><span class="hljs-function">        </span>&#123;            <span class="hljs-keyword">return</span> pPtr;        &#125;        T&amp; <span class="hljs-keyword">operator</span> *()        &#123;            <span class="hljs-keyword">return</span> *pPtr;        &#125;        T* <span class="hljs-keyword">operator</span> -&gt;()        &#123;            <span class="hljs-keyword">return</span> pPtr;        &#125;        Shard_Ptr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Shard_Ptr&lt;T&gt;&amp; ptr)        &#123;            <span class="hljs-keyword">if</span>(pPtr!=ptr.pPtr)            &#123;                <span class="hljs-built_in">release</span>();                pPtr=ptr.pPtr;                pCount=ptr.pCount;                addRefCount();            &#125;            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1705. 吃苹果的最大数目（可以用红黑树即map或者优先队列priority_queue实现）</title>
    <link href="/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>一般可以用优先队列的也可以用红黑树实现，可以比较一下。</p><p>优先队列实现<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eatenApples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; apples, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; days)&lt;/span&gt; &lt;/span&gt;&#123;</span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-built_in&quot;&gt;priority_queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;, greater&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; pq;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, n = apples.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); i &amp;lt; n || !pq.empty(); ++i) &amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; n  &amp;amp;&amp;amp; apples[i] != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123;        pq.emplace(i + days[i], apples[i]);    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!pq.empty() &amp;amp;&amp;amp; pq.top().first &amp;lt;= i) &amp;#123;        pq.pop();    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!pq.empty()) &amp;#123;        res++;        &lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mypair = pq.top();        mypair.second--;        pq.pop();        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (mypair.second&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123;            pq.emplace(mypair);        &amp;#125;    &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;</code></pre><p>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;<br>红黑树实现<br><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eatenApples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; apples, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; days)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n=apples.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; m;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n||!m.empty();i++)        &#123;            m.erase(i);            <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;apples[i]!=<span class="hljs-number">0</span>)                m[i+days[i]]=apples[i];            <span class="hljs-keyword">if</span>(!m.empty())            &#123;                <span class="hljs-keyword">auto</span> tmp=m.<span class="hljs-built_in">begin</span>();                tmp-&gt;second--;                <span class="hljs-keyword">if</span>(tmp-&gt;second==<span class="hljs-number">0</span>)                    m.erase(tmp);                res++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>红黑树</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树知识点</title>
    <link href="/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>一般来说红黑树有以下的知识点</p><ol><li><p>根是黑色</p></li><li><p>叶节点是黑色的（即为空的黑色的哨兵节点）</p></li><li><p>从跟到叶子经过相同数目的黑色节点</p></li><li><p>红色节点的子节点一定是两个黑色的</p></li><li><p>节点为红色或者黑色</p></li></ol><p>可以参考这个链接来使用<a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p><p>红黑树主要是通过左旋右旋和节点变色来实现的。这个左旋右旋和b树b+树的都是一样的。</p><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>与二叉搜索树差不多的，但是由于红黑树总是黑色平衡的，<br>所以最坏是O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性</p><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>首先必须先找到插入位置，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，<br>红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所<br>在的子树黑色结点总是多1，必须做自平衡。</p><p>一般来说加入红节点会破坏1或者4。</p><h3 id="1-如果此时树为空树，那么必须把插入的节点改成黑色。"><a href="#1-如果此时树为空树，那么必须把插入的节点改成黑色。" class="headerlink" title="1. 如果此时树为空树，那么必须把插入的节点改成黑色。"></a>1. 如果此时树为空树，那么必须把插入的节点改成黑色。</h3><h3 id="2-如果插入的节点父节点为黑节点，那么可以直接插入。"><a href="#2-如果插入的节点父节点为黑节点，那么可以直接插入。" class="headerlink" title="2. 如果插入的节点父节点为黑节点，那么可以直接插入。"></a>2. 如果插入的节点父节点为黑节点，那么可以直接插入。</h3><h3 id="3-如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论"><a href="#3-如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论" class="headerlink" title="3. 如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论"></a>3. 如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论</h3><h4 id="3-1-叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。"><a href="#3-1-叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。" class="headerlink" title="3.1 叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。"></a>3.1 叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。</h4><h4 id="3-2-叔叔节点为黑色或者不存在，且父亲是爷爷的左节点"><a href="#3-2-叔叔节点为黑色或者不存在，且父亲是爷爷的左节点" class="headerlink" title="3.2 叔叔节点为黑色或者不存在，且父亲是爷爷的左节点"></a>3.2 叔叔节点为黑色或者不存在，且父亲是爷爷的左节点</h4><h5 id="3-2-1-自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。"><a href="#3-2-1-自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。" class="headerlink" title="3.2.1 自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。"></a>3.2.1 自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。</h5><h5 id="3-2-2-自己插入的是父亲节点的右节点，对父亲节点左旋变成3-2-1"><a href="#3-2-2-自己插入的是父亲节点的右节点，对父亲节点左旋变成3-2-1" class="headerlink" title="3.2.2 自己插入的是父亲节点的右节点，对父亲节点左旋变成3.2.1"></a>3.2.2 自己插入的是父亲节点的右节点，对父亲节点左旋变成3.2.1</h5><h4 id="3-3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在"><a href="#3-3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在" class="headerlink" title="3.3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在"></a>3.3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在</h4><p>且为黑色，那么自己的路径和叔叔路径的黑色数目就不一样了），且父亲是爷爷的右节点（是3.2的另外一个方向的版本）</p><h5 id="3-3-1-自己插入的是父亲节点的左节点，右旋，变成3-3-2。"><a href="#3-3-1-自己插入的是父亲节点的左节点，右旋，变成3-3-2。" class="headerlink" title="3.3.1 自己插入的是父亲节点的左节点，右旋，变成3.3.2。"></a>3.3.1 自己插入的是父亲节点的左节点，右旋，变成3.3.2。</h5><h5 id="3-3-2-自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。"><a href="#3-3-2-自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。" class="headerlink" title="3.3.2 自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。"></a>3.3.2 自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。</h5><h3 id="插入节点的key已经存在，那么此时更新节点的value。"><a href="#插入节点的key已经存在，那么此时更新节点的value。" class="headerlink" title="插入节点的key已经存在，那么此时更新节点的value。"></a>插入节点的key已经存在，那么此时更新节点的value。</h3><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><p>删除的情况主要有几个点</p><p>1.删除的节点没有子节点，直接删除。</p><ol><li><p>删除的节点有一个子节点，用子节点代替删除的节点（可以认为是删除了子节点）</p></li><li><p>删除的节点有两个子节点，用后继节点代替删除的节点。（也可以用前驱节点代替，这里以后继节点为例）。<br>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。（即中序遍历的后面一个节点）<br>这里可以认为是删除了后继节点，转成情况2或者通过情况2（不存在左节点）转情况1</p></li></ol><p>我们目的都是可以把情况2，3认为是情况1</p><p>综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</p><ol><li>替换节点是红色节点</li></ol><p>我们把替换结点换到了删除结点的位置时，<br>由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p>2.替换节点是黑色节点</p><p>2.1.1 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点，兄弟节点的父节点和子节点都是黑色。</p><p>此时把替换节点，父节点，兄弟节点变成黑红黑，然后左旋。</p><p>2.1.2 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点，</p><p>2.1.2.1替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</p><p>此时由于会删除黑色节点导致不平衡，所以兄弟节点改成父节点的颜色，将父节点改为黑色，<br>兄弟节点的右节点改为黑色。然后左旋。</p><p>2.1.2.2 替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</p><p>删除黑色的替换节点会不平衡，所以将S设置为红色，对兄弟节点右旋，然后得到2.1.2.1的情况。</p><p>2.1.2.3 替换结点的兄弟结点的右子结点为黑结点，左子结点为黑结点</p><p>将兄弟节点设置为红色。将父节点作为新的替换节点。然后重新进行删除节点处理。</p><p>2.2：替换结点是其父结点的左子结点</p><p>这个情况和2.1相同，只是方向相反。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树压缩和解压缩</title>
    <link href="/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>主要是把字符串读到vector中，然后记录每个字符出现的次数，然后构建哈夫曼树，然后再生成哈夫曼编码，再写入。</p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">long</span> byteNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> weight;    <span class="hljs-keyword">int</span> parent, lchild, rchild;&#125;HafuNode, * HufumanTree;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span>* data;    <span class="hljs-keyword">int</span>* num;    <span class="hljs-keyword">int</span> length;&#125;TNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span>* data;    <span class="hljs-keyword">char</span>** HM;&#125;Code;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>** HuffmanCode;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hafuman</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    HuffmanCode code;    TNode tnod;    HufumanTree hafutree;    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">char</span>&gt; hafumanHash;    <span class="hljs-comment">//存文件内容</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; str;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compression</span><span class="hljs-params">(<span class="hljs-built_in">string</span> decomFile,<span class="hljs-built_in">string</span> comFile)</span></span><span class="hljs-function">    </span>&#123;        Read(comFile);        TNodeCount();        CreateHuffmanTree();        CreatHuffmanCode();        <span class="hljs-keyword">int</span> i, j, k;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">bit</span> = <span class="hljs-number">0</span>;        <span class="hljs-function">ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;compression.txt&quot;</span>, ios::out)</span></span>;        <span class="hljs-function">ofstream <span class="hljs-title">outComFile</span><span class="hljs-params">(decomFile, ios::out)</span></span>;        <span class="hljs-keyword">if</span> (!outfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//写入编码</span>        outComFile &lt;&lt; tnod.length &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tnod.length; i++)        &#123;            outComFile &lt;&lt; tnod.data[i];            outComFile &lt;&lt; code[i + <span class="hljs-number">1</span>];            outComFile &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        &#125;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)        &#123;            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; tnod.length; j++)            &#123;                <span class="hljs-keyword">if</span> (tnod.data[j] == str[i])                &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; code[j + <span class="hljs-number">1</span>][k] != <span class="hljs-string">&#x27;\0&#x27;</span>; k++)            &#123;                outfile &lt;&lt; code[j + <span class="hljs-number">1</span>][k];                <span class="hljs-keyword">if</span> (code[j + <span class="hljs-number">1</span>][k] == <span class="hljs-string">&#x27;0&#x27;</span>)                &#123;                    tmp = tmp | <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    tmp = (tmp | <span class="hljs-number">1</span>);                &#125;                <span class="hljs-built_in">bit</span> = (<span class="hljs-built_in">bit</span> + <span class="hljs-number">1</span>) % <span class="hljs-number">32</span>;                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">bit</span>)                &#123;                    outComFile &lt;&lt; tmp &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;                    tmp = <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span>                    tmp = tmp &lt;&lt; <span class="hljs-number">1</span>;                byteNum++;            &#125;        &#125;        tmp = tmp &lt;&lt; (<span class="hljs-number">32</span> - byteNum % <span class="hljs-number">32</span> - <span class="hljs-number">1</span>);        outComFile &lt;&lt; tmp &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        outComFile &lt;&lt; byteNum;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;文件的总的字符数为 &quot;</span> &lt;&lt; byteNum &lt;&lt; <span class="hljs-built_in">endl</span>;        outfile.<span class="hljs-built_in">close</span>();        <span class="hljs-comment">//写总共的位数</span>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;压缩成功!,可以到compression.txt中查看具体二进制码，压缩文件为 &quot;</span>&lt;&lt;decomFile &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-comment">//outComFile.seekg(0, ios::beg);</span>        <span class="hljs-comment">//streampos size = outComFile.tellg();</span>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;压缩文件大小为：&quot;</span> &lt;&lt; byteNum/<span class="hljs-number">8</span> &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        outComFile.<span class="hljs-built_in">close</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decompression</span><span class="hljs-params">(<span class="hljs-built_in">string</span> decomFilename, <span class="hljs-built_in">string</span> comfilename)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];        <span class="hljs-function">ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(comfilename, ios::out)</span></span>;        <span class="hljs-function">ifstream <span class="hljs-title">inComfile</span><span class="hljs-params">(decomFilename, ios::in)</span></span>;        <span class="hljs-keyword">if</span> (!outfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (!inComfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> bytenum;        inComfile.seekg(<span class="hljs-number">-2L</span>, ios::<span class="hljs-built_in">end</span>);        inComfile &gt;&gt; bytenum;        inComfile.seekg(<span class="hljs-number">0</span>, ios::beg);        <span class="hljs-keyword">int</span> codeNum;        inComfile &gt;&gt; codeNum;        <span class="hljs-keyword">char</span>* code = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];        <span class="hljs-keyword">char</span> ch;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">char</span>&gt; hash;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeNum; i++)        &#123;            inComfile &gt;&gt; ch;            inComfile &gt;&gt; code;            <span class="hljs-built_in">string</span> tmp = code;            hash[tmp] = ch;        &#125;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> m;        <span class="hljs-built_in">string</span> mystr = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (; bytenum &gt;= <span class="hljs-number">32</span>; bytenum -= <span class="hljs-number">32</span>)        &#123;            inComfile &gt;&gt; m;            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0x80000000</span>;            <span class="hljs-keyword">int</span> countForByte = <span class="hljs-number">32</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">if</span> (!(mask &amp; m))                    mystr.append(<span class="hljs-string">&quot;0&quot;</span>);                <span class="hljs-keyword">else</span>                    mystr.append(<span class="hljs-string">&quot;1&quot;</span>);                m = m &lt;&lt; <span class="hljs-number">1</span>;                countForByte--;                <span class="hljs-keyword">if</span> (hash.count(mystr))                &#123;                    outfile &lt;&lt; hash[mystr];                    mystr = <span class="hljs-string">&quot;&quot;</span>;                &#125;                <span class="hljs-keyword">if</span> (countForByte &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        inComfile &gt;&gt; m;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0x80000000</span>;        <span class="hljs-keyword">int</span> countForByte = bytenum;        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (!(mask &amp; m))                mystr.append(<span class="hljs-string">&quot;0&quot;</span>);            <span class="hljs-keyword">else</span>                mystr.append(<span class="hljs-string">&quot;1&quot;</span>);            m = m &lt;&lt; <span class="hljs-number">1</span>;            countForByte--;            <span class="hljs-keyword">if</span> (hash.count(mystr))            &#123;                outfile &lt;&lt; hash[mystr];                mystr = <span class="hljs-string">&quot;&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (countForByte &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;解压成功！解压文件为&quot;</span> &lt;&lt; comfilename&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">delete</span> code;        code = <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = tnod.length;        <span class="hljs-keyword">int</span> pare, child, start;        code = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>* [n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">char</span>* cd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];        cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            start = n - <span class="hljs-number">1</span>;            child = i;            pare = hafutree[i].parent;            <span class="hljs-keyword">while</span> (pare != <span class="hljs-number">0</span>)            &#123;                start--;                <span class="hljs-keyword">if</span> (child == hafutree[pare].lchild)                &#123;                    cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;                &#125;                child = pare;                pare = hafutree[child].parent;            &#125;            code[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n - start];            <span class="hljs-built_in">strcpy</span>(code[i], &amp;cd[start]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; tnod.data[i<span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-string">&quot;权重 : &quot;</span> &lt;&lt; tnod.num[i<span class="hljs-number">-1</span>];            <span class="hljs-built_in">cerr</span> &lt;&lt;<span class="hljs-string">&quot;二进制编码为&quot;</span>&lt;&lt; code[i] &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">delete</span> cd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initTnode</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        tnod.data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span>];        tnod.num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];        <span class="hljs-keyword">if</span> (tnod.data == <span class="hljs-literal">NULL</span> || tnod.num == <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        tnod.length = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Read</span><span class="hljs-params">( <span class="hljs-built_in">string</span> filename)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">char</span> ch;        <span class="hljs-function">ifstream <span class="hljs-title">infile</span><span class="hljs-params">(filename, ios::in)</span></span>;        <span class="hljs-keyword">if</span> (!infile)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span> (infile.<span class="hljs-built_in">peek</span>() != EOF)        &#123;            infile.<span class="hljs-built_in">get</span>(ch);            str.push_back(ch);        &#125;        infile.seekg(<span class="hljs-number">0</span>, ios::<span class="hljs-built_in">end</span>);        streampos <span class="hljs-built_in">size</span> = infile.tellg();        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;源文件大小为：&quot;</span> &lt;&lt; <span class="hljs-built_in">size</span> &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        infile.<span class="hljs-built_in">close</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ch, TNode t)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++)        &#123;            <span class="hljs-keyword">if</span> (t.data[i] == ch)            &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TNodeCount</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> m = str.<span class="hljs-built_in">size</span>(), j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> ch;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)        &#123;            ch = str[i];            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">find</span>(ch, tnod))            &#123;                tnod.data[j] = ch;                tnod.num[j] = count(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), ch);                tnod.length++;                j++;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HufumanTree&amp; tree, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>&amp; b, <span class="hljs-keyword">int</span>&amp; c)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> min1, min2, minweight = <span class="hljs-number">10000</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)        &#123;            <span class="hljs-keyword">if</span> (tree[i].parent == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (tree[i].weight &lt; minweight)                &#123;                    minweight = tree[i].weight;                    min1 = i;                &#125;            &#125;        &#125;        tree[min1].parent = <span class="hljs-number">1</span>;        minweight = <span class="hljs-number">10000</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)        &#123;            <span class="hljs-keyword">if</span> (tree[i].parent == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (tree[i].weight &lt; minweight)                &#123;                    minweight = tree[i].weight;                    min2 = i;                &#125;            &#125;        &#125;        tree[min2].parent = <span class="hljs-number">1</span>;        b = min1;        c = min2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = tnod.length;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;        hafutree = <span class="hljs-keyword">new</span> HafuNode[m + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<span class="hljs-comment">//为0表示没有左右节点，父节点</span>        &#123;            hafutree[i].lchild = <span class="hljs-number">0</span>;            hafutree[i].parent = <span class="hljs-number">0</span>;            hafutree[i].rchild = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            hafutree[i].weight = tnod.num[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span> s1, s2;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= m; i++)        &#123;            Select(hafutree, i - <span class="hljs-number">1</span>, s1, s2);            hafutree[s1].parent = i;            hafutree[s2].parent = i;            hafutree[i].lchild = s1;            hafutree[i].rchild = s2;            hafutree[i].weight = hafutree[s1].weight + hafutree[s2].weight;        &#125;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Hafuman  hafumanClass;    hafumanClass.initTnode();    <span class="hljs-built_in">string</span> command;    <span class="hljs-keyword">char</span> commandOpt;    <span class="hljs-built_in">string</span> comFile, deComFile;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;请输入选择的功能&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;1.压缩文件（SZip A  xx.haf test.txt（需要压缩的文件名）)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;2.解压文件（SZip X  xx.haf test1.txt(解压的文件名))&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cin</span> &gt;&gt; command;        <span class="hljs-built_in">cin</span> &gt;&gt; commandOpt;        <span class="hljs-keyword">if</span> (command != <span class="hljs-string">&quot;SZip&quot;</span>||(commandOpt!=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp; commandOpt != <span class="hljs-string">&#x27;X&#x27;</span>))        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;命令输入错误，请重新输入 &quot;</span> ;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">cin</span> &gt;&gt; deComFile &gt;&gt; comFile;        <span class="hljs-keyword">switch</span> (commandOpt)        &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:            hafumanClass.compression(deComFile, comFile);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:            hafumanClass.decompression(deComFile,comFile);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入错误！请重新输入&quot;</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>树</category>
      
      <category>压缩算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
      <tag>哈夫曼树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的后序遍历，先序遍历和层次遍历，中序遍历</title>
    <link href="/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/04/02/%E7%AE%97%E6%B3%95/%E6%A0%91/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。<br>而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。</p><p>所以方法有三种：</p><h3 id="开始的话，也是不停的往左子树走，然后直到为-null-，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶"><a href="#开始的话，也是不停的往左子树走，然后直到为-null-，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶" class="headerlink" title="开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶"></a>开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶</h3><h3 id="元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。"><a href="#元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。" class="headerlink" title="元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。"></a>元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。</h3><pre><code class="hljs lasso">class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root)     &#123;        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">Integer</span>&gt;();        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt;();        <span class="hljs-built_in">Set</span>&lt;TreeNode&gt; <span class="hljs-built_in">set</span>=<span class="hljs-literal">new</span> HashSet&lt;TreeNode&gt;();        TreeNode treenode=root;        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty()||treenode!=<span class="hljs-built_in">null</span>)        &#123;            <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-built_in">null</span>)            &#123;                <span class="hljs-built_in">stack</span>.push(treenode);                treenode=treenode.left;                   &#125;               <span class="hljs-keyword">else</span>            &#123;                TreeNode tmp=<span class="hljs-built_in">stack</span>.peek();                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">set</span>.contains(tmp)&amp;&amp;tmp.right!=<span class="hljs-built_in">null</span>)                &#123;                    treenode=tmp.right;                    <span class="hljs-built_in">set</span>.add(tmp);                &#125;                <span class="hljs-keyword">else</span>                &#123;                    res.add(tmp.val);                    <span class="hljs-built_in">stack</span>.pop();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h3 id="如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了"><a href="#如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了" class="headerlink" title="如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了"></a>如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了</h3><pre><code class="hljs routeros">class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root)     &#123;        List&lt;Integer&gt; <span class="hljs-attribute">res</span>=new ArrayList&lt;Integer&gt;();        Stack&lt;TreeNode&gt; <span class="hljs-attribute">stack</span>=new Stack&lt;TreeNode&gt;();        TreeNode <span class="hljs-attribute">treenode</span>=root;        TreeNode <span class="hljs-attribute">last</span>=<span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span>(!stack.isEmpty()||treenode!=<span class="hljs-literal">null</span>)        &#123;            <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-literal">null</span>)            &#123;                stack.push(treenode);                <span class="hljs-attribute">treenode</span>=treenode.left;                   &#125;               <span class="hljs-keyword">else</span>            &#123;                TreeNode <span class="hljs-attribute">tmp</span>=stack.peek();                <span class="hljs-keyword">if</span>(tmp.right!=<span class="hljs-literal">null</span>&amp;&amp;tmp.right!=last)                &#123;                    <span class="hljs-attribute">treenode</span>=tmp.right;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    res.<span class="hljs-builtin-name">add</span>(tmp.val);                    <span class="hljs-attribute">last</span>=tmp;                    stack.pop();                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h3 id="只需要把每个节点-push-两次，然后判断当前-pop-节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。"><a href="#只需要把每个节点-push-两次，然后判断当前-pop-节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。" class="headerlink" title="只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。"></a>只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。</h3><h3 id="不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到-list-中。这个方法比较巧妙"><a href="#不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到-list-中。这个方法比较巧妙" class="headerlink" title="不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙"></a>不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙</h3><pre><code class="hljs lasso">    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-built_in">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;    &#125;    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;        TreeNode cur = <span class="hljs-built_in">stack</span>.pop();        <span class="hljs-keyword">if</span> (cur == <span class="hljs-built_in">null</span>) &#123;            continue;        &#125;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">stack</span>.isEmpty() &amp;&amp; cur == <span class="hljs-built_in">stack</span>.peek()) &#123;            <span class="hljs-built_in">stack</span>.push(cur.right);            <span class="hljs-built_in">stack</span>.push(cur.right);            <span class="hljs-built_in">stack</span>.push(cur.left);            <span class="hljs-built_in">stack</span>.push(cur.left);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">list</span>.add(cur.val);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;&#125;</code></pre><h3 id="可以转换成一个逆的前序遍历来实现"><a href="#可以转换成一个逆的前序遍历来实现" class="headerlink" title="可以转换成一个逆的前序遍历来实现"></a>可以转换成一个逆的前序遍历来实现</h3><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">Integer</span>&gt;();    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt;();    TreeNode treenode=root;    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty()||treenode!=<span class="hljs-built_in">null</span>)    &#123;        <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-built_in">null</span>)        &#123;            res.add(treenode.val);            <span class="hljs-built_in">stack</span>.add(treenode);            treenode=treenode.right;         &#125;           <span class="hljs-keyword">else</span>        &#123;            treenode=<span class="hljs-built_in">stack</span>.pop().left;        &#125;    &#125;    Collections.reverse(res);    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>树</category>
      
      <category>后序遍历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下 c/c++线程锁种类有哪些？如何理解互斥锁、条件变量、读写锁以及自旋锁,原子操作，无锁编程 以及异步编程？</title>
    <link href="/2022/04/01/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/01/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<pre><code>   互斥锁是阻塞锁，当某线程无法获取互斥量时，该线程会被直接挂起，该线程不再消耗CPU时间，当其他线程释放互斥量后，操作系统会激活那个被挂起的线程，让其投入运行。</code></pre><p>临界区：每个进程中访问临界资源的那段程序称为临界区，每次只允许一个进程进入临界区，进入后不允许其他进程进入。</p><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>现象：</p><p>（1）单线程无锁速度最快，但应用场合受限；</p><p>（2）多线程无锁速度第二快，但结果不对，未保护临界代码段；</p><p>（3）多线程原子锁第三快，且结果正确；</p><p>（4）多线程互斥量较慢，慢与原子锁近10倍，结果正确；</p><p>（5）多线程自旋锁最慢，慢与原子锁30倍，结果正确。</p><p>结论：原子锁速度最快，互斥量和自旋锁都用保护多线程共享资源。</p><p>线程之间的锁有：互斥锁、条件锁、自旋锁、读写锁、递归锁(可重入锁)。一般而言，锁的功能越强大，性能就会越低。</p><h1 id="mutex-互斥锁"><a href="#mutex-互斥锁" class="headerlink" title="mutex(互斥锁)"></a>mutex(互斥锁)</h1><pre><code class="hljs sql">mutex（mutual exclusive）即互斥量（互斥体）。也便是常说的互斥锁。尽管名称不含<span class="hljs-keyword">lock</span>，但是称之为锁，也是没有太大问题的。<span class="hljs-keyword">mutex</span>无疑是最常见的多线程同步方式。其思想简单粗暴，多线程共享一个互斥量，然后线程之间去竞争。得到锁的线程可以进入临界区执行代码。<span class="hljs-keyword">mutex</span>是睡眠等待（<span class="hljs-keyword">sleep</span> waiting）类型的锁，当线程抢互斥锁失败的时候，线程会陷入休眠。优点就是节省CPU资源，缺点就是休眠唤醒会消耗一点时间。另外自从Linux <span class="hljs-number">2.6</span>版以后，<span class="hljs-keyword">mutex</span>完全用futex的API实现了，内部系统调用的开销大大减小。值得一提的是，pthread的锁一般都有一个trylock的函数，比如对于互斥量：pthread_mutex_trylock用于以非阻塞的模式来请求互斥量。就好比各种IO函数都有一个noblock的模式一样，对于加锁这件事也有类似的非阻塞模式。当线程尝试加锁时，如果锁已经被其他线程锁定，该线程就会阻塞住，直到能成功acquire。但有时候我们不希望这样。pthread_mutex_trylock在被其他线程锁定时，会返回特殊错误码。加锁成返回<span class="hljs-number">0</span>，仅当成功但时候，我们才能解锁在后面进行解锁操作！C++<span class="hljs-number">11</span>开始引入了多线程库&lt;<span class="hljs-keyword">thread</span>&gt;，其中也包含了互斥锁的API：<span class="hljs-keyword">std</span>::muxtex 。</code></pre><p>互斥锁可以分为可重入的以及不可重入的<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs sql"><span class="hljs-comment"># 可重入锁</span><br>此外，依据同一线程是否能多次加锁，把互斥锁又分为如下两类：</code></pre></p><p>是：称为『递归互斥量』recursive mutex ，也称『可重入锁』reentrant <span class="hljs-keyword">lock</span><br>否：即『非递归互斥量』non-<span class="hljs-keyword">recursive</span> mute），也称『不可重入锁』non-reentrant <span class="hljs-keyword">mutex</span></p><p>若同一线程对非递归的互斥量多次加锁，可能会造成死锁。递归互斥量则无此风险。C++<span class="hljs-number">11</span>中有递归互斥量的API：<span class="hljs-keyword">std</span>::recursive_mutex。对于pthread则可以通过给<span class="hljs-keyword">mutex</span>添加PTHREAD_MUTEX_RECURSIVE 属性的方式来使用递归互斥量</p><p>使用场景：<br>    一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法【即可重入】，而无需重新获得锁</p><pre><code>比如，&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;操作将会获取锁，若一个事务当中多次&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;，就应该允许该线程多次进入该临界区。</code></pre><p>可重入锁存在的问题<br>递归锁必须配合临界区的语义使用，解锁操作不仅不能在别的线程，而且绝对不能在reschedule放弃线程并在重新获得线程之后解锁。举例说明：</p><p>假设有一个单服务线程，<span class="hljs-keyword">lock</span>之后让出线程等待回调，线程此时服务于其它service，其它service也<span class="hljs-keyword">lock</span>同一个<span class="hljs-keyword">mutex</span>，此时本应互斥的操作就成了重入操作，在递归锁下不能互斥！换句话说，不同的服务，通过同一个线程实例获取到了同一个监视器资源。</p><p>这是非常刁钻的bug，实际可能会出现在线程池使用中，需要格外注意。</p><p>总结<br>可重入锁的优点：支持线程进入多个同步代码块，不容易造成死锁。<br>可重入锁的缺点：在非常刁钻的情况下，会出现监视器资源互斥失效的情况。&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><h1 id="condition-variable-条件变量"><a href="#condition-variable-条件变量" class="headerlink" title="condition variable(条件变量)"></a>condition variable(条件变量)</h1><pre><code class="hljs cpp">请注意条件变量不是锁，它是一种线程间的通讯机制，并且几乎总是和互斥量一起使用的。所以互斥量和条件变量二者一般是成套出现的。比如C++<span class="hljs-number">11</span>中也有条件变量的API：<span class="hljs-built_in">std</span>::condition_variable。可以使用<span class="hljs-built_in">std</span>::condition_variable cv</code></pre><h1 id="read-write-lock-读写锁"><a href="#read-write-lock-读写锁" class="headerlink" title="read-write lock(读写锁)"></a>read-write lock(读写锁)</h1><pre><code class="hljs awk">顾名思义『读写锁』就是对于临界区区分读和写。在读多写少的场景下，不加区分的使用互斥量显然是有点浪费的。此时便该上演读写锁的拿手好戏。但是在单读多写的情况，更为复杂的锁竞争，不在此章介绍，后面我会用单读的一章来介绍。读写锁有一个别称叫『共享-独占锁』。不过单看『共享-独占锁』或者『读写锁』这两个名称，其实并未区分对于读和写，到底谁共享，谁独占。可能会让人误以为读写锁是一种更为泛化的称呼，其实不是。读写锁的含义是准确的：是一种 读共享，写独占的锁。读写锁的特性：当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会阻塞（不是失败）。当读写锁被加了读锁时，其他线程对该锁加写锁会阻塞，加读锁会成功。因而适用于多读少写的场景。在C++<span class="hljs-number">17</span>中出现了一种读写锁：std::shared_mutex。用它可以模拟实现出读写锁。demo代码可以直接参考cppreference：https:<span class="hljs-regexp">//</span>en.cppreference.com<span class="hljs-regexp">/w/</span>cpp<span class="hljs-regexp">/thread/</span>shared_mutex</code></pre><h1 id="spinlock-自旋锁"><a href="#spinlock-自旋锁" class="headerlink" title="spinlock(自旋锁)"></a>spinlock(自旋锁)</h1><pre><code class="hljs mipsasm">       自旋锁是一种非阻塞锁，也就是说，如果某线程需要获取自旋锁，但该锁已经被其他线程占用时，该线程不会被挂起，而是在不断的消耗CPU的时间，不停的试图获取自旋锁。要了解自旋锁，首先了解自旋。什么是自旋（spin）呢？更为通俗的一个词是『忙等待』（<span class="hljs-keyword">busy </span><span class="hljs-keyword">waiting）。最最通俗的一个理解，其实就是死循环……。</span><span class="hljs-keyword"></span><span class="hljs-keyword">单看使用方法和使用互斥量的代码是差不多的。只不过自旋锁不会引起线程休眠。当共享资源的状态不满足的时候，自旋锁会不停地循环检测状态。因为不会陷入休眠，而是忙等待的方式也就不需要条件变量。</span><span class="hljs-keyword"></span><span class="hljs-keyword">这是优点也是缺点。不休眠就不会引起上下文切换，但是会比较浪费CPU。</span><span class="hljs-keyword"></span><span class="hljs-keyword">在多处理器环境中对持有锁时间较短的程序来说使用自旋锁代替一般的互斥锁往往能提高程序的性能</span></code></pre><p>pthread 自旋锁的使用<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs reasonml"><span class="hljs-comment">// 声明一个自旋锁变量</span><br>pthread_spinlock_t spinlock;</code></pre></p><p><span class="hljs-comment">// 初始化</span><br>pthread<span class="hljs-constructor">_spin_init(&amp;<span class="hljs-params">spinlock</span>, 0)&lt;/span&gt;;</span></p><p><span class="hljs-comment">// 加锁</span><br>pthread<span class="hljs-constructor">_spin_lock(&amp;<span class="hljs-params">spinlock</span>)&lt;/span&gt;;</span></p><p><span class="hljs-comment">// 解锁</span><br>pthread<span class="hljs-constructor">_spin_unlock(&amp;<span class="hljs-params">spinlock</span>)&lt;/span&gt;;</span></p><p><span class="hljs-comment">// 销毁</span><br>pthread<span class="hljs-constructor">_spin_destroy(&amp;<span class="hljs-params">spinlock</span>)&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</span></p><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p><a href="https://www.hiyu.space/2021/02/20/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/">原子操作与无锁编程</a></p><pre><code class="hljs dns">果数据结构本身就带有排他性访问的特性，也就相当于该数据结构自带一个细粒度的锁，对该数据结构的并发访问就能更加简单高效，这就是C++<span class="hljs-number">11</span>提供的原子数据类型&lt; atomic &gt;。下面解释两个概念：原子操作：顾名思义就是不可分割的操作，该操作只存在未开始和已完成两种状态，不存在中间状态；原子类型：原子库中定义的数据类型，对这些类型的所有操作都是原子的，包括通过原子类模板st<span class="hljs-number">d::</span>atomic&lt; T &gt;实例化的数据类型，也都是支持原子操作的。比如st<span class="hljs-number">d::</span>atomic&lt;int&gt; a<span class="hljs-comment">;</span>对原子类型的访问，最主要的就是读和写，但原子库提供的对应原子操作是load()与store(val)原子操作中的内存访问模型原子操作保证了对数据的访问只有未开始和已完成两种状态，不会访问到中间状态，但我们访问数据一般是需要特定顺序的，比如想读取写入后的最新数据，原子操作函数是支持控制读写顺序的，即带有一个数据同步内存模型参数st<span class="hljs-number">d::</span>memory_order，用于对同一时间的读写操作进行排序。C++<span class="hljs-number">11</span>定义的<span class="hljs-number">6</span>种类型如下：memory_order_relaxed: 宽松操作，没有同步或顺序制约，仅对此操作要求原子性；memory_order_release &amp; memory_order_acquire: 两个线程<span class="hljs-keyword">A</span>&amp;B，<span class="hljs-keyword">A</span>线程Release后，B线程Acquire能保证一定读到的是最新被修改过的值；这种模型更强大的地方在于它能保证发生在<span class="hljs-keyword">A</span>-Release前的所有写操作，在B-Acquire后都能读到最新值；memory_order_release &amp; memory_order_consume: 上一个模型的同步是针对所有对象的，这种模型只针对依赖于该操作涉及的对象：比如这个操作发生在变量a上，而s = a + b<span class="hljs-comment">; 那s依赖于a，但b不依赖于a; 当然这里也有循环依赖的问题，例如：t = s + 1，因为s依赖于a，那t其实也是依赖于a的；</span>memory_order_seq_cst: 顺序一致性模型，这是C++<span class="hljs-number">11</span>原子操作的默认模型；大概行为为对每一个变量都进行Release-Acquire操作，当然这也是一个最慢的同步模型；</code></pre><h1 id="使用原子操作实现无锁编程"><a href="#使用原子操作实现无锁编程" class="headerlink" title="使用原子操作实现无锁编程"></a>使用原子操作实现无锁编程</h1><p><a href="https://www.hiyu.space/2021/02/20/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B/">原子操作与无锁编程</a></p><p>详细示例可以参考链接<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs dns"><br>无锁编程是基于原子操作的，对基本原子类型的共享访问由load()与store(val)即可保证其并发同步，对抽象复杂类型的共享访问则需要更复杂的CAS来保证其并发同步，并发访问过程只是不使用锁机制了，但还是可以理解为有锁止行为的，其粒度很小，性能更高。对于某个无法实现为一个原子操作的并发访问过程还是需要借助锁机制来实现。</code></pre></p><p>CAS原子操作实现无锁编程<br>CAS原子操作主要是通过函数a.compare_exchange(expected,desired)实现的，其语义为“我认为V的值应该为<span class="hljs-keyword">A</span>，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”</p><p>CAS 看起来很厉害，但也有缺点，最著名的就是 ABA 问题，假设一个变量 <span class="hljs-keyword">A</span> ，修改为 B之后又修改为 <span class="hljs-keyword">A</span>，CAS 的机制是无法察觉的，但实际上已经被修改过了。如果在基本类型上是没有问题的，但是如果是引用类型呢？这个对象中有多个变量，我怎么知道有没有被改过？聪明的你一定想到了，加个版本号啊。每次修改就检查版本号，如果版本号变了，说明改过，就算你还是 <span class="hljs-keyword">A</span>，也不行。</p><p>上面的例子节点指针也属于引用类型，自然也存在ABA问题，比如在线程<span class="hljs-number">2</span>执行pop操作，将<span class="hljs-keyword">A</span>,B都删掉，然后创建一个新元素push进去，因为操作系统的内存分配机制会重复使用之前释放的内存，恰好push进去的内存地址和<span class="hljs-keyword">A</span>一样，我们记为<span class="hljs-keyword">A</span>’，这时候切换到线程<span class="hljs-number">1</span>，CAS操作检查到<span class="hljs-keyword">A</span>没变化成功将B设为栈顶，但B是一个已经被释放的内存块。该问题的解决方案就是上面说的通过打标签标识<span class="hljs-keyword">A</span>和<span class="hljs-keyword">A</span>’为不同的指针。&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p><a href="https://www.hiyu.space/2021/02/19/C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">多线程（四）-异步编程</a><br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript">同步：就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。</code></pre></p><p>异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p><p>方法<span class="hljs-number">1</span>：<br>使用全局变量与条件变量传递结果，即mutex 和条件变量</p><p>条件变量具有“通知–唤醒”功能，可以把执行结果或执行状态放入一个全局变量中，当被调用者执行完任务后，通过条件变量通知调用者结果或状态已更新，可以使用了。&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><pre><code class="hljs arduino">方法<span class="hljs-number">2</span>：使用promise与<span class="hljs-built_in">future</span>传递结果线程间传递的返回值或抛出的异常都是在共享状态中交流的。我们知道多线程间并发访问共享数据是需要保持同步的，这里的共享状态是保证返回值或异常在线程间正确传递的关键，被调用线程可以通过改变共享状态通知调用线程返回值或异常已写入完毕，可以访问或操作了。<span class="hljs-built_in">future</span>的状态（future_status）有以下三种：deferred：异步操作还没开始；<span class="hljs-built_in">ready</span>：异步操作已经完成；timeout：异步操作超时。既然线程间传递返回值或异常是通过共享状态进行的，就涉及到共享状态的提供方与获取方，只有该任务或线程拥有包含共享状态的对象，其他任务或线程才能够通过共享状态的通知机制同步获取到该任务或线程的返回值或异常。我们通常使用的&lt; thread &gt;创建线程并不拥有共享状态，我们需要为该线程提供一个共享状态，以便后续对其返回值或异常的访问。那么，怎么为一个线程提供一个包含共享状态的对象呢？这就需要借助<span class="hljs-built_in">std</span>::promise&lt; T &gt;类模板实现了，<span class="hljs-built_in">std</span>::promise&lt; T &gt;构造时，产生一个未就绪的共享状态（包含存储的T值和是否就绪的状态）。可设置T值，并让状态变为<span class="hljs-built_in">ready</span>。也可以通过产生一个<span class="hljs-built_in">future</span>对象获取到已就绪的共享状态中的T值。继续使用上面的程序示例，改为使用promise传递结果，值得注意的是，<span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt; T &gt;在多个线程等待时，只有一个线程能获取等待结果。当需要多个线程等待相同的事件的结果(即多处访问同一个共享状态)，需要用<span class="hljs-built_in">std</span>::shared_future&lt; T &gt;来替代<span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span> &lt; T &gt;，<span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span>&lt; T &gt;也提供了一个将<span class="hljs-built_in">future</span>转换为shared_future的方法f.share()，但转换后原<span class="hljs-built_in">future</span>状态失效。这有点类似于智能指针<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt; T &gt;与<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt; T &gt;的关系，使用时需要留心。</code></pre><pre><code class="hljs cpp">使用packaged_task与<span class="hljs-built_in">future</span>传递结果除了为一个任务或线程提供一个包含共享状态的变量，还可以直接把共享状态包装进一个任务或线程中。这就需要借助<span class="hljs-built_in">std</span>::packaged_task&lt; Func &gt;来实现了，<span class="hljs-built_in">std</span>::packaged_task&lt; Func &gt;构造时绑定一个函数对象，也产生一个未就绪的共享状态。通过thread启动或者仿函数形式启动该函数对象。但是相比promise，没有提供set_value()公用接口，而是当执行完绑定的函数对象，其执行结果返回值或所抛异常被存储于能通过 <span class="hljs-built_in">std</span>::<span class="hljs-built_in">future</span> 对象访问的共享状态中。继续使用上面的程序示例，改为使用packaged_task传递结果，</code></pre><pre><code class="hljs rust">使用<span class="hljs-keyword">async</span>传递结果前面介绍的std::promise&lt; T &gt;与std::packaged_task&lt; Func &gt;已经提供了较丰富的异步编程工具，但在使用时既需要创建提供共享状态的对象(promise与packaged_task)，又需要创建访问共享状态的对象(future与shared_future)，还是觉得使用起来不够方便。有没有更简单的异步编程工具呢？future头文件也确实封装了更高级别的函数std::<span class="hljs-keyword">async</span>，其具体用法如下：std::future std::<span class="hljs-keyword">async</span>(std::launch policy, Func, Args…)std::<span class="hljs-keyword">async</span>是一个函数而非类模板，其函数执行完后的返回值绑定给使用std::<span class="hljs-keyword">async</span>的std::futrue对象（std::<span class="hljs-keyword">async</span>其实是封装了thread,packged_task的功能，使异步执行一个任务更为方便）。Func是要调用的可调用对象(function, member function, function object, lambda)，Args是传递给Func的参数，std::launch policy是启动策略，它控制std::<span class="hljs-keyword">async</span>的异步行为，我们可以用三种不同的启动策略来创建std::<span class="hljs-keyword">async</span>：std::launch::<span class="hljs-keyword">async</span>参数 保证异步行为，即传递函数将在单独的线程中执行；std::launch::deferred参数 当其他线程调用get()/wait()来访问共享状态时，将调用非异步行为；std::launch::<span class="hljs-keyword">async</span> | std::launch::deferred参数 是默认行为(可省略)。有了这个启动策略，它可以异步运行或不运行，这取决于系统的负载。继续使用上面的程序示例，改为使用std::<span class="hljs-keyword">async</span>传递结果从上面的代码可以看出使用std::<span class="hljs-keyword">async</span>能在很大程度上简少编程工作量，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略。所以，我们可以使用std::<span class="hljs-keyword">async</span>替代线程的创建，让它成为我们做异步操作的首选。</code></pre><p><a href="http://www.kolhuang.top/posts/java-reentrantlock-pros-and-cons/">可重入锁参考</a></p><p><a href="https://lusaceg.com/index.php/2021/10/28/pthread_mutex/">Linux下 c/c++线程锁种类有哪些？如何理解互斥锁、条件变量、读写锁以及自旋锁？</a></p><p><a href="https://www.cnblogs.com/zhangbaochong/p/5879263.html">条件变量和信号量的区别</a></p><p><a href="https://www.shuzhiduo.com/A/n2d9WBDvJD/">条件变量和信号量的区别</a></p><p><a href="http://shouce.jb51.net/cpp_concurrency_in_action/content/chapter7/7.2-chinese.html">并发编程参考书籍</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>C++并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>互斥锁</tag>
      
      <tag>条件变量</tag>
      
      <tag>读写锁</tag>
      
      <tag>自旋锁</tag>
      
      <tag>原子操作</tag>
      
      <tag>无锁编程</tag>
      
      <tag>异步编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++类的内存大小计算</title>
    <link href="/2022/04/01/C++/C++%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97/"/>
    <url>/2022/04/01/C++/C++%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://aqzt.com/30521.html">C++类的内存大小计算</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git rebase 和git merge的区别</title>
    <link href="/2022/04/01/Git/Git%20rebase%20%E5%92%8CGit%20merge%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/04/01/Git/Git%20rebase%20%E5%92%8CGit%20merge%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://joyohub.com/2020/04/06/git-rebase/">【Git】：git rebase和git merge有什么区别？</a></p><p><a href="https://learngitbranching.js.org/?locale=zh_CN">一个学习git的游戏网站</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper脑裂</title>
    <link href="/2022/03/31/Zookeeper/zookeeper%E8%84%91%E8%A3%82/"/>
    <url>/2022/03/31/Zookeeper/zookeeper%E8%84%91%E8%A3%82/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/kevingrace/p/12433503.html">Zookeeper集群”脑裂”问题 - 运维总结</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常见的面试题</title>
    <link href="/2022/03/31/C++/C++%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/03/31/C++/C++%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/zhouchuyi/cpp-backend-reference/blob/master/back-end.md">c++ 后端开发面试题</a></p><p><a href="https://github.com/hehaoyulkeke/Interview#%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%9B%A2%E9%98%9Fmq%E7%BB%84%E5%86%85%E6%8E%A8%E5%AE%9E%E4%B9%A01%E9%9D%A2">师兄面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka 介绍和基本原理</title>
    <link href="/2022/03/31/Kafka/Kafka%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2022/03/31/Kafka/Kafka%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mikechen.cc/7299.html">kafka的基本原理，介绍以及应用场景</a></p><p><a href="https://www.jianshu.com/p/ea9121ee20b1">kafka概念与原理</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性一致性-顺序一致性-最终一致性</title>
    <link href="/2022/03/31/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2022/03/31/%E5%88%86%E5%B8%83%E5%BC%8F/%E7%BA%BF%E6%80%A7%E4%B8%80%E8%87%B4%E6%80%A7-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000022248118">共识、线性一致性与顺序一致性</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 堆和栈哪个运行速度快</title>
    <link href="/2022/03/30/C++/%E5%A0%86%E5%92%8C%E6%A0%88%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%93%AA%E4%B8%AA%E5%BF%AB/"/>
    <url>/2022/03/30/C++/%E5%A0%86%E5%92%8C%E6%A0%88%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E5%93%AA%E4%B8%AA%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="栈快"><a href="#栈快" class="headerlink" title="栈快"></a>栈快</h2><p>为什么<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript">栈由系统自动分配，速度较快。但程序员是无法控制的。<br>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。</code></pre></p><p>而且<br>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放<br>堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定</p><pre><code>  &lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;分配和释放，堆在分配和释放时都要调用函数（MALLOC,FREE)，比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成空洞），这些都会花费一定的时间，具体可以看看MALLOC和FREE的源代码，他们做了很多额外的工作，而栈却不需要这些。  &lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;访问时间，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。 &lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape--&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft算法的几种情况以及问题</title>
    <link href="/2022/03/29/%E5%88%86%E5%B8%83%E5%BC%8F/raft%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/29/%E5%88%86%E5%B8%83%E5%BC%8F/raft%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="关于Raft的一些面试题"><a href="#关于Raft的一些面试题" class="headerlink" title="关于Raft的一些面试题"></a>关于Raft的一些面试题</h2><h2 id="raft-prevote"><a href="#raft-prevote" class="headerlink" title="raft prevote"></a>raft prevote</h2><p>这个可以避免因为分区导致某个节点的任期一直增加，然后重新加入节点后导致重新发起选举扰乱集群，因为它的任期不是最新，不可能成为leader，此时可以引入prevote</p><p>Prevote（预投票）是一个类似于两阶段提交的协议，第一阶段先征求其他节点是否同意选举，如果同意选举则发起真正的选举操作，否则降为Follower角色。这样就避免了网络分区节点重新加入集群，触发不必要的选举操作。</p><h2 id="、Raft分为哪几个部分？"><a href="#、Raft分为哪几个部分？" class="headerlink" title="、Raft分为哪几个部分？"></a>、Raft分为哪几个部分？</h2><p>  主要是分为leader选举、日志复制、日志压缩、成员变更等。</p><h2 id="Raft中任何节点都可以发起选举吗？"><a href="#Raft中任何节点都可以发起选举吗？" class="headerlink" title="Raft中任何节点都可以发起选举吗？"></a>Raft中任何节点都可以发起选举吗？</h2><p>  Raft发起选举的情况有如下几种：</p><p>刚启动时，所有节点都是follower，这个时候发起选举，选出一个leader；</p><p>当leader挂掉后，时钟最先跑完的follower发起重新选举操作，选出一个新的leader。</p><p>成员变更的时候会发起选举操作。</p><h2 id="Raft中选举中给候选人投票的前提？"><a href="#Raft中选举中给候选人投票的前提？" class="headerlink" title="Raft中选举中给候选人投票的前提？"></a>Raft中选举中给候选人投票的前提？</h2><p>  Raft确保新当选的Leader包含所有已提交（集群中大多数成员中已提交）的日志条目。这个保证是在RequestVoteRPC阶段做的，candidate在发送RequestVoteRPC时，会带上自己的last log entry的term_id和index，follower在接收到RequestVoteRPC消息时，如果发现自己的日志比RPC中的更新，就拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term id更大，则更新，如果term id一样大，则日志更多的更大(index更大)。</p><h2 id="Raft网络分区下的数据一致性怎么解决？"><a href="#Raft网络分区下的数据一致性怎么解决？" class="headerlink" title="Raft网络分区下的数据一致性怎么解决？"></a>Raft网络分区下的数据一致性怎么解决？</h2><p>  发生了网络分区或者网络通信故障，使得Leader不能访问大多数Follwer了，那么Leader只能正常更新它能访问的那些Follower，而大多数的Follower因为没有了Leader，他们重新选出一个Leader，然后这个 Leader来接受客户端的请求，如果客户端要求其添加新的日志，这个新的Leader会通知大多数Follower。如果这时网络故障修复 了，那么原先的Leader就变成Follower，在失联阶段这个老Leader的任何更新都不能算commit（因为没有同步到大多数达成共识），都回滚，接受新的Leader的新的更新（递减查询匹配日志）。</p><h2 id="为-Raft-引入-leader-lease-机制解决集群脑裂时的-stale-read-问题"><a href="#为-Raft-引入-leader-lease-机制解决集群脑裂时的-stale-read-问题" class="headerlink" title="为 Raft 引入 leader lease 机制解决集群脑裂时的 stale read 问题"></a>为 Raft 引入 leader lease 机制解决集群脑裂时的 stale read 问题</h2><p>当 raft group 发生脑裂的情况下，老的 raft leader 可能在一段时间内并不知道新的 leader 已经被选举出来，这时候客户端在老的 leader 上可能会读取出陈旧的数据（stale read）。<br>比如，我们假想一个拥有 5 个节点的 raft group:</p><p>其中 Node 5 是当前的 raft leader，当出现网络分区时，在 Node 5 的 raft lease 任期还没结束的一段时间内，Node 5 仍然认为自己是当前 term 的 leader，但是此时，另外一边分区已经在新的 term 中选出了新的 leader。</p><p>如果此时，客户端在新的 leader 上更新了某个值 x，此时是可以更新成功的（因为还是可以复制到多数派）。但是在分区的另一端，此时一个客户端去读取 x 的值，Node 5 还会返回老的值，这样就发生了 stale read。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>引入一个新的概念, region leader。region leader 是一个逻辑上的概念, 任意时刻对于某一个 region 来说, 一定只拥有一个 region leader, 每个 region leader 在任期之内尝试每隔 t 时间间隔, 在 raft group 内部更新一下 region leader 的 lease. 所有的读写请求都必须通过 region leader 完成，<br>但是值得注意的是， region leader 和 raft leader 可能不是一个节点，当 region leader 和 raft leader 不重合的时候，region leader 会将请求转发给当前的 raft leader，当网络出现分区时，会出现以下几种情况：</p><p>region leader 落在多数派，老 raft leader 在多数派这边<br>region leader 落在多数派，老 raft leader 在少数派这边<br>region leader 落在少数派，老 raft leader 在多数派这边<br>region leader 落在少数派，老 raft leader 在少数派这边<br>用开篇的例子来分情况讨论：</p><p>对于第一种情况，region leader 的 lease 不会过期，因为 region leader 的心跳仍然能更新到多数派的节点上，老的 raft leader 仍然能同步到大多数节点上，少数派这边也不会选举出新的 leader， 这种情况下不会出现 stale read。</p><p>第二种情况，就是开篇提到会出现 stale read 的典型情况，老的 raft leader 被分到了少数派这边，多数派这边选举出了新的 raft leader ，如果此时的 region leader 在多数派这边。</p><p>因为所有的读写请求都会找到 region leader 进行，即使在原来没有出现网络分区的情况下，客户端的请求也都是要走 node 1 ，经由 node 1 转发给 node 5，客户端不会直接访问 node 5，所以此时即使网络出现分区，新 leader 也正好在多数派这边，读写直接就打到 node 1 上，皆大欢喜，没有 stale read。</p><p>第三种情况，region leader 落在少数派这边，老 raft leader 在多数派这边，这种情况客户端的请求找到 region leader，他发现的无法联系到 leader（因为在少数派这边没有办法选举出新的 leader），请求会失败，直到本次 region leader 的 lease 过期，同时新的 region leader 会在多数派那边产生（因为新的 region leader 需要尝试走一遍 raft 流程）。因为老的 region leader 没办法成功的写入，所以也不会出现 stale read。但是付出的代价是在 region leader lease 期间的系统的可用性。</p><p>第四种情况和第三种情况类似，多数派这边会产生新的 raft leader 和 region leader。这个时候如果多数派的region还没产生，那么只能联系到少数派的，读写数据不会不一致。如果一段时间之后旧的region leader超时，同时多数派中出现region，那么就只能读到多数派中的数据，只要不同时出现新旧区域都有region leader，就不会出现stale read的问题，而因为旧的region总是每隔t时间续租，联系不到大多数的时候就会过期，这个过期的之前只要多数派还没选出region就可以，这个只要把选region的时间间隔设置得大一点就可以。</p><p>而在raft中写总是一致的，因为要收到大多数的ack，才会commit，用region leader可以解决读不一致得问题。</p><h2 id="raft并不是线性一致性得"><a href="#raft并不是线性一致性得" class="headerlink" title="raft并不是线性一致性得"></a>raft并不是线性一致性得</h2><p>这里可以看一下etcd的保持线性一致性的方法（因为脑裂中可能出现两个leader，同时如何旧leader在少数派，新leader写入了数据，此时可能从旧leader那里读到旧数据）</p><p>mit6.824是线性一致性的，因为写肯定是一致性的，读也是要通过状态机提交之后才能返回的，如果脑裂了，那么也是一致性的</p><p><a href="https://keys961.github.io/2020/11/06/etcd-raft-7/">etcd-raft (7): Raft线性一致读</a></p><p><a href="https://zhuanlan.zhihu.com/p/31118381">etcd-raft的线性一致读方法二：LeaseRead</a></p><h2 id="基于raft的etcd的一些问题"><a href="#基于raft的etcd的一些问题" class="headerlink" title="基于raft的etcd的一些问题"></a>基于raft的etcd的一些问题</h2><p><a href="https://www.modb.pro/db/193588">关于 etcd 的一些谣言</a></p><h2 id="Raft-常见的一些问题"><a href="#Raft-常见的一些问题" class="headerlink" title="Raft 常见的一些问题"></a>Raft 常见的一些问题</h2><p><a href="https://zhuanlan.zhihu.com/p/266860228">Raft中 几种特殊情况分析（持续更新）（1-26日勘误）</a></p><p><a href="https://zhuanlan.zhihu.com/p/187506841">Raft算法相关工程问题以及解释</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘调度策略</title>
    <link href="/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/"/>
    <url>/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="http://c.biancheng.net/view/1289.html">磁盘调度策略</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>磁盘调度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pageCache 以及刷盘</title>
    <link href="/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/pageCache/"/>
    <url>/2022/03/29/%E6%95%B0%E6%8D%AE%E5%BA%93/pageCache/</url>
    
    <content type="html"><![CDATA[<p><a href="http://mysql.taobao.org/monthly/2020/09/01/">MySQL · 性能优化 · PageCache优化管理</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>pageCache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mmap</title>
    <link href="/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap/"/>
    <url>/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mmap/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.wangmenghua.com/2020/04/04/mmap%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%B5%81%E7%A8%8B/">mmap内存映射流程</a></p><p><a href="https://www.cnblogs.com/-citywall123/p/13526102.html">mmap文件映射过程</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>mmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis 分布式方案以及一致性hash算法</title>
    <link href="/2022/03/29/Redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/"/>
    <url>/2022/03/29/Redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.xiaojieboshi.com/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88%E5%8F%8A%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2.html"> redis 分布式方案以及一致性hash算法</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cap理论</title>
    <link href="/2022/03/29/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E7%90%86%E8%AE%BA/"/>
    <url>/2022/03/29/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.lllpan.top/article/66">分布式之CAP原则详解</a> </p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>CAP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程间8种通信方式详解</title>
    <link href="/2022/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1690556">进程间8种通信方式详解</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程协程调度</title>
    <link href="/2022/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2022/03/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/Survivalist/p/11527949.html">一文读懂什么是进程、线程、协程 </a></p><p><a href="https://www.cnblogs.com/secondtonone1/p/11803961.html">图解Go协程调度原理，小白都能理解 </a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interface 如何判断类型</title>
    <link href="/2022/03/24/GO/Interface%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AE%83%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/03/24/GO/Interface%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AE%83%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>interface.(type)可以判断类型</p><p><a href="https://www.cnblogs.com/techflow/p/13474641.html">可以参考的文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>interface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志型key/value存储模型 Bitcask</title>
    <link href="/2022/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%97%A5%E5%BF%97%E5%9E%8Bkeyvalue%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%20Bitcask/"/>
    <url>/2022/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%97%A5%E5%BF%97%E5%9E%8Bkeyvalue%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%20Bitcask/</url>
    
    <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1083737">日志型key/value存储模型 Bitcask参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bitcask</tag>
      
      <tag>kv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO的并发安全吗</title>
    <link href="/2022/03/24/GO/GO%20%E7%9A%84map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%90%97/"/>
    <url>/2022/03/24/GO/GO%20%E7%9A%84map%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E5%90%97/</url>
    
    <content type="html"><![CDATA[<p>不是安全的，可以用Sync.Map来替换，或者使用同步机制，加sync.RWLock<br>读的时候加读锁，写的时候加写锁。</p><p><a href="https://www.cnblogs.com/peteremperor/p/14469710.html">详细内容可以参考这篇文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>GO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>map</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC相关</title>
    <link href="/2022/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/RPC%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/03/24/%E5%88%86%E5%B8%83%E5%BC%8F/RPC%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000011891865">golang中的net/rpc包使用概述</a></p><p><a href="https://juejin.cn/post/6844903801044860935">RPC的基本的原理可以看这里</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql redo log undo log binlog 区别</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql_redo_undo_binlog%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql_redo_undo_binlog%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6987557227074846733">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql一行是如何存储的</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%80%E8%A1%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%80%E8%A1%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.songbingjia.com/nginx/show-164330.html">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql写入数据的流程</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000022315340">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql各种锁和MVCC</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%90%84%E7%A7%8D%E9%94%81%E5%92%8CMVCC/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%90%84%E7%A7%8D%E9%94%81%E5%92%8CMVCC/</url>
    
    <content type="html"><![CDATA[<p>MySQL中的锁<br>主要分为三类<br><pre><code class="hljs markdown">表锁：<span class="hljs-code">    读锁：多个读可并发</span><span class="hljs-code">    写锁：当前写未提交事务之前，会阻塞其他写和读的进程</span><span class="hljs-code"></span><span class="hljs-code">行锁：</span><span class="hljs-code">    共享锁：允许一个事务读一行，而阻止其他事务获得相同的排他锁</span><span class="hljs-code">    排他锁：允许获得排他锁的事务更新数据，阻止其他事务获得共享锁和排他锁</span><span class="hljs-code">    意向共享锁（IS）：一个事务给一个数据行加共享锁时，必须先获得意向共享锁</span><span class="hljs-code">    意向排他锁(IX)：一个事务给一个数据行加排他锁时，必须先获得意向排他锁</span><span class="hljs-code"></span><span class="hljs-code">页锁:</span></code></pre></p><p>提到锁到种类,需要提一下MySQL到存储引擎,MySQL常用引擎有MyISAM和InnoDB，而InnoDB是mysql默认的引擎。MyISAM是不支持行锁的，而InnoDB支持行锁和表锁。</p><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁,读锁会阻塞对同一张表对写操作,而写锁既会阻塞对同一张表对写操作,也会阻塞读操作.</p><p>对于InnoDB来说,大家都知道InnoDB相对与MyISAM,支持了事务和行锁.而行锁顾名思义,就是针对具体某一行数据上的锁,更切确的说是针对索引加的锁(这个会在下文锁的实现中讲到).</p><p>排他锁,通常我们在InnoDB中执行一个更新操作,针对这一行数据会持有排他锁,持有排他锁时,不允许再在数据行上添加写锁与读锁,其他事务对此行数据的读、写操作都会被阻塞,只有当前事务提交了,锁释放了才允许其他事务进行读写,达到避免 脏读 的效果<br>共享锁,主要是为了支持并发的读取数据而出现的，当一个事务持有某一数据行的共享锁时,允许其它事务再获取共享锁,但不允许其它事务获取排他锁，也就是说,在持有共享锁时,多个事务可以读取当前数据,但不不允许任何事务对当前数据进行修改操作，从而避免 不可重复 的问题</p><p>意向锁,首先需要明白一点,意向锁的作用是在表上的,当一个事务需要获取共享锁或排他锁时,首先要获取对应的意向锁,为什么要这样做呢,举个例子,假设在事务A中,某一行数据持有共享锁,这一行只能读,不能写.此时事务B申请获得表的写锁,假如加锁成功,那么事务B将能够对整个表的数据进行读写,与事务A冲突.这种操作肯定是不允许的,所以MySQL会在申请共享锁或者排他锁的时候,先获取对应的意向锁,也就是说,你要操作表中的某一行锁数据,先要看看整个表能不能被操作.意向锁的申请是有数据库完成的,不需要人为申请.</p><h2 id="行锁的3种实现"><a href="#行锁的3种实现" class="headerlink" title="行锁的3种实现"></a>行锁的3种实现</h2><p>上文对几种锁类型进行了分析,其实平时开发中接触到最多的还是行锁,行锁的实现有以下几种<br><pre><code class="hljs sql">行锁分为：    Record <span class="hljs-keyword">Lock</span>记录锁：针对单个行记录得锁    Gap <span class="hljs-keyword">Lock</span>间隙锁：锁定一个范围    <span class="hljs-keyword">Next</span>-<span class="hljs-keyword">Key</span> <span class="hljs-keyword">Lock</span>：<span class="hljs-built_in">Record</span> <span class="hljs-keyword">Lock</span>和Gap <span class="hljs-keyword">Lock</span>的并集</code></pre><br>在InnoDB中,锁的实现是基于索引的</p><p>Record Lock(记录锁),会锁住索引记录,比如 update table where id = 1;,会是这种实现</p><p>Gap Lock(间隙锁),实质上是对索引前后的间隙上锁，不对索引本身上锁,目的是为了防止幻读.当使用范围条件而不是相等条件检索数据并请求排他锁、或共享锁时,对于该范围内不存在的记录,不允许其修改插入.举个例子,当表中只有一条id=101的记录,一个事务执行select * from  user where user_id &gt; 100 for update;,此时另一个事务执行插入一条id=102的数据是会阻塞的,必须等待第一个事务提交后才能完成.间隙锁是针对事务隔离级别为可重复读或以上级别</p><p>Next-Key Lock,是记录锁和间隙锁对结合,会同时锁住记录与间隙.在可重复读(Repeatable Read)隔离级别下，会以Next-Key Lock的方式对数据行进行加锁</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>锁机制可以控制并发操作,来保证一致性,但是系统开销会很大.在RC、RR的隔离级别下,MySQL InnoDB通过MVCC (多版本并发控制)机制来解决幻读,使事务在并发过程中,SELECT 操作不用加锁，读写不冲突从而提高性能.其原理是通过保存数据在某个时间点的快照来实现的.通过在每行记录后面保存隐藏列来存放事务ID,这样每一个事务,都会对应一个递增的事务ID.假设三个事务同时更新来同一行数据,那么就会对应三个数据版本,但实际上版本1、版本2并不是物理存在的,而是通过关联记录在undo log中,这样就可以通过undo log找回数据的历史版本,比如回滚的操作,会使用上一个版本的数据覆盖数据页上的数据</p><p>下面举例一个RR隔离级别下快照读的</p><p>例子1:开启事务A按条件A查询到两条数据,此时事务B再插入1条数据满足条件A的数据,并提交事务,此时事务A再按条件A进行查询,查询到的依然是两条数据,也就是说,事务A查询到的并不是当前最新的数据版本,而是通过MVCC实现的历史快照版本.这也是可重复读的实现.<strong>快照读</strong></p><p>上面的例子介绍了读操作,那么写操作呢,也是如此事务之间互不干扰吗.再举例一个RR隔离级别下更新操作的</p><p>例子2:假设事务A执行一个更新语句,满足更新条件A的的数据是2条,更新成功后不提交事务,此时事务B插入一条新的满足条件A的数据,此时事务A再按条件A去更新数据,实验发现事务B新插入的数据也被更新了.出现了幻读,这就是<strong>当前读</strong>,即对数据修改的操作(update、insert、delete)都会读到已提交事务的最新数据.</p><p>那么当前读的幻读问题如何解决呢?MVCC不能解决的问题当然是交给锁来解决了.上文提到的Next-Key Lock正是解决这个问题的方法,还以上面的例子2为例,给条件A字段非唯一索引,事务B进行插入数据的时候就会被阻塞,原因是事务A持有了Gap Lock,只有事务A提交了,事务B才能成功插入数据.这就解决了当前读操作下的幻读问题.</p><p>所以MVCC机制可防止快照读引起的幻读，next-key锁可防止当前读引起的幻读.需要说明的是,MVCC只在RC和RR两个隔离级别下工作。其他两个隔离级别和MVCC不兼容, 因为 RU总是读取最新的数据行, 而不是符合当前事务版本的数据行.而SERIALIZABLE 则会对所有读取的行都加锁.</p><h2 id="锁的触发和升级"><a href="#锁的触发和升级" class="headerlink" title="锁的触发和升级"></a>锁的触发和升级</h2><p>以默认的InnoDB引擎RR级别说明,表锁可以理解为每一行记录都持有Record Lock,更新记录时,当更新字段没有走索引时,无法获取对应记录的Record Lock,行锁便会升级为表锁,这一点可以结合MySQL Explain去分析.需要注意的是当普通索引值区分度低时，此时观察Explain显示是走了索引的,但当另一个事务并发操作不同数据时,依然发现第二个事务会阻塞,这是因为MySQL的执行优化器认为给多行记录一次一次当加锁不如表锁来的高效,所以不会把这个普通索引当做索引,而当区分度高时,则认为是高效的,不会升级为表锁.所以,创建合适的索引很重要,区分度低的字段不建议创建索引.</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MVCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql数据大量写入的问题</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%A4%A7%E9%87%8F%E5%86%99%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%A4%A7%E9%87%8F%E5%86%99%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>今天这里主要给大家介绍，在有大量写入的场景，进行优化的方案。</p><p>总的来说MYSQL数据库写入性能主要受限于数据库自身的配置，以及操作系统的性能，磁盘IO的性能。主要的优化手段包括以下几点：</p><h1 id="1、调整数据库参数"><a href="#1、调整数据库参数" class="headerlink" title="1、调整数据库参数"></a>1、调整数据库参数</h1><h2 id="（1）-innodb-flush-log-at-trx-commit"><a href="#（1）-innodb-flush-log-at-trx-commit" class="headerlink" title="（1） innodb_flush_log_at_trx_commit"></a>（1） innodb_flush_log_at_trx_commit</h2><p>默认为1，这是数据库的事务提交设置参数，可选值如下：</p><p>0: 日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新，但是在一个事务提交不做任何操作。</p><p>1：在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新。</p><p>2：在每个提交，日志缓冲被写到文件，但不对日志文件做到磁盘操作的刷新。对日志文件每秒刷新一次。</p><p>有人会说如果改为不是1的值会不会不安全呢？ 安全性比较如下：</p><p>在 mysql 的手册中，为了确保事务的持久性和一致性，都是建议将这个参数设置为 1 。出厂默认值是 1，也是最安全的设置。</p><p>当innodb_flush_log_at_trx_commit和sync_binlog 都为 1 时是最安全的，在mysqld 服务崩溃或者服务器主机crash的情况下，binary log 只有可能丢失最多一个语句 或者一个事务。</p><p>但是这种情况下，会导致频繁的io操作，因此该模式也是最慢的一种方式。</p><p>当innodb_flush_log_at_trx_commit设置为0，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。<br>当innodb_flush_log_at_trx_commit设置为2，只有在操作系统崩溃或者系统掉电的情况下，上一秒钟所有事务数据才可能丢失。<br>针对同一个表通过c#代码按照系统业务流程进行批量插入，性能比较如下所示：</p><p>（a.相同条件下：innodb_flush_log_at_trx_commit=0，插入50W行数据所花时间25.08秒;<br>（b.相同条件下：innodb_flush_log_at_trx_commit=1，插入50W行数据所花时间17分21.91秒;<br>（c.相同条件下：innodb_flush_log_at_trx_commit=2，插入50W行数据所花时间1分0.35秒。<br>结论：设置为0的情况下，数据写入是最快的，能迅速提升数据库的写入性能， 但有可能丢失上1秒的数据。</p><h2 id="（2-temp-table-size-heap-table-size"><a href="#（2-temp-table-size-heap-table-size" class="headerlink" title="（2) temp_table_size,heap_table_size"></a>（2) temp_table_size,heap_table_size</h2><p>这两个参数主要影响临时表temporary table 以及内存数据库引擎memory engine表的写入，设置太小，甚至会出现table is full的报错信息.</p><p>要根据实际业务情况设置大于需要写入的数据量占用空间大小才行。</p><h2 id="（3-max-allowed-packet-256M-net-buffer-length-16M，set-autocommit-0"><a href="#（3-max-allowed-packet-256M-net-buffer-length-16M，set-autocommit-0" class="headerlink" title="（3) max_allowed_packet=256M,net_buffer_length=16M，set autocommit=0"></a>（3) max_allowed_packet=256M,net_buffer_length=16M，set autocommit=0</h2><p>备份和恢复时如果设置好这三个参数,可以让你的备份恢复速度飞起来哦！</p><h2 id="（4-innodb-data-file-path-ibdata1-1G-ibdata2-64M-autoextend"><a href="#（4-innodb-data-file-path-ibdata1-1G-ibdata2-64M-autoextend" class="headerlink" title="（4) innodb_data_file_path=ibdata1:1G;ibdata2:64M:autoextend"></a>（4) innodb_data_file_path=ibdata1:1G;ibdata2:64M:autoextend</h2><p>很显然表空间后面的autoextend就是让表空间自动扩展，不够默认情况下只有10M，而在大批量数据写入的场景，不妨把这个参数调大；</p><p>让表空间增长时一次尽可能分配更多的表空间，避免在大批量写入时频繁的进行文件扩容</p><h2 id="（5-innodb-log-file-size-innodb-log-files-in-group-innodb-log-buffer-size"><a href="#（5-innodb-log-file-size-innodb-log-files-in-group-innodb-log-buffer-size" class="headerlink" title="（5) innodb_log_file_size,innodb_log_files_in_group,innodb_log_buffer_size"></a>（5) innodb_log_file_size,innodb_log_files_in_group,innodb_log_buffer_size</h2><p>设置事务日志的大小，日志组数，以及日志缓存。默认值很小，innodb_log_file_size默认值才几十M，innodb_log_files_in_group默认为2。</p><p>然而在innodb中，数据通常都是先写缓存，再写事务日志，再写入数据文件。设置太小，在大批量数据写入的场景，必然会导致频繁的触发数据库的检查点，去把 日志中的数据写入磁盘数据文件。频繁的刷新buffer以及切换日志，就会导致大批量写入数据性能的降低。</p><p>当然，也不宜设置过大。过大会导致数据库异常宕机时，数据库重启时会去读取日志中未写入数据文件的脏数据，进行redo，恢复数据库，太大就会导致恢复的时间变的更长。当恢复时间远远超出用户的预期接受的恢复时间，必然会引起用户的抱怨。</p><p>这方面的设置倒可以参考华为云的数据库默认设置,在华为云2核4G的环境，貌似默认配置的buffer:16M,log_file_size:1G——差不多按照mysql官方建议达到总内存的25%了；而日志组files_in_group则设置为4组。</p><p>2核4G这么低的硬件配置，由于参数设置的合理性，已经能抗住每秒数千次，每分钟8万多次的读写请求了。</p><p>而假如在写入数据量远大于读的场景，或者说方便随便改动参数的场景，可以针对大批量的数据导入，再做调整，把log_file_size调整的更大，可以达到innodb_buffer_pool_size的25%~100%。</p><h2 id="（6-innodb-buffer-pool-size设置MySQL-Innodb的可用缓存大小。理论上最大可以设置为服务器总内存的80"><a href="#（6-innodb-buffer-pool-size设置MySQL-Innodb的可用缓存大小。理论上最大可以设置为服务器总内存的80" class="headerlink" title="（6) innodb_buffer_pool_size设置MySQL Innodb的可用缓存大小。理论上最大可以设置为服务器总内存的80%."></a>（6) innodb_buffer_pool_size设置MySQL Innodb的可用缓存大小。理论上最大可以设置为服务器总内存的80%.</h2><p>设置越大的值，当然比设置小的值的写入性能更好。比如上面的参数innodb_log_file_size就是参考innodb_buffer_pool_size的大小来设置的。</p><h2 id="（7-innodb-thread-concurrency-16"><a href="#（7-innodb-thread-concurrency-16" class="headerlink" title="（7) innodb_thread_concurrency=16"></a>（7) innodb_thread_concurrency=16</h2><p>故名思意，控制并发线程数，理论上线程数越多当然会写入越快。当然也不能设置过大官方建议是CPU核数的两倍左右最合适。</p><h2 id="（8-write-buffer-size"><a href="#（8-write-buffer-size" class="headerlink" title="（8) write_buffer_size"></a>（8) write_buffer_size</h2><p>控制单个会话单次写入的缓存大小，默认值4K左右，一般可以不用调整。然而在频繁大批量写入场景，可以尝试调整为2M，你会发现写入速度会有一定的提升。</p><h2 id="（9-innodb-buffer-pool-instance"><a href="#（9-innodb-buffer-pool-instance" class="headerlink" title="（9) innodb_buffer_pool_instance"></a>（9) innodb_buffer_pool_instance</h2><p>默认为1，主要设置内存缓冲池的个数，简单一点来说，是控制并发读写innodb_buffer_pool的个数。</p><p>在大批量写入的场景，同样可以调大该参数，也会带来显著的性能提升。</p><h2 id="（10-bin-log"><a href="#（10-bin-log" class="headerlink" title="（10) bin_log"></a>（10) bin_log</h2><p>二进制日志，通常会记录数据库的所有增删改操作。然而在大量导数据，比如数据库还原的时候不妨临时关闭bin_log,关掉对二进制日志的写入，让数据只写入数据文件，迅速完成数据恢复，完了再开启吧。</p><h2 id="2、减少磁盘IO，提高磁盘读写效率"><a href="#2、减少磁盘IO，提高磁盘读写效率" class="headerlink" title="2、减少磁盘IO，提高磁盘读写效率"></a>2、减少磁盘IO，提高磁盘读写效率</h2><p>包括如下方法：</p><h2 id="（1-：数据库系统架构优化"><a href="#（1-：数据库系统架构优化" class="headerlink" title="（1)：数据库系统架构优化"></a>（1)：数据库系统架构优化</h2><p>a：做主从复制；</p><p>比如部署一个双主从，双主从模式部署是为了相互备份，能保证数据安全，不同的业务系统连接不同的数据库服务器，结合ngnix或者keepalive自动切换的功能实现负载均衡以及故障时自动切换。</p><p>通过这种架构优化，分散业务系统的并发读写IO从一台服务器到多台服务器，同样能提高单台数据库的写入速度。</p><p>b：做读写分离</p><p>和1中要考虑的问题一样，可以减轻单台服务器的磁盘IO，还可以把在服务器上的备份操作移到备服务器，减轻主服务器的IO压力，从而提升写入性能。</p><h2 id="（2-：硬件优化"><a href="#（2-：硬件优化" class="headerlink" title="（2)：硬件优化"></a>（2)：硬件优化</h2><p>a: 在资源有限的情况下，安装部署的时候，操作系统中应有多个磁盘，把应用程序，数据库文件，日志文件等分散到不同的磁盘存储，减轻每个磁盘的IO，从而提升单个磁盘的写入性能。</p><p>b：采用固态硬盘SSD</p><p>如果资源足够可以采用SSD存储，SSD具有高速写入的特性，同样也能显著提升所有的磁盘IO操作。</p><p>当然还有更多的硬件或者软件优化方法，这里就不一一列举了。</p><p><a href="https://zhuanlan.zhihu.com/p/341686785">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>间隙锁</title>
    <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%97%B4%E9%9A%99%E9%94%81/"/>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/%E9%97%B4%E9%9A%99%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h1><p>当我们用范围条件而不是相等条件索引数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项枷锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP）”。</p><p>InnoDB也会对这个“间隙”枷锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><h1 id="间隙锁的危害"><a href="#间隙锁的危害" class="headerlink" title="间隙锁的危害"></a>间隙锁的危害</h1><p>因为Query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，也造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><h1 id="间隙锁与死锁"><a href="#间隙锁与死锁" class="headerlink" title="间隙锁与死锁"></a>间隙锁与死锁</h1><p>最近用户反馈说系统老是出现insert时，等待超时了，最后发现是insert间隙锁！间隙锁是innodb中行锁的一种， 但是这种锁锁住的却不止一行数据，他锁住的是多行，是一个数据范围。间隙锁的主要作用是为了防止出现幻读，但是它会把锁定范围扩大，</p><p>有时候也会给我们带来麻烦，我们就遇到了。 在数据库参数中， 控制间隙锁的参数是：</p><p>innodb_locks_unsafe_for_binlog，</p><p>这个参数默认值是OFF， 也就是启用间隙锁， 他是一个bool值， 当值为true时表示disable间隙锁。</p><p>那为了防止间隙锁是不是直接将innodb_locaks_unsafe_for_binlog设置为true就可以了呢？ 不一定！</p><p>而且这个参数会影响到主从复制及灾难恢复， 这个方法还尚待商量。</p><p>间隙锁的出现主要集中在同一个事务中先delete后 insert的情况下， 当我们通过一个参数去删除一条记录的时候， </p><p>如果参数在数据库中存在，那么这个时候产生的是普通行锁，锁住这个记录， 然后删除， 然后释放锁。如果这条记录不存在，</p><p>问题就来了， 数据库会扫描索引，发现这个记录不存在， 这个时候的delete语句获取到的就是一个间隙锁，然后数据库会向左扫描扫到第一个比给定参数小的值，向右扫描扫描到第一个比给定参数大的值， 然后以此为界，构建一个区间， 锁住整个区间内的数据， 一个特别容易出现死锁的间隙锁诞生了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>间隙锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务的隔离级别</title>
    <link href="/2022/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <url>/2022/03/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="事务并发可能出现的情况"><a href="#事务并发可能出现的情况" class="headerlink" title="事务并发可能出现的情况"></a>事务并发可能出现的情况</h2><h2 id="脏读（Dirty-Read）"><a href="#脏读（Dirty-Read）" class="headerlink" title="脏读（Dirty Read）"></a>脏读（Dirty Read）</h2><p>一个事务读到了另一个未提交事务修改过的数据</p><pre><code class="hljs applescript">会话B开启一个事务，把<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的<span class="hljs-built_in">name</span>为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的<span class="hljs-built_in">name</span>，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）</code></pre><h2 id="不可重复读（Non-Repeatable-Read）"><a href="#不可重复读（Non-Repeatable-Read）" class="headerlink" title="不可重复读（Non-Repeatable Read）"></a>不可重复读（Non-Repeatable Read）</h2><p>一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）<br><pre><code class="hljs applescript">会话A开启一个事务，查询<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的结果，此时查询的结果<span class="hljs-built_in">name</span>为武汉市。接着会话B把<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的<span class="hljs-built_in">name</span>修改为温州市（隐式事务，因为此时的autocommit为<span class="hljs-number">1</span>，每条SQL语句执行完自动提交），此时会话A的事务再一次查询<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的结果，读取的结果<span class="hljs-built_in">name</span>为温州市。会话B再此修改<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>的<span class="hljs-built_in">name</span>为杭州市，会话A的事务再次查询<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>，结果<span class="hljs-built_in">name</span>的值为杭州市，这种现象就是不可重复读。</code></pre></p><h1 id="幻读（Phantom）"><a href="#幻读（Phantom）" class="headerlink" title="幻读（Phantom）"></a>幻读（Phantom）</h1><p>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入或者删除了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）</p><pre><code class="hljs applescript">会话A开启一个事务，查询<span class="hljs-built_in">id</span>&gt;<span class="hljs-number">0</span>的记录，此时会查到<span class="hljs-built_in">name</span>=武汉市的记录。接着会话B插入一条<span class="hljs-built_in">name</span>=温州市的数据（隐式事务，因为此时的autocommit为<span class="hljs-number">1</span>，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（<span class="hljs-built_in">id</span>&gt;<span class="hljs-number">0</span>）再一次查询，此时会出现两条记录（<span class="hljs-built_in">name</span>为武汉市和温州市的记录），这种现象就是幻读。</code></pre><p>不可重复读出现多是因为修改；幻读重点是新增、删除。mysql中的REPEATABLE_READ模式引入了间隙锁（GAP），解决了幻读的问题。</p><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><pre><code class="hljs plain">MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。</code></pre><h1 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h1><pre><code class="hljs dns">在读未提交隔离级别下，事务<span class="hljs-keyword">A</span>可以读取到事务B修改过但未提交的数据。可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。</code></pre><h1 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h1><pre><code class="hljs dns">在读已提交隔离级别下，事务B只能在事务<span class="hljs-keyword">A</span>修改过并且已提交后才能读取到事务B修改的数据。读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。</code></pre><h1 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h1><pre><code class="hljs angelscript">在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。为什么解决了不可重复读呢，因为如果自己的事务没提交就算对方事务提交了，也不能读到对方修改的数据。但是为什么没解决幻读的问题呢，因为幻读出现的场景：<span class="hljs-number">1</span>、如果事务中都是用快照读，那么不会产生幻读的问题<span class="hljs-number">2</span>、快照读和当前读一起使用的时候就会产生幻读而正常采用的不是快照读提问：为什么上了写锁（写操作），别的事务还可以读操作？因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。使用间隙锁可以避免当前读情况下的幻读</code></pre><h1 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h1><pre><code class="hljs plain">各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</code></pre><pre><code class="hljs vim">隔离级别的实现原理使用MySQL的默认隔离级别（可重复读）来进行说明。每条记录在更新的时候都会同时记录一条回滚操作（回滚操作日志<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span>）。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。即通过回滚（rollback操作），可以回到前一个状态的值。假设一个值从 <span class="hljs-number">1</span> 被按顺序改成了 <span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>，在回滚日志里面就会有类似下面的记录。当前值是 <span class="hljs-number">4</span>，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 <span class="hljs-keyword">read</span>-<span class="hljs-keyword">view</span>。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">4</span>，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 <span class="hljs-keyword">read</span>-<span class="hljs-keyword">view</span> A，要得到 <span class="hljs-number">1</span>，就必须将当前值依次执行图中所有的回滚操作得到。同时你会发现，即使现在有另外一个事务正在将 <span class="hljs-number">4</span> 改成 <span class="hljs-number">5</span>，这个事务跟 <span class="hljs-keyword">read</span>-<span class="hljs-keyword">view</span> A、B、C 对应的事务是不会冲突的。提问：回滚操作日志（<span class="hljs-keyword">undo</span> <span class="hljs-built_in">log</span>）什么时候删除？MySQL会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。提问：什么时候不需要了？当系统里么有比这个回滚日志更早的<span class="hljs-keyword">read</span>-<span class="hljs-keyword">view</span>的时候。</code></pre><p><a href="https://developer.aliyun.com/article/743691">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>隔离级别</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>io read/write on closed pipe</title>
    <link href="/2022/03/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/io%20read%20write%20on%20closed%20pipe/"/>
    <url>/2022/03/23/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/io%20read%20write%20on%20closed%20pipe/</url>
    
    <content type="html"><![CDATA[<p>这个的主要原因在于客户端和主机的时间不同步，因此需要安装chronyd，然后进行时间校正</p><p>date可以查看服务器的时间，如果不对就安装chronyd。</p><p>yum install chronyd<br>可能会出现问题</p><p>CentOS-8中“Failed to download metadata for repo ‘AppStream“</p><p>问题原因：<br>原因是：CentOS-8于2021年12月31日停止了源的服务</p><p>可以命令查看一下系统是不是8：</p><p>cat /etc/redhat-release</p><p>（1）打开/etc/yum.repos.d文件夹：</p><p>cd /etc/yum.repos.d</p><p>（2）新建bak文件夹并将文件拷贝进其中：</p><p>mkdir bak<br>cp * bak/</p><p>可能会出现cp: -r not specified; omitting directory ‘bak’提示，无影响，无视就好。</p><p>（3）使用以下命令进行内容的替换：</p><p>sed -i ‘s/$releasever/8-stream/‘ CentOS*repo</p><p>问题解决！</p><p>输入以上命令之后，就可以接着运行你的install命令了</p><p>安装完这个chronyd之后，然后</p><p> vim  /etc/chrony.conf</p><p>然后再上面的ntp server 换成下面的国内的地址，接着地址就和国内同步了<br> <pre><code class="hljs applescript">cn.pool.ntp.org  <span class="hljs-comment"># 最常用的国内NTP服务器，参考：https://www.ntppool.org/zh/use.html</span>cn.ntp.org.cn    <span class="hljs-comment"># 中国</span>edu.ntp.org.cn   <span class="hljs-comment"># 中国教育网</span>ntp1.aliyun.com  <span class="hljs-comment"># 阿里云</span>ntp2.aliyun.com  <span class="hljs-comment"># 阿里云</span>ntp.sjtu.edu.cn  <span class="hljs-comment"># 上海交通大学</span>s1a.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 北京邮电大学</span>s1b.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 清华大学</span>s1c.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 北京大学</span>s1d.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 东南大学</span>s1e.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 清华大学</span>s2a.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 清华大学</span>s2b.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 清华大学</span>s2c.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 北京邮电大学</span>s2d.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 西南地区网络中心</span>s2e.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 西北地区网络中心</span>s2f.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 东北地区网络中心</span>s2g.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 华东南地区网络中心</span>s2h.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 四川大学网络管理中心</span>s2j.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># 大连理工大学网络中心</span>s2k.<span class="hljs-built_in">time</span>.edu.cn  <span class="hljs-comment"># CERNET桂林主节点</span></code></pre><br>然后重启时间服务<br> systemctl restart chronyd</p><p> 然后重启v2ray服务</p><p>  systemctl restart v2ray</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>服务器配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慢查询</title>
    <link href="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%85%A2%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%85%A2%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>慢查询就是那些查询时间过长的语句</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow_qurey%&#x27;</span><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log = <span class="hljs-keyword">ON</span>; 开启慢查询SQL功能,最好在配置环境直接配置保证重启时也生效<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time = <span class="hljs-number">1</span>; 慢查询阈值</code></pre><p>执行计划是指一条SQL 语句在经过MySQL 查询优化器的优化会后，具体的执行方式。</p><p>思路<br>1.开启慢查询日志，设置超过几秒为慢sql语句，抓取慢sq语句。l<br>2.通过explain查看执行计划，对慢sql语句分析。<br>3.创建索引并调整语句，再查看执行计划，对比优化结果。</p><p>比如说<br><pre><code class="hljs pgsql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">select</span> *<span class="hljs-keyword">from</span> single <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> <span class="hljs-keyword">like</span> &quot;%解%&quot;</code></pre><br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs routeros">得到的结果为<br>id  selectType  table   patition   <span class="hljs-built_in"> type </span>   possiable_key   key     key_len     ref     rows    fitered     Extra</code></pre></p><p>1 <span class="hljs-built_in"> simple </span> single   <span class="hljs-literal">null</span>    range    idx_single_name   idx_single_name     137     <span class="hljs-literal">null</span>     1    100     using index condition&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>先看type：All全表扫描，没有用到索引</p><p>再看key：Null没有使用索引列</p><p>然后看rows：数值越多耗时越长</p><p>最后看Extra：避免Using temporary和Using Filesort</p><p>id:选择标识符，代表执行顺序</p><p>select_type:表示查询的类型。</p><pre><code class="hljs crystal"><span class="hljs-symbol">simple:</span>简单的<span class="hljs-keyword">select</span>查询，不包含联合查询和子查询<span class="hljs-symbol">primary:</span>查询中包含子查询<span class="hljs-symbol">subquery:</span><span class="hljs-keyword">select</span> 或者where中包含子查询derived：from中包含子查询<span class="hljs-class"><span class="hljs-keyword">union</span>：联合查询</span><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">result</span>：<span class="hljs-title">union</span>后的结果集</span></code></pre><p>table:查询的表名<br>partitions:匹配的分区<br>type:表示表的连接类型<br><pre><code class="hljs pgsql"><span class="hljs-keyword">All</span>：全表扫描<span class="hljs-keyword">Index</span>：只遍历索引树，索引树上就有要查询的结果，不需要IORange：索引范围扫描<span class="hljs-keyword">Ref</span>：非唯一性索引扫描Eq_ref：唯一索引扫描Const：通过一次索引就能查询到，通常是<span class="hljs-keyword">Primary Key</span>或者<span class="hljs-keyword">Unique</span><span class="hljs-keyword">System</span>：Const特例，表数据只有一行<span class="hljs-keyword">Null</span>：不用访问索引就可以直接查询到结果</code></pre></p><p>Possible_key：能使用哪个索引找到数据行，单并不一定会被使用到<br>Key：Possible_key中决定使用的索引<br>Key_len:显示索引中使用的字节数<br>ref:上述表的连接匹配条件，即哪些列或常量被用于查找索引上的值<br>Rows:找到所需记录要读取的行数<br>Extra:<br><pre><code class="hljs pgsql"><span class="hljs-keyword">Using</span> <span class="hljs-keyword">Where</span>：仅通过索引就可以过滤所需数据<span class="hljs-keyword">Using</span> <span class="hljs-keyword">temporary</span>：需要使用临时表来存储结果集<span class="hljs-keyword">Using</span> Filesort：<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>操作无法利用索引完成导致的“文件排序”<span class="hljs-keyword">Using</span> <span class="hljs-keyword">join</span> buffer：连接使用了缓存，可以通过添加索引来解决<span class="hljs-keyword">Using</span> <span class="hljs-keyword">Index</span>：索引树中包含要查询的所有信息<span class="hljs-keyword">Using</span> <span class="hljs-keyword">Index</span> Condition:根据辅助索引过滤数据，减少<span class="hljs-keyword">Server</span>和磁盘的IO次数</code></pre></p><h2 id="索引创建原则"><a href="#索引创建原则" class="headerlink" title="索引创建原则"></a>索引创建原则</h2><pre><code class="hljs pgsql">表一定要有业务无关的主键适合添加索引的列：经常被查询、经常用于表链接，经常排序或者分组索引列尽量都是不重复的数据组合索引一般不超过<span class="hljs-number">5</span>列，选择性高的放在前面合理利用索引覆盖，禁止<span class="hljs-keyword">select</span> *<span class="hljs-keyword">explain</span> 判断<span class="hljs-keyword">sql</span>是否合理利用索引单表索引控制在<span class="hljs-number">5</span>个以内不建议在频繁更新的字段上添加索引<span class="hljs-keyword">where</span>条件中的索引列不能是表达式的一部分，避免对索引列进行函数计算<span class="hljs-keyword">join</span>类型的字段必须类型一致且都建立索引</code></pre><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><pre><code class="hljs xquery">隐式的类型转换会导致索引失效，导致全表扫描对索引列进行函数或者数学计算，例如日期格式化模糊匹配未使用前缀匹配使用了负方向查询<span class="hljs-built_in">，not</span>，!=<span class="hljs-built_in">，not</span> <span class="hljs-keyword">in</span>等</code></pre><h2 id="Sql规范"><a href="#Sql规范" class="headerlink" title="Sql规范"></a>Sql规范</h2><pre><code class="hljs pgsql">按需查询避免 <span class="hljs-keyword">select</span> *无法使用覆盖索引，回表，增加IO多查询的列，会有多余的IO和网络开销避免大事务，将大事务拆成小事务。防止出现锁阻塞，导致的雪崩效应少用多表<span class="hljs-keyword">join</span>，禁止大表<span class="hljs-keyword">join</span>，小表驱动大表，<span class="hljs-keyword">join</span>列必须字符集一致，且有索引尽量避免多层子查询嵌套定期对慢<span class="hljs-keyword">sql</span>优化</code></pre><h1 id="总的优化"><a href="#总的优化" class="headerlink" title="总的优化"></a>总的优化</h1><h2 id="1、索引优化"><a href="#1、索引优化" class="headerlink" title="1、索引优化"></a>1、索引优化</h2><pre><code class="hljs pgsql">为搜索字段（<span class="hljs-keyword">where</span>中的条件）、排序字段、<span class="hljs-keyword">select</span>查询列，创建合适的索引，不过要考虑数据的 业务场景：查询多还是增删多？尽量建立组合索引并注意组合索引的创建顺序，按照顺序组织查询条件、尽量将筛选粒度大的查询 条件放到最左边。尽量使用覆盖索引，<span class="hljs-keyword">SELECT</span>语句中尽量不要使用*。<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>、<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>语句要尽量使用到索引索引长度尽量短，短索引可以节省索引空间，使查找的速度得到提升，同时内存中也可以装载更多 的索引键值。太长的列，可以选择建立前缀索引索引更新不能频繁，更新非常频繁的数据不适宜建索引，因为维护索引的成本。<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>的索引生效，<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序应该遵循最佳左前缀查询，如果是使用多个索引字段进行排 序，那么排序的规则必须相同（同是升序或者降序），否则索引同样会失效。(最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、<span class="hljs-keyword">between</span>、<span class="hljs-keyword">like</span>)就停止匹配，比如a = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> c &gt; <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> d = <span class="hljs-number">4</span> 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。)</code></pre><h2 id="2-LIMIT优化"><a href="#2-LIMIT优化" class="headerlink" title="2. LIMIT优化"></a>2. LIMIT优化</h2><pre><code class="hljs sql">如果预计<span class="hljs-keyword">SELECT</span>语句的查询结果是一条，最好使用 <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>，可以停止全表扫描处理分页会使用到 <span class="hljs-keyword">LIMIT</span> ，当翻页到非常靠后的页面的时候，偏移量会非常大，这时<span class="hljs-keyword">LIMIT</span>的效率 会非常差。<span class="hljs-keyword">LIMIT</span> <span class="hljs-keyword">OFFSET</span> , <span class="hljs-keyword">SIZE</span>；<span class="hljs-keyword">LIMIT</span>的优化问题，其实是 <span class="hljs-keyword">OFFSET</span> 的问题，它会导致MySql扫描大量不需要的行然后再抛弃掉。解决方案：单表分页时，使用自增主键排序之后，先使用<span class="hljs-keyword">where</span>条件 <span class="hljs-keyword">id</span> &gt; <span class="hljs-keyword">offset</span>值，<span class="hljs-keyword">limit</span>后面只写 <span class="hljs-keyword">rows</span></code></pre><h2 id="3-其他查询优化"><a href="#3-其他查询优化" class="headerlink" title="3. 其他查询优化"></a>3. 其他查询优化</h2><pre><code class="hljs pgsql">小表驱动大表, 在 <span class="hljs-keyword">left join</span> 时, 小的表应该为基准表, 外联大表避免全表扫描, mysql在使用不等于(!=或者&lt;&gt;)的时候无法使用索引导致全表扫描。尽量使用count（主键）<span class="hljs-keyword">JOIN</span>条件的两表的字段最好加上索引<span class="hljs-keyword">WHERE</span>条件中尽量不要使用<span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>语句（建议使用<span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span>）</code></pre><p><a href="https://www.modb.pro/db/44911">参考的文章1</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">参考的文章2</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>慢查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2pc 和3pc 协议</title>
    <link href="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/2pc3pc%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/2pc3pc%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="2pc"><a href="#2pc" class="headerlink" title="2pc"></a>2pc</h1><p>主要分为两阶段</p><p>设计出发点<br>为了允许任何一个参与者自行放弃他自己的那部分事务。</p><p>第一阶段：参与者投票表决事务放弃还是提交事务T。如果提交事务，就回复协调者YES T,否则，就回复 abort，同时记录到日志中。同时为了保证提交，必须将事务所有日志记录保存到持久性存储中。</p><p>第二阶段：协调者决定是否提交事务，如果有一个参与者放弃事务，那么最终放弃事务。如果所有参与者投票提交事务，那么最终提交事务，同时将结果保存到持久性存储中。</p><p>如果参与者发生故障，会检查参与者发生故障的时期。</p><p>1.如果在回答YES T消息之前进入故障，那么协调者假定参与者回答的是abort T.</p><p>2.如果在回答YES T消息之后进入故障，那么协调者就按照通常方式执行协议的剩余部分，忽略该站点故障。</p><p>如果参与者S从故障中恢复，那么就检查日志来决定</p><p>1）如果包含commit T,参与者执行redo（T）</p><p>2）如果包含abort T,参与者执行undo（T）</p><p>3）如果包含YES T,就询问协调者事务T的最终结果，如果协调者故障，那么就向其他参与者询问T是否提交或者放弃。如果没有得到信息，那么就定期询问其他参与者，会占据大量资源。</p><p>如果协调者发生故障，就必须检查参与者来决定事务T的结果</p><p>1.如果活跃的参与者日志中包含commit T，那么事务T提交。</p><p>2.如果活跃的参与者日志中包含abort T，那么事务T放弃。</p><p>3.如果有活跃参与者日志中没有YES T,那么就放弃T。</p><p>如果均不成立，那么就必须等待协调者恢复，因此事务T会占据大量资源，这种情况被成为阻塞问题。</p><p>引入 超时机制 和 互询机制 在很大程度上予以解决。</p><p>协调者来说如果在指定时间内没有收到所有参与者的应答，则可以自动退出 等待 状态，并向所有参与者发送 放弃事务 通知。对于参与者来说如果位于 READY 状态，但是在指定时间内没有收到协调者的第二阶段通知，则不能武断地执行 放弃事务 操作，因为协调者可能发送的是 commit 通知，这个时候执行 放弃事务 就会导致数据不一致。<br>此时，我们可以介入互询机制，让参与者 A 去询问其他参与者 B 的执行情况。如果 B 执行了 放弃事务 或 commit 操作，则 A 可以大胆的与 B 执行相同的操作；如果 B 此时还没有到达 准备 状态，则可以进行放弃事务；如果 B 同样位于 准备 状态，则 A 可以继续询问另外的参与者。只有当所有的参与者都位于 准备 状态时，此时两阶段提交协议无法处理，将陷入长时间的阻塞状态。</p><h1 id="3pc"><a href="#3pc" class="headerlink" title="3pc"></a>3pc</h1><p>针对两阶段提交存在的问题，三阶段提交协议通过引入一个 预询盘 阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能。</p><p>第一阶段：<br>协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复；<br>各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息。</p><p>第二阶段 预提交<br>执行事务预提交：如果 协调者 接收到各参与者反馈都是Yes，那么执行事务预提交：</p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>发送预提交请求：协调者 向各参与者发送 preCommit 请求，并进入 prepared 阶段；<span class="hljs-number">2.</span>事务预提交：参与者接收到 preCommit 请求后，会执行事务操作，但不提交；<span class="hljs-number">3.</span>各参与者向协调者反馈事务执行的响应：如果各参与者都成功执行了事务操作，那么反馈给协调者 ACK 响应，同时等待最终指令，提交 commit 或者终止 abort，结束流程；</code></pre><p>第二阶段 预提交<br>中断事务：如果任何一个参与者向 协调者 反馈了 No 响应，或者在等待超时后，协调者 无法接收到所有参与者的反馈，那么就会中断事务。<br>发送中断请求：协调者 向所有参与者发送 abort 请求；<br>中断事务：无论是收到来自 协调者 的 abort 请求，还是等待超时，参与者都中断事务。</p><p>第三阶段事务提交<br>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为 3 种情况：<br>所有的参与者都能正常执行事务。<br>一个或多个参与者执行事务失败。<br>协调者等待超时。<br>针对第 1 种情况，协调者向各个参与者发起事务提交请求，具体步骤如下：<br>协调者向所有参与者发送事务 commit 通知；<br>所有参与者在收到通知之后执行 commit 操作，并释放占有的资源；<br>参与者向协调者反馈事务提交结果。</p><p>针对第 2 和第 3 种情况，协调者认为事务无法成功执行，于是向各个参与者发送事务回滚请求，具体步骤如下：<br>协调者向所有参与者发送事务 rollback 通知；<br>所有参与者在收到通知之后执行 rollback 操作，并释放占有的资源；<br>参与者向协调者反馈事务回滚结果。</p><h1 id="3PC最关键要解决的就是2PC中协调者和参与者同时挂掉的问题"><a href="#3PC最关键要解决的就是2PC中协调者和参与者同时挂掉的问题" class="headerlink" title="3PC最关键要解决的就是2PC中协调者和参与者同时挂掉的问题"></a>3PC最关键要解决的就是2PC中协调者和参与者同时挂掉的问题</h1><p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的 commit 或 rollback 请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续 commit，相对于两阶段提交虽然降低了同步阻塞，但仍然无法完全避免数据的不一致。</p><p>当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么Coordinator产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。</p><p>3PC存在的问题</p><p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。<br>所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>2pc</tag>
      
      <tag>3pc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lsm树</title>
    <link href="/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/lsm%E6%A0%91/"/>
    <url>/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93/lsm%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="日志结构合并树"><a href="#日志结构合并树" class="headerlink" title="日志结构合并树"></a>日志结构合并树</h1><h2 id="LSM树（Log-Structured-Merge-Tree）存储引擎"><a href="#LSM树（Log-Structured-Merge-Tree）存储引擎" class="headerlink" title="LSM树（Log-Structured Merge Tree）存储引擎"></a>LSM树（Log-Structured Merge Tree）存储引擎</h2><p>代表数据库：nessDB、leveldb、hbase等</p><p>核心思想的核心就是放弃部分读能力，换取写入的最大化能力。LSM Tree ，这个概念就是结构化合并树的意思，它的核心思路其实非常简单，就是假定内存足够大，因此不需要每次有数据更新就必须将数据写入到磁盘中，而可以先将最新的数据驻留在磁盘中，等到积累到最后多之后，再使用归并排序的方式将内存内的数据合并追加到磁盘队尾(因为所有待排序的树都是有序的，可以通过合并排序的方式快速合并到一起)。</p><p>日志结构的合并树（LSM-tree）是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销，并能在较长的时间提供对文件的高速插入（删除）。然而LSM-tree在某些情况下，特别是在查询需要快速响应时性能不佳。通常LSM-tree适用于索引插入比检索更频繁的应用系统。Bigtable在提供Tablet服务时，使用GFS来存储日志和SSTable，而GFS的设计初衷就是希望通过添加新数据的方式而不是通过重写旧数据的方式来修改文件。而LSM-tree通过滚动合并和多页块的方法推迟和批量进行索引更新，充分利用内存来存储近期或常用数据以降低查找代价，利用硬盘来存储不常用数据以减少存储代价。</p><p>磁盘的技术特性:对磁盘来说，能够最大化的发挥磁盘技术特性的使用方式是:一次性的读取或写入固定大小的一块数据，并尽可能的减少随机寻道这个操作的次数。</p><h2 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1 B+树"></a>1 B+树</h2><p>相信大家对B+树已经非常的熟悉，比如Oracle的普通索引就是采用B+树的方式，下面是一个B+树的例子：</p><p>根节点和枝节点很简单，分别记录每个叶子节点的最小值，并用一个指针指向叶子节点。</p><p>叶子节点里每个键值都指向真正的数据块（如Oracle里的RowID），每个叶子节点都有前指针和后指针，这是为了做范围查询时，叶子节点间可以直接跳转，从而避免再去回溯至枝和跟节点。</p><p>B+树最大的性能问题是会产生大量的随机IO，随着新数据的插入，叶子节点会慢慢分裂，逻辑上连续的叶子节点在物理上往往不连续，甚至分离的很远，但做范围查询时，会产生大量读随机IO。</p><p>对于大量的随机写也一样，举一个插入key跨度很大的例子，如7-&gt;1000-&gt;3-&gt;2000 … 新插入的数据存储在磁盘上相隔很远，会产生大量的随机写IO.</p><p>从上面可以看出，低下的磁盘寻道速度严重影响性能（近些年来，磁盘寻道速度的发展几乎处于停滞的状态）。</p><h2 id="2-LSM树"><a href="#2-LSM树" class="headerlink" title="2 LSM树"></a>2 LSM树</h2><p>为了克服B+树的弱点，HBase引入了LSM树的概念，即Log-Structured Merge-Trees。</p><p>为了更好的说明LSM树的原理，下面举个比较极端的例子：</p><p>现在假设有1000个节点的随机key，对于磁盘来说，肯定是把这1000个节点顺序写入磁盘最快，但是这样一来，读就悲剧了，因为key在磁盘中完全无序，每次读取都要全扫描；</p><p>那么，为了让读性能尽量高，数据在磁盘中必须得有序，这就是B+树的原理，但是写就悲剧了，因为会产生大量的随机IO，磁盘寻道速度跟不上。</p><p>LSM树本质上就是在读写之间取得平衡，和B+树相比，它牺牲了部分读性能，用来大幅提高写性能。</p><p>它的原理是把一颗大树拆分成N棵小树， 它首先写入到内存中（内存没有寻道速度的问题，随机写的性能得到大幅提升），在内存中构建一颗有序小树，随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历所有的小树，但在每颗小树内部数据是有序的。</p><h2 id="以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。"><a href="#以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。" class="headerlink" title="以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。"></a>以上就是LSM树最本质的原理，有了原理，再看具体的技术就很简单了。</h2><p>1）首先说说为什么要有WAL（Write Ahead Log），很简单，因为数据是先写到内存中，如果断电，内存中的数据会丢失，因此为了保护内存中的数据，需要在磁盘上先记录logfile，当内存中的数据flush到磁盘上时，就可以抛弃相应的Logfile。</p><p>2）什么是memstore, storefile？很简单，上面说过，LSM树就是一堆小树，在内存中的小树即memstore，每次flush，内存中的memstore变成磁盘上一个新的storefile。</p><p>3）为什么会有compact？很简单，随着小树越来越多，读的性能会越来越差，因此需要在适当的时候，对磁盘中的小树进行merge，多棵小树变成一颗大树。</p><p>关于LSM Tree，对于最简单的二层LSM Tree而言，<br>下面说说详细例子:</p><p>LSM Tree弄了很多个小的有序结构，比如每m个数据，在内存里排序一次，下面100个数据，再排序一次……这样依次做下去，就可以获得N/m个有序的小的有序结构。</p><p>在查询的时候，因为不知道这个数据到底是在哪里，所以就从最新的一个小的有序结构里做二分查找，找得到就返回，找不到就继续找下一个小有序结构，一直到找到为止。</p><p>很容易可以看出，这样的模式，读取的时间复杂度是(N/m)*log2N 。读取效率是会下降的。</p><p>这就是最本来意义上的LSM tree的思路。那么这样做，性能还是比较慢的，于是需要再做些事情来提升，怎么做才好呢？</p><h2 id="LSM-Tree优化方式："><a href="#LSM-Tree优化方式：" class="headerlink" title="LSM Tree优化方式："></a>LSM Tree优化方式：</h2><p>a、Bloom filter: 就是个带随即概率的bitmap,可以快速的告诉你，某一个小的有序结构里有没有指定的那个数据的。于是就可以不用二分查找，而只需简单的计算几次就能知道数据是否在某个小集合里啦。效率得到了提升，但付出的是空间代价。</p><p>b、compact:小树合并为大树:因为小树他性能有问题，所以要有个进程不断地将小树合并到大树上，这样大部分的老数据查询也可以直接使用log2N的方式找到，不需要再进行(N/m)*log2n的查询了</p><p>可以参考github这篇文章<a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter02/LSMTree.html">lsm树</a></p><p>可以参考博客园这篇文章<a href="https://www.cnblogs.com/bonelee/p/6244810.html">lsm树</a></p><p>都看下差不多就懂了</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>lsm树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++并发编程</title>
    <link href="/2022/03/11/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bc++/"/>
    <url>/2022/03/11/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bc++/</url>
    
    <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://shouce.jb51.net/cpp_concurrency_in_action/content/chapter2/2.4-chinese.html">http://shouce.jb51.net/cpp_concurrency_in_action/content/chapter2/2.4-chinese.html</a></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><pre><code class="hljs crystal"><span class="hljs-comment">#include&lt;thread&gt;</span>void <span class="hljs-function"><span class="hljs-keyword">fun</span>()&#123;&#125;;</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">std</span></span>::thread m(<span class="hljs-function"><span class="hljs-keyword">fun</span>);</span><span class="hljs-function"></span><span class="hljs-function">线程分为加入式，或者分离式</span><span class="hljs-function"></span><span class="hljs-function">加入是<span class="hljs-title">join</span></span>（）m.join();阻塞线程，直到线程返回m.detach()detach 在主线程结束但是分线程没结束得时候可能会导致引用不存在得变量得情况。</code></pre><h2 id="如果线程产生异常"><a href="#如果线程产生异常" class="headerlink" title="如果线程产生异常"></a>如果线程产生异常</h2><p>可以使用</p><pre><code class="hljs cpp"><span class="hljs-keyword">try</span>  &#123;    do_something_in_current_thread();  &#125;  <span class="hljs-keyword">catch</span>(...)  &#123;    t.join();  <span class="hljs-comment">// 1</span>    <span class="hljs-keyword">throw</span>;  &#125;  t.join();  <span class="hljs-comment">// 2</span>如果使用RAII得方式<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thread_guard</span></span><span class="hljs-class">&#123;</span>  <span class="hljs-built_in">std</span>::thread&amp; t;<span class="hljs-keyword">public</span>:  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::thread&amp; t_)</span>:</span><span class="hljs-function">    <span class="hljs-title">t</span><span class="hljs-params">(t_)</span></span><span class="hljs-function">  </span>&#123;&#125;  ~thread_guard()  &#123;    <span class="hljs-keyword">if</span>(t.joinable()) <span class="hljs-comment">// 1</span>    &#123;      t.join();      <span class="hljs-comment">// 2</span>    &#125;  &#125;  thread_guard(thread_guard <span class="hljs-keyword">const</span>&amp;)=<span class="hljs-keyword">delete</span>;   <span class="hljs-comment">// 3</span>  thread_guard&amp; <span class="hljs-keyword">operator</span>=(thread_guard <span class="hljs-keyword">const</span>&amp;)=<span class="hljs-keyword">delete</span>;&#125;;在thread_guard的析构函数的测试中，首先判断线程是否已加入<span class="hljs-number">1</span>，如果没有会调用join()<span class="hljs-number">2</span>进行加入。这很重要，因为join()只能对给定的对象调用一次，所以对给已加入的线程再次进行加入操作时，将会导致错误。</code></pre><h2 id="线程传参"><a href="#线程传参" class="headerlink" title="线程传参"></a>线程传参</h2><p>thread 在向线程传递参数得时候，默认是拷贝到线程中得，即使它是引用传递。传递给函数的参数是data变量内部拷贝的引用，而非数据本身的引用。</p><p>如果一定要使用引用，使用std::ref</p><p>每个实例都负责管理一个执行线程。执行线程的所有权可以在多个std::thread实例中互相转移，这是依赖于std::thread实例的可移动且不可复制性。不可复制保性证了在同一时间点，一个std::thread实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。</p><p>这个与unique_prt相似</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">std</span>::thread <span class="hljs-title">t1</span><span class="hljs-params">(some_function)</span></span>;            <span class="hljs-comment">// 1</span><span class="hljs-built_in">std</span>::thread t2=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(t1);            <span class="hljs-comment">// 2</span></code></pre><h2 id="产生一批线程，然后等待"><a href="#产生一批线程，然后等待" class="headerlink" title="产生一批线程，然后等待"></a>产生一批线程，然后等待</h2><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::thread&gt; threads;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)  &#123;    threads.push_back(<span class="hljs-built_in">std</span>::thread(do_work,i)); <span class="hljs-comment">// 产生线程</span>  &#125;   <span class="hljs-built_in">std</span>::for_each(threads.<span class="hljs-built_in">begin</span>(),threads.<span class="hljs-built_in">end</span>(),                  <span class="hljs-built_in">std</span>::mem_fn(&amp;<span class="hljs-built_in">std</span>::thread::join)); <span class="hljs-comment">// 对每个线程调用join()</span>                      <span class="hljs-comment">//mem_fn把成员函数转为函数对象，使用对象指针进行绑定</span>&#125;</code></pre><h2 id="获取支持得线程数目"><a href="#获取支持得线程数目" class="headerlink" title="获取支持得线程数目"></a>获取支持得线程数目</h2><p>std::thread::hardware_concurrency()在新版C++标准库中是一个很有用的函数。这个函数将返回能同时并发在一个程序中的线程数量。</p><h2 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h2><p>std::thread::id</p><p>std::this_thread::get_id()</p><p>或者thread.get_id()</p><h2 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h2><h3 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h3><p>std::mutex创建互斥量  lock()进行上锁，unlock()进行解锁</p><p>C++标准库为互斥量提供了一个RAII语法的模板类std::lock_guard，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁</p><p>要避免成员函数通过返回值或者输出参数的形式向其调用者返回指向受保护数据的指针或引用</p><p>std::lock——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)</p><p>std::unique_lock——灵活的锁<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs cpp">简单地讲，unique_lock 是 lock_guard 的升级加强版，它具有 lock_guard 的所有功能，同时又具有其他很多方法，使用起来更强灵活方便，能够应对更复杂的锁定需要。</code></pre></p><p>特点如下：</p><p>创建时可以不锁定（通过指定第二个参数为<span class="hljs-built_in">std</span>::defer_lock），而在需要时再锁定<br>可以随时加锁解锁<br>作用域规则同 lock_grard，析构时自动释放锁<br>不可复制，可移动<br>条件变量需要该类型的锁作为参数（此时必须使用unique_lock）&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>lock_guard<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs delphi">lock_guard是一个互斥量包装程序，它提供了一种方便的RAII（Resource acquisition <span class="hljs-keyword">is</span> <span class="hljs-keyword">initialization</span> ）风格的机制来在作用域块的持续时间内拥有一个互斥量。</code></pre></p><p>创建lock_guard对象时，它将尝试获取提供给它的互斥锁的所有权。当控制流离开lock_guard对象的作用域时，lock_guard析构并释放互斥量。</p><p>它的特点如下：</p><p>创建即加锁，作用域结束自动析构并解锁，无需手工解锁<br>不能中途解锁，必须等作用域结束才解锁<br>不能复制&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>C++并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++并发编程</title>
    <link href="/2022/03/11/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bleetcode/"/>
    <url>/2022/03/11/C++/C++%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8Bleetcode/</url>
    
    <content type="html"><![CDATA[<p>在leetcode里面最常用得就是mutex，互斥量加锁，C++11要求由同一个线程来对一个 mutex 对象进行 lock 和 unlock 操作，不然是未定义得行为</p><p>然后还有一种是需要A线程做了某事情，然后b需要某些条件才可以做，可以使用互斥量加条件变量</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H2O</span> &#123;</span><span class="hljs-keyword">private</span>:    <span class="hljs-built_in">std</span>::mutex m;    <span class="hljs-built_in">std</span>::condition_variable cv;    <span class="hljs-keyword">int</span> h=<span class="hljs-number">0</span>;<span class="hljs-keyword">public</span>:    H2O() &#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hydrogen</span><span class="hljs-params">(function&lt;<span class="hljs-keyword">void</span>()&gt; releaseHydrogen)</span> </span>&#123;        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        cv.wait(lk,[&amp;]&#123;<span class="hljs-keyword">return</span> h&lt;<span class="hljs-number">2</span>;&#125;);<span class="hljs-comment">//这个是当h&lt;2，返回true，继续执行，如果返回得是false，那么释放锁，阻塞，直到被唤醒</span>        releaseHydrogen();        h++;        cv.notify_all();        <span class="hljs-comment">// releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">oxygen</span><span class="hljs-params">(function&lt;<span class="hljs-keyword">void</span>()&gt; releaseOxygen)</span> </span>&#123;        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;        cv.wait(lk,[&amp;]&#123;<span class="hljs-keyword">return</span> h==<span class="hljs-number">2</span>;&#125;);        releaseOxygen();        h=<span class="hljs-number">0</span>;        cv.notify_all();        <span class="hljs-comment">// releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span>    &#125;&#125;;</code></pre><p>还有一种是信号量得写法</p><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;semaphore.h&gt;<span class="hljs-keyword">class</span> H2O &#123;    sem_t s1, s2;    <span class="hljs-built_in">int</span> state = <span class="hljs-number">0</span>;public:    <span class="hljs-constructor">H2O()</span> &#123;        sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">s1</span>, 0, 2)</span>;<span class="hljs-comment">//0代表共享，2为初始值</span>        sem<span class="hljs-constructor">_init(&amp;<span class="hljs-params">s2</span>, 0, 0)</span>;        <span class="hljs-comment">// sem_post(&amp;s1);</span>    &#125;    void hydrogen(<span class="hljs-keyword">function</span>&lt;void<span class="hljs-literal">()</span>&gt; releaseHydrogen) &#123;        sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">s1</span>)</span>;<span class="hljs-comment">//信号量-1，如果小于等于0就阻塞</span>        state++;        <span class="hljs-comment">// releaseHydrogen() outputs &quot;H&quot;. Do not change or remove this line.</span>        release<span class="hljs-constructor">Hydrogen()</span>;        <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> == </span><span class="hljs-number">2</span>) &#123;            sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">s2</span>)</span>;<span class="hljs-comment">//信号量+1</span>        &#125;    &#125;    void oxygen(<span class="hljs-keyword">function</span>&lt;void<span class="hljs-literal">()</span>&gt; releaseOxygen) &#123;        sem<span class="hljs-constructor">_wait(&amp;<span class="hljs-params">s2</span>)</span>;        <span class="hljs-comment">// releaseOxygen() outputs &quot;O&quot;. Do not change or remove this line.</span>        release<span class="hljs-constructor">Oxygen()</span>;        state = <span class="hljs-number">0</span>;        sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">s1</span>)</span>;        sem<span class="hljs-constructor">_post(&amp;<span class="hljs-params">s1</span>)</span>;    &#125;&#125;;</code></pre><p>使用原子操作<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt;/span&gt;&#123;<br>    std::atomic&lt;<span class="hljs-keyword">bool</span>&gt; a&#123; <span class="hljs-literal">false</span> &#125;;<br>    std::atomic&lt;<span class="hljs-keyword">bool</span>&gt; b&#123; <span class="hljs-literal">false</span> &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> first(<span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">void</span>(<span class="hljs-params">&lt;/span&gt;)&gt; <span class="hljs-title">printFirst</span>) &lt;/span&gt;&#123;<br>        printFirst();<br>        a = <span class="hljs-literal">true</span>;<br>    &#125;</span></span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; second(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;printSecond&lt;/span&gt;) &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!a)        this_thread::sleep_for(chrono::milliseconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));    printSecond();    b = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; third(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;printThird&lt;/span&gt;) &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!b)        this_thread::sleep_for(chrono::milliseconds(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;));    printThird();&amp;#125;</code></pre><p>&#125;;<br>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;<br>future 使用<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt;/span&gt;&#123;<br>    promise&lt;<span class="hljs-keyword">void</span>&gt; pro1, pro2;</span></code></pre></p><p><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> first(<span class="hljs-function"><span class="hljs-keyword">function</span>&lt;<span class="hljs-title">void</span>(<span class="hljs-params">&lt;/span&gt;)&gt; <span class="hljs-title">printFirst</span>) &lt;/span&gt;&#123;<br>        printFirst();<br>        pro1.set_value();<br>    &#125;</span></span></p><pre><code>&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; second(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;printSecond&lt;/span&gt;) &lt;/span&gt;&amp;#123;    pro1.get_future().wait();&lt;span class=&quot;hljs-comment&quot;&gt;//等待set传入得数，否则阻塞&lt;/span&gt;    printSecond();    pro2.set_value();&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; third(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;void&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;printThird&lt;/span&gt;) &lt;/span&gt;&amp;#123;    pro2.get_future().wait();    printThird();&amp;#125;</code></pre><p>&#125;;<br>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
      <category>C++并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程</title>
    <link href="/2022/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/03/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="基于并发进程的并发编程"><a href="#基于并发进程的并发编程" class="headerlink" title="基于并发进程的并发编程"></a>基于并发进程的并发编程</h2><p>当父进程接受客户端的连接请求的时候,创建新的子进程为客户服务,这个需要注意的是,子进程会继承父进程文件描述符的副本,因此都指向同一个文件表的表项,因此需要父进程关闭他的连接描述符的副本,然后子进程需要关闭listen socket的副本,然后开始服务,服务完了关闭连接描述符的副本.</p><p>在linux中文件表是引用计数的,因此父进程关闭文件描述符,不会影响子进程</p><h2 id="IO多路复用技术"><a href="#IO多路复用技术" class="headerlink" title="IO多路复用技术"></a>IO多路复用技术</h2><p>可以参考select,poll,epoll那一篇.</p><h2 id="基于线程的并发"><a href="#基于线程的并发" class="headerlink" title="基于线程的并发"></a>基于线程的并发</h2><p>线程有自己的栈,寄存器,程序计数器,线程ID,与其他线程共享虚拟地址空间.</p><p>主要区别是join和detach的区别.</p><p>join会阻塞直到线程返回,需要被其他线程回收.</p><p>detach不能被其他线程回收,内存资源在终止的时候由系统自动释放.</p><p>多线程的共享变量需要同步互斥,使用信号量.</p><p>经典的比如说是生产者消费者问题</p><p>它由三个信号量,一个mutex用来设置互斥访问的,一个是itemm,empty,分别是有多少东西,有多少空位</p><pre><code class="hljs reasonml">生产者:<span class="hljs-constructor">P(<span class="hljs-params">empty</span>)</span>;<span class="hljs-constructor">P(<span class="hljs-params">mutex</span>)</span>;插入<span class="hljs-constructor">V(<span class="hljs-params">mutex</span>)</span>;<span class="hljs-constructor">V(<span class="hljs-params">itemm</span>)</span>;消费者:<span class="hljs-constructor">P(<span class="hljs-params">itemm</span>)</span><span class="hljs-constructor">P(<span class="hljs-params">mutex</span>)</span>;删除<span class="hljs-constructor">V(<span class="hljs-params">mutex</span>)</span>;<span class="hljs-constructor">V(<span class="hljs-params">empty</span>)</span>;</code></pre><p>读者写者问题:<br>我们考虑第一种问题,读者优先的问题.有两个信号量,mutex控制读者数目,w控制临界区<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs reasonml">读者:<br><span class="hljs-constructor">P(<span class="hljs-params">mutex</span>)&lt;/span&gt;;<br>readcnt++;<br><span class="hljs-keyword">if</span>(readcnt==<span class="hljs-number">1</span>)<br>    p(w);<br><span class="hljs-constructor">V(<span class="hljs-params">mutex</span>)&lt;/span&gt;;</span></span></code></pre></p><p>读信息</p><p><span class="hljs-constructor">P(<span class="hljs-params">mutex</span>)&lt;/span&gt;;<br>readcnt—;<br><span class="hljs-keyword">if</span>(readcnt==<span class="hljs-number">0</span>)<br>    <span class="hljs-constructor">V(<span class="hljs-params">w</span>)&lt;/span&gt;;<br><span class="hljs-constructor">V(<span class="hljs-params">mutex</span>)&lt;/span&gt;;</span></span></span></p><p>写者:<br><span class="hljs-constructor">P(<span class="hljs-params">w</span>)&lt;/span&gt;;<br>写信息;<br><span class="hljs-constructor">V(<span class="hljs-params">w</span>)&lt;/span&gt;;<br>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</span></span></p><p>注意rand函数是线程不安全的,因为它依赖于之前一次的调用结果.</p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性:"></a>可重入性:</h3><p>当其被多个线程调用的时候,不会引用共享数据.可重入函数是线程安全函数的真子集.</p><h2 id="死锁也需要注意"><a href="#死锁也需要注意" class="headerlink" title="死锁也需要注意"></a>死锁也需要注意</h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常控制流</title>
    <link href="/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<p>当有异常发生的时候，会通过一张异常表的跳转表来进行一个间接异常调用，到操作系统专门用来处理这种异常的异常处理程序中。</p><p>异常表的起始地址放在一个叫做异常表基址寄存器的特殊CPU寄存器中。</p><p>异常处理程序运行在内核模式下，因此对所有资源都有完全的访问权限。</p><p>异常的类别：中断，陷阱，故障，终止</p><pre><code class="hljs plain">中断 来自IO设备的信号，异步处理，总是返回下一条指令陷阱，有意的异常，同步，总是返回下一条指令，陷阱的重要用途在于系统调用，与普通函数调用的区别在于，他是运行在内核模式下的。故障，潜在可恢复的错误，同步，可能返回当前指令，经典的是缺页异常终止，不可恢复的错误，同步，不会返回</code></pre><h2 id="内核模式与用户模式"><a href="#内核模式与用户模式" class="headerlink" title="内核模式与用户模式"></a>内核模式与用户模式</h2><p>处理器通常用某个控制寄存器的模式位来提供进入内核模式的功能</p><p>从用户态变为内核态的唯一方法是异常</p><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>操作系统使用上下文切换的异常控制流来实现多任务</p><p>上下文信息包括，程序计数器，寄存器，内核栈，内核数据结构，比如地址空间的页表，当前进程信息的进程表，已打开文件的文件表。</p><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>创建新的子进程，不完全与父进程相同，他们有相同的堆栈，代码段数据段，相同的打开文件描述符的副本，因此子进程可以读写父进程的任何文件，但是他们有不同的PID。</p><p>fork调用一次，返回两次，返回0，说明在子进程中，在父进程中返回子进程的PID。</p><p>父进程和子进程是并发执行的，相同的但是独立的地址空间，因为继承了文件描述符的副本，如果父进程写stdout，那么子进程也可以输出。</p><p>注意fork与execve的区别，fork创建父进程的复制品，有不同的pid，execve加载执行程序，他们有着相同的PID，新程序会覆盖当前进程的地址空间，没有创建新的进程。</p><h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><p>进程终止的时候是由父进程回收的，父进程是由内核指定的init进程（PID=1）回收的。</p><p>当父进程回收子进程时，内核将子进程的退出状态传给父进程，然后子进程被完全抛弃。</p><p>终止了但是还没回收的进程为僵尸进程。</p><p>waitpid可以等待子进程终止或者停止。</p><h2 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h2><p>C语言提供的用户级的异常控制流形式，称为非本地跳转。通过setjmp和longjmp实现。</p><p>两者是配合使用的，setjmp在env缓冲区中保存当前调用环境吗，供longjmp使用。返回0，调用环境包括程序计数器，栈指针，通用目的寄存器。其返回值不能被赋值给变量。<br>不过可以用在switch和if中。</p><p>longjmp从env缓冲区恢复调用环境，然后触发一次最近的初始化env的setjmp的返回</p><p>注意setjmp调用一次返回多次,longjmp从不返回.</p><p>C++和java的异常机制是setjmp和longjmp更加结构化的版本,可以将catch认为setjmp,throw认为是longjmp.</p><h2 id="linux的几个命令"><a href="#linux的几个命令" class="headerlink" title="linux的几个命令"></a>linux的几个命令</h2><p>ps,列出当前系统的进程</p><p>top,打印当前进程资源的使用<br>PMAP 显示进程的内存映射.</p><p>/proc 一个虚拟文件系统,以ASCII输出大量内核数据结构内容,用户可以读取这些内容,比如cat /proc/loadavg</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>linux信号允许进程和内核中断其他的进程,</p><p>信号使用主要分为发送信号和接收信号</p><p>发送信号:内核检测到上下文信息发送信号给目的进程</p><p>接收信号,目的进程被内核强迫对信号的发送做出反应,就接收了信号.如果忽略这个信号或者终止或者执行信号处理程序的用户层函数捕捉信号.</p><p>发出而没有被接收的称为待处理的信号,任何情况,一种类型都只会有一个待处理的信号.<br>超过1的都会被丢弃.</p><p>如果进程阻塞某个信号,那么发送过来的不会被接收,只有阻塞解除之后才会被接收.</p><p>内核为每个进程在pending位向量中维护着待处理信号的集合,在blocked位向量中维护着被阻塞的信号的集合.</p><p>具体内容可以参考csapp第八章,关于代码的比较多.</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>异常控制流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟内存</title>
    <link href="/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将虚拟内存区域与磁盘中的对象关联起来叫做内存映射。</p><p>可以映射两种对象</p><pre><code class="hljs angelscript">linux的普通文件，内存中映射文件的连续的一块，如果这一块区域比较小，那么就补<span class="hljs-number">0</span>，匿名文件，也叫请求二进制<span class="hljs-number">0</span>的页面，他是由内核创建的全是二进制<span class="hljs-number">0</span>的。要么从物理内存中换一个页面出来，并且覆盖<span class="hljs-number">0</span>，注意没有磁盘与内存没有数据传送。</code></pre><p>在使用内存映射的时候，对象可分为共享的，或者私有的，如果是共享对象，那么对对象的任意修改都会反映到磁盘上，如果是私有的对象，不会反映到磁盘上，而是使用写时复制的思想来处理。就是说只有对私有对象写的时候才复制，之前都是共享的，只保留一个物理副本，是只读的，如果写了，就会复制一个新的页面，然后指向新页面，让其可写。</p><p>fork函数就使用了写时复制的方法。</p><p>使用execve的时候，bss，堆栈是使用映射匿名文件，全0的</p><p>mmap函数就是为了创建一个新的虚拟内存区域，使其映射到一个文件的chunk，同时给定偏移量，长度。</p><p><a href="https://www.hiyu.space/2021/01/31/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/#more">虚拟内存参考文章</a></p><pre><code class="hljs mathematica">虚拟地址的整个想法是这样的：把程序给出的地址看做是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。除了在编程时可以使用固定的内存地址，给程序员带来方便外，使用虚拟地址还能够使不同程序的地址空间相互隔离，提高内存使用效率。使不同程序的地址空间相互隔离如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 Bug 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。这对于需要安全稳定的计算机环境的用户来说是不能容忍的，用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。使用了虚拟地址后，程序A和程序B虽然都可以访问同一个地址，但它们对应的物理地址是不同的，无论如何操作，都不会修改对方的内存。提高内存使用效率使用虚拟地址后，操作系统会更多地介入到内存管理工作中，这使得控制内存权限成为可能。例如，我们希望保存数据的内存没有执行权限，保存代码的内存没有修改权限，操作系统占用的内存普通程序没有读取权限等。另外，当物理内存不足时，操作系统能够更加灵活地控制换入换出的粒度，磁盘 <span class="hljs-keyword">I</span>/<span class="hljs-keyword">O</span> 是非常耗时的工作，这能够从很大程度上提高程序性能。</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>虚拟内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态链接和动态链接，库打桩，位置无关代码</title>
    <link href="/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <url>/2022/03/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>主要是为了将一些可重定位目标文件链接为可执行的目标文件。</p><p>目标文件主要包括三种：</p><h2 id="可重定位目标文件，可执行目标文件，共享目标文件"><a href="#可重定位目标文件，可执行目标文件，共享目标文件" class="headerlink" title="可重定位目标文件，可执行目标文件，共享目标文件"></a>可重定位目标文件，可执行目标文件，共享目标文件</h2><p>链接的主要完成的有两点，符号解析和地址重定位</p><h2 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h2><p>主要是为了解析函数符号，全局变量的符号，static的符号，主要是为了将符号引用与符号定义关联起来。为什么不需要对局部变量进行符号解析呢，因为在文件内部可以找到，不需要链接。</p><p>符号解析主要是通过将每个引用同输入的可重定位目标文件的符号表中的一个条目对应起来<br>局部变量的符号解析比较简单，静态局部变量会有本地链接器的符号，编译器需要确保有唯一的名字，</p><p>如果碰到当前模块没有定义的符号，会假设是其他某个模块定义的，然后生成一个链接器符号表条目，交给链接器处理，然后去其他模块中找，没找到就会报错。</p><p>如果出现重名的全局符号，要么选出一个抛弃其他的，要么报错。重名时根据符号强弱来选择，已经初始化的为强符号，没有初始化的为弱符号。</p><p>多个强符号报错，一个强多个弱，选强，如果多个弱，任意选一个</p><p>对于函数C++和JAVA都会用方法和参数列表组合出一个对链接器唯一的名字，叫函数重整。</p><h1 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h1><p>汇编器生成的是从0开始的代码和数据节，链接器通过把每个符号同一个内存位置关联起来，重定位这些节，然后修改对这些符号的引用，使其指向这个位置，链接器使用汇编器产生的重定位条目。</p><p>主要包含两个，重定位节和符号定义，重定位节中的符号引用</p><h2 id="重定位节和符号定义-确定符号和节的地址"><a href="#重定位节和符号定义-确定符号和节的地址" class="headerlink" title="重定位节和符号定义(确定符号和节的地址)"></a>重定位节和符号定义(确定符号和节的地址)</h2><p>将所有相同类型的节合并成聚合的节，然后将运行时的内存地址赋给新的聚合节，赋给输入模块的定义每个符号，此时全局变量和每条指令都有唯一的运行地址了。</p><h2 id="重定位节中的符号引用（确定每个符号引用的地址）"><a href="#重定位节中的符号引用（确定每个符号引用的地址）" class="headerlink" title="重定位节中的符号引用（确定每个符号引用的地址）"></a>重定位节中的符号引用（确定每个符号引用的地址）</h2><p>修改代码节和数据节中对每个符号的引用，使其指向正确的运行时地址，这一个步骤依赖于重定位条目。</p><p>重定位条目是由于目标模块不知道函数和代码具体存放在内存的位置。也不知道外部定义的函数和全局变量的位置，所以生成重定位条目用来后面生成可执行文件时的修改。</p><h2 id="重定位条目包含"><a href="#重定位条目包含" class="headerlink" title="重定位条目包含"></a>重定位条目包含</h2><pre><code class="hljs routeros">offset 被修改的引用的节偏移type 告诉链接器如何修改新的引用主要有两种常用类型，R_X86_64_PC32,,重定位一个32位PC相对地址的引用，例如当进行PC相对寻址的时候，这个数加上PC值得到有效地址，例如call的地址。R_X86_64_32，重定位一个使用32位绝对地址的引用，CPU直接使用这个绝对地址作为有效地址，不需要进一步修改。addend 有符号常熟，对一些类型的重定位需要使用其对被修改引用的值做偏移调整symbol 表示被修改的引用应该指向的符号</code></pre><p>重定位符号引用<br><pre><code class="hljs plain"></code></pre></p><p>可重定位目标文件包含的内容</p><pre><code class="hljs css"><span class="hljs-selector-tag">ELF</span>头<span class="hljs-selector-class">.text</span> 已经编译的机器代码<span class="hljs-selector-class">.rodata</span> 只读数据，例如<span class="hljs-selector-tag">printf</span>的格式串<span class="hljs-selector-class">.data</span> 已经初始化的全局数据和静态数据<span class="hljs-selector-class">.bss</span> 未初始化的全局数据和静态数据,不占实际空间,分配在符号表中以及段表中,实际运行才会分配空间.<span class="hljs-selector-class">.systab</span> 符号表，存放文件引用的全局变量和函数信息（不包含局部变量），静态变量也在符号表中，局部变量放在栈中管理。符号表的每个条目由一个结构体表示，包含<span class="hljs-selector-tag">name</span>，<span class="hljs-selector-tag">type</span>，<span class="hljs-selector-tag">section</span>(目标文件的哪个节)，其中有三个特殊的伪节（只在可重定位目标文件才有，可执行文件中没有），<span class="hljs-selector-tag">UNDEF</span>（未定义的符号），<span class="hljs-selector-tag">ABS</span>(不该被重定位的符号)，<span class="hljs-selector-tag">COMMON</span>(未被分配位置的未初始化的数据目标)，<span class="hljs-selector-tag">value</span>，<span class="hljs-selector-tag">size</span>。<span class="hljs-selector-tag">COMMON</span>主要代表未初始化的全局变量，<span class="hljs-selector-tag">bss</span>主要代表未初始化的静态变量以及初始化未0的全局和静态变量<span class="hljs-selector-class">.rel</span><span class="hljs-selector-class">.text</span>  <span class="hljs-selector-class">.text</span> 节中位置的列表，当链接器将这个文件和其他文件组合的时候需要修改，即任何调用外部函数时候都需要修改这些位置，调用本地文件不需要<span class="hljs-selector-class">.rel</span><span class="hljs-selector-class">.data</span> 被模块引用的全局变量的重定位信息。<span class="hljs-selector-class">.debug</span> 调试符号表，文件中定义的局部变量，以及其类型<span class="hljs-selector-class">.line</span> <span class="hljs-selector-class">.text</span>中的行号和对应的机器指令的映射<span class="hljs-selector-class">.strtab</span> 字符串表节头部表</code></pre><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><pre><code class="hljs mathematica">当与静态库进行链接的时候，构建出的可执行文件实际上只复制静态库中引用的目标模块，它只需要包含较少的模块。linux中静态库以存档的形式放在磁盘中，是一组连接起来的可重定位目标文件的集合，有头部描述每个文件的大小和位置，存档文件为.a文件。假设有可重定位目标文件集合<span class="hljs-keyword">E</span>，未解析的符号U，前面输入文件定义的符号集合<span class="hljs-keyword">D</span>。静态链接的时候是从左到右扫描，添加符号，如果文件是目标文件，那么就会添加到<span class="hljs-keyword">E</span>中，然后修改U，<span class="hljs-keyword">D</span>。如果是静态库中的每个可重定位目标文件，那么就会比较U中的符号这个文件中有没有，有就添加到<span class="hljs-keyword">E</span>，然后修改U，<span class="hljs-keyword">D</span>，如果没有那么直接丢弃。但是如果定义的符号的库出现在引用符号的库之前，那么就会链接失败，所以顺序很重要。所以我们一般把库都放在链接命令的末尾，如果各个库之间没有相互引用，那么顺序是任意的，如果有相互引用，那么需要按照一定的顺序</code></pre><h2 id="可执行目标文件"><a href="#可执行目标文件" class="headerlink" title="可执行目标文件"></a>可执行目标文件</h2><pre><code class="hljs asciidoc">ELF头 描述总体格式，程序的入口点段头部表 <span class="hljs-title">.init 初始化代码时调用的</span><span class="hljs-title">.text</span><span class="hljs-title">.rodata</span><span class="hljs-title">.data</span><span class="hljs-title">.bss</span>其他的像符号表可重定位条目都没了</code></pre><pre><code class="hljs sqf">加载器加载可执行目标文件时在linux中使用execve函数来调用，在程序头部表的引导下，然后将可执行目标文件的片（chunk）代码和数据复制到内存，然后跳转到第一个入口点（<span class="hljs-variable">_start</span>）运行该程序。这个入口是在系统目标文件ctrl.o中定义的，然后<span class="hljs-variable">_start</span>调用<span class="hljs-variable">__libc_start_main</span>,此函数定义在libc.o中，它初始化环境，调用用户的main函数，处理返回值，需要时将控制返回给内核。实际上当父shell进程生成一个子进程的时候，foke继承父进程的所有内容，然后删除子进程的虚拟内存段，然后创建新的代码数据，堆栈段，并用虚拟地址空间的页映射可执行目标文件的片（chunk），代码段和数据段初始化为可执行文件的内容。然后跳到<span class="hljs-variable">_start</span>，执行main</code></pre><p>代码段总是从0x400000开始，然后地址从低到高分别是数据段，堆，栈，内核内存。</p><p>数据段要求内存对齐，因此有间隙，</p><h2 id="动态链接共享库"><a href="#动态链接共享库" class="headerlink" title="动态链接共享库"></a>动态链接共享库</h2><p>静态链接的缺点在于每次需要复制静态库中的模块到最终的文件中，同时如果静态库更新了，需要重新链接。<br>使用动态共享库使得每次运行或者加载的时候才将文件加载到内存中，进行连接，重定位符号引用，不需要复制模块，只复制一些符号表和重定位信息，而且只有一个副本，由不同的进程共享</p><p>linux 中dlopen函数用来在运行的时候加载和链接共享库</p><h3 id="JAVA-JNI-java-native-interface-java本地接口"><a href="#JAVA-JNI-java-native-interface-java本地接口" class="headerlink" title="JAVA JNI(java native interface)java本地接口"></a>JAVA JNI(java native interface)java本地接口</h3><p>他是将本地的C函数foo编译到一个共享库中，然后当正在运行的java程序试图调用foo时，会使用dlopen动态链接和加载foo.so，然后调用foo</p><h2 id="位置无关代码（PIC"><a href="#位置无关代码（PIC" class="headerlink" title="位置无关代码（PIC)"></a>位置无关代码（PIC)</h2><p>可以加载而无需重定位的代码称为PIC，使用-fpic，生成pic代码，共享库的生成总是需要这个选项，对于共享文件内部，是不需要做什么的，因为进行引用的时候直接用PC相对寻址就好，但是外部过程和全局变量需要特殊的技巧。</p><h3 id="PIC数据引用"><a href="#PIC数据引用" class="headerlink" title="PIC数据引用"></a>PIC数据引用</h3><p>有一个事实是这样的：无论在内存的哪里加载目标模块（包括共享目标模块），数据段和代码段的距离总是不变的。</p><p>同时在数据段中会有一个全局偏移量表GOT，每个被这个模块引用的全局数据目标都有一个条目，动态链接器会重定位每个条目，使其包含正确的地址，比如说调用一个A，是在其他模块定义的，然后它就会去通过GOT间接访问。</p><h3 id="PIC函数调用"><a href="#PIC函数调用" class="headerlink" title="PIC函数调用"></a>PIC函数调用</h3><p>使用了延迟绑定技术，即将过程地址的绑定推迟到第一次调用该过程时候。<br>优点在于当一个共享库的函数太多的时候，将地址绑定推迟到第一次调用时，可以减少很多不需要的重定位，虽然第一次很慢，但是后面都很快，只需要一条指令和一个间接的内存引用。</p><p>他是通过GOT和过程链接表PLT实现的，GOT属于数据段，PLT数据代码段。</p><p>第一次的时候，会先跳到PLT，然后跳到对应的GOT，然后跳到PLT，然后在栈中压入一些参数，然后跳到动态链接器，使用栈中的条目确定函数地址，然后重写GOT的内容，再调用函数。</p><p>后面每次就直接会先跳到PLT，然后跳到对应的GOT，然后跳到对应函数。</p><h2 id="库打桩机制"><a href="#库打桩机制" class="headerlink" title="库打桩机制"></a>库打桩机制</h2><p>它可以截获对共享库函数的调用，转而执行我们自己的代码。</p><p>可以在编译时，运行时，或者加载和链接时刻。</p><h3 id="编译时打桩"><a href="#编译时打桩" class="headerlink" title="编译时打桩"></a>编译时打桩</h3><p>在编译的时候的命令行参数加入-I. ，此时会进行打桩，在搜索系统目录的时候优先搜索当前目录。</p><h3 id="链接时打桩"><a href="#链接时打桩" class="headerlink" title="链接时打桩"></a>链接时打桩</h3><p>例如使用—wrap f 标志进行链接时打桩，这个会将f符号解释为<strong>wrap_f，将</strong>real_f的符号解释为f。</p><h3 id="运行时打桩"><a href="#运行时打桩" class="headerlink" title="运行时打桩"></a>运行时打桩</h3><p>编译时打桩需要访问程序的源代码，链接时打桩需要访问程序的可重定位对象文件。运行时打桩只需要访问可执行目标文件。</p><p>它基于动态链接器的LD_PRELOAD.将LD_PRELOAD设置为一个路径，然后当加载和执行一个程序的时候，需要解析其他未定义的引用的时候，会优先搜索LD_PRELOAD库，然后才搜索其他的库。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>操作系统</tag>
      
      <tag>静态链接</tag>
      
      <tag>动态链接</tag>
      
      <tag>库打桩</tag>
      
      <tag>位置无关代码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++运行时的内存映像</title>
    <link href="/2022/03/05/C++/C++%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F/"/>
    <url>/2022/03/05/C++/C++%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p>主要分为这几个部分，</p><pre><code class="hljs mipsasm">地址从高到低系统内核的内存栈的内存，由高地址向低地址延申（这里有一个rsp，栈指针）共享库的内存映射区域堆内存，由低地址向高地址延申（这里有一个<span class="hljs-keyword">brk指针）</span><span class="hljs-keyword"></span><span class="hljs-keyword">已经初始化全局数据段和静态变量区data，以及未初始化的全局变量区和静态变量bss</span><span class="hljs-keyword"></span><span class="hljs-keyword">只读数据段和代码段 </span> - 常量区(只读数据段，rodata) ，虚函数表就放在这个位置- 代码段(<span class="hljs-meta">.text</span>),虚函数放在这个位置</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie和session的区别</title>
    <link href="/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>1、由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车。</p><p>当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。</p><p>这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p><p>2、思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。</p><p>有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p><p>3、Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p><p>所以，总结一下：</p><p>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。</p><p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何实现DNS劫持</title>
    <link href="/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0DNS%E5%8A%AB%E6%8C%81/"/>
    <url>/2022/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0DNS%E5%8A%AB%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS-劫持即域名劫持，是通过将原域名对应的-IP-地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。"><a href="#DNS-劫持即域名劫持，是通过将原域名对应的-IP-地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。" class="headerlink" title="DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。"></a>DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。</h2><h2 id="域名劫持往往只能在特定的网络范围内进行，范围外的-DNS-服务器能够返回正常的-IP-地址。"><a href="#域名劫持往往只能在特定的网络范围内进行，范围外的-DNS-服务器能够返回正常的-IP-地址。" class="headerlink" title="域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。"></a>域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。</h2><h2 id="攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的-DNS-服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。"><a href="#攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的-DNS-服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。" class="headerlink" title="攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。"></a>攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址。</h2><h2 id="具体实施步骤如下："><a href="#具体实施步骤如下：" class="headerlink" title="具体实施步骤如下："></a>具体实施步骤如下：</h2><p>1.获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息。</p><p>2.控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取。</p><p>3.修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等。</p><p>4.使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持。</p><h2 id="用户端的一些预防手段："><a href="#用户端的一些预防手段：" class="headerlink" title="用户端的一些预防手段："></a>用户端的一些预防手段：</h2><p>直接通过 IP 地址访问网站，避开 DNS 劫持。<br>由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 8.8.8.8。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS为什么使用UDP</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8UDP/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8UDP/</url>
    
    <content type="html"><![CDATA[<p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的最大连接数目</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="如何标识一个TCP连接"><a href="#如何标识一个TCP连接" class="headerlink" title="如何标识一个TCP连接"></a>如何标识一个TCP连接</h2><p>在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。</p><h2 id="client最大tcp连接数"><a href="#client最大tcp连接数" class="headerlink" title="client最大tcp连接数"></a>client最大tcp连接数</h2><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535，这些连接可以连到不同的server ip。</p><h2 id="server最大tcp连接数"><a href="#server最大tcp连接数" class="headerlink" title="server最大tcp连接数"></a>server最大tcp连接数</h2><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p><h2 id="实际的tcp连接数"><a href="#实际的tcp连接数" class="headerlink" title="实际的tcp连接数"></a>实际的tcp连接数</h2><p>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。</p><p>对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万 是没问题的，国外 Urban Airship 公司在产品环境中已做到 50 万并发 。在实际应用中，对大规模网络应用，还需要考虑C10K 问题。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP地址和MAC地址作用的区别</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%92%8CMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%92%8CMAC%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>简单着说，IP 地址主要用来网络寻址用的，就是大致定位你在哪里，而 MAC 地址，则是身份的唯一象征，通过 MAC 来唯一确认这人是不是就是你，MAC 地址不具备寻址的功能。</p><p>IP 地址是基于逻辑的，比较灵活，不受硬件的限制，也容易记忆。而 MAC地址在一定程度上与硬件一致，是基于物理的，能够标识具体的网络节点。这两种地址各有优点，使用时也因条件不同而采取不同的地址 [6]  。</p><p>大多数接入Internet的方式是把主机通过局域网组织在一起，然后再通过交换机或路由器等设备和 Internet 相连接。这样一来就出现了如何区分具体用户，防止 IP地址被盗用的问题。由于IP地址只是逻辑上的标识，任何人都能随意修改，因此不能用来具体标识一个用户。而 MAC地址则不然，它是固化在网卡里面的。从理论上讲，除非盗来硬件即网卡，否则一般是不能被冒名顶替的。基于 MAC 地址的这种特点，因此局域网采用了用MAC地址来标识具体用户的方法  。</p><p>在具体的通信过程中，通过交换机内部的交换表把 MAC地址和 IP 地址一一对应。当有发送给本地局域网内一台主机的数据包时，交换机首先将数据包接收下来，然后把数据包中的 IP 地址按照交换表中的对应关系映射成 MAC地址，然后将数据包转发到对应的 MAC地址的主机上去。这样一来，即使某台主机盗用了这个 IP 地址，但由于此主机没有对应的 MAC地址，因此也不能收到数据包，发送过程和接收过程类似 。</p><p>所以，无论是局域网，还是广域网中的计算机之间进行通信时，最终都表现为将数据包从某种形式的链路上的一个初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的传递都是由 ARP（Address Resolution Protocol：地址解析协议）负责将IP地址映射到 MAC地址上来完成的  。</p><p>身份证就是用来证明一个人的身份。平日身份证的作用并不是很大，但是到了有的关键时刻，必须有身份证来说明一个人的一切。那么，IP地址与MAC地址绑定，就如同在日常生活中一个人与身份证的关系。因为，IP地址可以随意的，但MAC地址是唯一说明IP地址身份的。</p><p>从上面看如果没有ip地址，只用mac地址，那么很难进行网络寻址，不知道目标主机在哪个区域，但是mac地址就是在局域网中映射成mac地址，然后转发给那个主机，确保是你，没有被冒用。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPV4不够如何解决</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPV4%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IPV4%E4%B8%8D%E5%A4%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>目前主要有以下两种方式：  </p><p>1、其实我们平时上网，电脑的 IP 地址都是属于私有地址，我无法出网关，我们的数据都是通过网关来中转的，这个其实 NAT 协议，可以用来暂缓 IPV4 地址不够，关于 NAT，具体可以看我写的这篇文章：什么是 NAT 网络地址转换协议？  </p><p>2、IPv6 ：作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址，而这个数量级，即使是给地球上每一颗沙子都分配一个IP地址，该协议能够从根本上解决 IPv4 地址不够用的问题。</p><p>NAT协议：在私有地址和全局地址之间转换的协议。</p><p>就是使得私有ip通过转换成网关的地址和ip去访问东西，然后返回结果时再映射为私有地址。</p><pre><code>    首先什么是私有地址？私有地址是不能用在Internet上(路由器将丢弃寻址这种地址的包)的内部地址。这些地址是不能够在公网上面用的，只能用在局域网的内部。私有地址有三种：①10.0.0.0~10.255.255.255/8 ②172.16.0.0~172.31.255.255/12 ③192.168.0.0~192.168.255.255/16 这些IP地址是用于私有的网络。与之对应的是全局地址，就是正规的自己电脑的地址，全网络承认。比如说，每个人都有自己的大名，走到哪里都能被承认，这就是自己的全局地址；但是在班级里面的外号，就是私有地址，只有班级里面的人知道，在外面别人都不知道这个外号对应的是谁。</code></pre><p>、</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICMP以及相关应用</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ICMP%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>ICMP 主要有两个应用，一个是 Ping，一个是 Traceroute。</p><h2 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h2><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><h2 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h2><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p><p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</p><p>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</p><p>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</p><p>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SYN洪水攻击</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SYN%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SYN%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<p>SYN Flood 又称 SYN 洪水攻击，也是拒绝服务攻击的一种，是一种曾经很经典的攻击方式。攻击者利用TCP协议的安全缺陷，不断发送一系列的SYN请求到目标系统，消耗服务器系统的资源，从而导致目标服务器不响应合法流量请求。</p><p>在谈SYN flood 之前，我们先了解一下一次正常的网络请求都有哪些步骤，从而更清晰的了解SYN Flood的攻击方式。</p><p>一般一次正常的网络请求分以下几个步骤：</p><pre><code>        域名解析        TCP握手建立链接        客户端发起请求        服务器响应请求        客户端解析并且渲染页面        至此一次请求结束。</code></pre><p>而此种攻击正是发生在TCP握手的阶段。TCP握手一般分为三步。客户端发送SYN请求数据包。服务器回复（ACK）确认包。客户端再次回复（ACK）确认包。至此，TCP握手阶段结束。</p><h2 id="SYN-Flood-SYN-洪水攻击原理"><a href="#SYN-Flood-SYN-洪水攻击原理" class="headerlink" title="SYN Flood / SYN 洪水攻击原理"></a>SYN Flood / SYN 洪水攻击原理</h2><p>为了创建拒绝服务，攻击者利用的正是TCP协议的安全缺陷。在接收到初始SYN数据包之后，服务器用一个或多个SYN / ACK数据包进行响应，并等待握手中的最后一步。这是它的工作原理。</p><p>此种攻击是攻击者向目标服务器发送大量的SYN数据包，服务器会响应每一个请求然后返回ACK确认包，并且等待客户端的最终响应。</p><p>因为攻击者通常会采用虚拟ip，所以也就意味着服务器永远不可能接收到最终的确认包。这种情况下当服务器未接收到最终ACK数据包的时候，服务端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接。</p><p>这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）；一个用户出现异常导致服务器的一个线程等待1分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况（伪造IP地址），那么服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源。从而造成服务器的崩溃，即使你的服务器系统资源够强大，服务端也将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小）。</p><p>此时，正常用户就会觉得服务器失去响应，这种情况就叫做，服务端收到了SYN Flood攻击（SYN 洪水攻击）</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TIME_WAIT 状态会导致什么问题，怎么解决</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%87%E5%A4%9A%E7%9A%84TIME_WAIT%20%E7%8A%B6%E6%80%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%87%E5%A4%9A%E7%9A%84TIME_WAIT%20%E7%8A%B6%E6%80%81%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p><p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p><p>下面是读者提供的具体操作</p><p>修改配置文件：/etc/sysctl.conf</p><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</p><p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 长连接短连接使用场景是什么</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个 TCP 连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多， 所以每个操作完后都不断开，下次处理时直接发送数据包就 OK 了，不用建立 TCP 连接。例如： 数据库的连接用长连接， 如果用短连接频繁的通信会造成 socket 错误，而且频繁的 socket创建也是对资源的浪费。</p><p>而像 WEB 网站的 http 服务一般都用短链接，因为长连接对于服务端来说会耗费一定的 资源，而像 WEB 网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源， 如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS的解析过程</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<ol><li><p>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</p></li><li><p>本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</p></li></ol><h2 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h2><p>为了提升域名查询效率，设计了域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间（即TTL值）的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。</p><p>目前，除了传统的递归DNS服务器（如运营商的Local DNS, 114dns,Google public DNS等）外，计算机中DNS记录在本地也有两种缓存方式：浏览器缓存和操作系统(OS)缓存。在浏览器中访问的时候，会优先访问浏览器缓存，如果未命中则访问OS缓存，最后再访问递归DNS服务器，然后递归DNS服务器会递归式的查找域名记录，然后返回结果。那么浏览器DNS缓存和操作系统DNS缓存又是怎样的呢？</p><h3 id="浏览器DNS缓存："><a href="#浏览器DNS缓存：" class="headerlink" title="浏览器DNS缓存："></a>浏览器DNS缓存：</h3><p>首先，浏览器DNS缓存的时间跟DNS服务器返回的TTL值无关。浏览器在获取网站域名的实际IP地址后会对其IP进行缓存，减少网络请求的损耗。每种浏览器都有一个固定的DNS缓存时间，如Chrome的过期时间是1分钟，在这个期限内不会重新请求DNS。常用的浏览器的DNS缓存时间如下：Chrome：为了加快访问速度，Google Chrome浏览器采用了预提DNS记录，在本地建立DNS缓存的方法，加快网站的连接速度。在Chrome地址栏中输入chrome://net-internals/#dns 就可以看各域名的DNS 缓存时间。默认，Chrome对每个域名会默认缓存60s：</p><h3 id="操作系统DNS缓存："><a href="#操作系统DNS缓存：" class="headerlink" title="操作系统DNS缓存："></a>操作系统DNS缓存：</h3><p>OS缓存会参考DNS服务器响应的TTL值，但是不完全等于TTL值。</p><h3 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h3><p>Linux系统的nscd服务可以实现DNS缓存的功能。nscd会缓存三种服务passwd,group,hosts，所以它会记录三个库，分别对应源/etc/passwd, /etc/hosts 和/etc/resolv.conf每个库保存两份缓存，一份是找到记录的，一份是没有找到记录的。每一种缓存都保存有生存时间（TTL）。其作用就是增加cache ，加快如DNS的解析等的速度。配置文件为/etc/nscd.conf    默认该服务在redhat或centos下是关闭的，可以通过services nscd start开启。缓存DB文件在/var/db/nscd下。可以通过nscd -g查看统计的信息</p><p>清除缓存</p><ol><li>nscd -i passwd</li><li>nscd -i group</li><li>nscd -i hosts<br>除了上面的方法，重启nscd服务同样可以达到清理cache的目的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在浏览器中输入 URL 地址到显示主页的过程？</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；  </p><p>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手； </p><p> 发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；  </p><p>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； </p><p> 浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。  连接结束。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是粘包以及如何解决</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%B2%98%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。  </p><pre><code>    TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；    从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。  </code></pre><p> 基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。 </p><p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p><p>发送方产生粘包 </p><p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。 </p><p>接收方产生粘包 </p><p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p><p>分包机制一般有两个通用的解决方法： </p><p> 特殊字符控制； </p><p> 在包头首都添加数据包的长度。  </p><p> 如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。  </p><p> tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARQ协议和停止等待协议</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARQ%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ARQ%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h2><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认收到。</p><h2 id="自动重传请求-ARQ-协议"><a href="#自动重传请求-ARQ-协议" class="headerlink" title="自动重传请求 ARQ 协议"></a>自动重传请求 ARQ 协议</h2><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p><h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP协议是如何保证可靠传输的。</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E5%8D%8F%E8%AE%AE%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；  </p><p>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。</p><p>TCP 将对失序数据进行重新排序，然后才交给应用层；  </p><p>丢弃重复数据：对于重复数据，能够丢弃重复数据；  </p><p>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；  </p><p>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；  </p><p>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP和HTTPS的区别</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；</p><p>Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同： </p><p> 1、端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；  </p><p> 2、资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；  </p><p> 3、开销：Https通信需要证书，而证书一般需要向认证机构购买； 　 Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p><h2 id="一般http中存在如下问题："><a href="#一般http中存在如下问题：" class="headerlink" title="一般http中存在如下问题："></a>一般http中存在如下问题：</h2><p>请求信息明文传输，容易被窃听截取。</p><p>数据的完整性未校验，容易被篡改</p><p>没有验证对方身份，存在冒充危险</p><h2 id="HTTPS-协议过程"><a href="#HTTPS-协议过程" class="headerlink" title="HTTPS 协议过程"></a>HTTPS 协议过程</h2><p>SSL握手协议的过程</p><p>握手阶段分成以下五步：</p><pre><code>  第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。  第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。  第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。  第四步，服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。  第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成&quot;对话密钥&quot;（session key），用来加密接下来的整个对话过程。</code></pre><h2 id="为什么非得这么麻烦，非要三个随机数呢？"><a href="#为什么非得这么麻烦，非要三个随机数呢？" class="headerlink" title="为什么非得这么麻烦，非要三个随机数呢？"></a>为什么非得这么麻烦，非要三个随机数呢？</h2><p>这就必须说 TLS 的设计者考虑得非常周到了，他们不信任客户端或服务器伪随机数的可靠性，为了保证真正的“完全随机”“不可预测”，把三个不可靠的随机数混合起来，那么“随机”的程度就非常高了，足够让黑客难以猜测</p><p>客户端是没有证书的，也就没有公钥和私钥。<br>SSL握手阶段，服务器把证书传输给客户端，同时也就传输了公钥（公钥是证书的一部分）。</p><h3 id="有一个问题？如何保证公钥传输正确，如何防止中间人攻击？"><a href="#有一个问题？如何保证公钥传输正确，如何防止中间人攻击？" class="headerlink" title="有一个问题？如何保证公钥传输正确，如何防止中间人攻击？"></a>有一个问题？如何保证公钥传输正确，如何防止中间人攻击？</h3><pre><code> 找到一个拥有公信力、大家都认可的认证中心(CA)。服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成信息摘要 为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成数字签名。 并且，最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成数字证书 当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到另外一份信息摘要。最后把两份信息摘要进行对比，如果一样，则证明这个人是服务器，否则就不是。 这样，就可以保证服务器的公钥安全着交给客户端了。从而防止了中间人攻击。</code></pre><p>由客户端来对这个证书进行有效性认可，再由这个客户端来生成对称密钥。<br>对称密钥用服务器证书中的公钥加密后，传回给服务器。只有服务器才能解密这个信息，也就只有服务器才知道你的对称密钥。<br>只要这个SSL连接没有关闭，后续的所有数据，无论是客户端发出的还是服务器发出的，均会使用这个对称密钥加密。<br>对称加密算法中，依赖的是密钥的保密性，只要密钥没有被泄露，对称加密的结果被截获也没有什么意义。而密钥是用公钥加密的，只能由服务器解开。</p><h2 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h2><p>HTTPS协议多次握手，导致页面的加载时间延长近50%；</p><p>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗；</p><p>申请SSL证书需要钱，功能越强大的证书费用越高。</p><p>SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲一下网络五层模型，每一层的职责？</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BD%91%E7%BB%9C%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B%EF%BC%8C%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E8%81%8C%E8%B4%A3/</url>
    
    <content type="html"><![CDATA[<p>天各一方的两台计算机是如何通信的呢？ 在成千上万的计算机中，为什么一台计算机能够准确着寻找到另外一台计算机，并且把数据发送给它呢？可能很多人都听说过网络通信的 5 层模型，但是可能并不是很清楚为什么需要五层模型，五层模型负责的任务也有可能经常混淆。 </p><p>下面是网络通信的五层模型   </p><p>说实话，五层模型的具体内容还是极其复杂的，不过今天这篇文章，我将用最简洁的模式，通过网络通信的五层模型来讲解一台计算机是如何找到另外一台计算机并且把数据发送给另一台计算机的，就算你没学过计算机网络，也能够听的懂。 </p><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h2><p> 一台计算机与另一台计算机要进行通信，第一件要做的事是什么？ 当然是要把这台计算机与另外的其他计算机连起来啊，这样，我们才能把数据传输过去。 例如可以通过光纤啊，电缆啊，双绞线啊等介质把他们连接起来，然后才能进行通信。</p><pre><code> 也就是说，物理层负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号。  </code></pre><h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h2><p> 前面说了，物理层它只是单纯着负责把计算机连接起来，并且在计算机之间传输0，1这样的电信号。 如果这些0，1组合的传送毫无规则的话，计算机是解读不了的。 一大堆0，1谁知道是什么鬼啊。</p><p>  因此，我们需要制定一套规则来进行0，1的传送。 例如多少个电信号为一组啊，每一组信号应该如何标识才能让计算机读懂啊等等。</p><pre><code>于是，有了以太网协议。 </code></pre><h3 id="1-以太网协议"><a href="#1-以太网协议" class="headerlink" title="1. 以太网协议"></a>1. 以太网协议</h3><pre><code>以太网协议规定，一组电信号构成一个数据包，我们把这个数据包称之为帧。 每一个桢由标头(Head)和数据(Data)两部分组成。帧的大小一般为 64 – 1518 个字节。 假如需要传送的数据很大的话，就分成多个桢来进行传送。  对于表头和数据这两个部分，他们存放的都是一些什么数据呢？ 我猜你眯着眼睛都能想到他们应该放什么数据。 毫无疑问，我们至少得知道这个桢是谁发送，发送给谁的等这些信息吧？ 所以标头部分主要是一些说明数据，例如发送者，接收者等信息。 而数据部分则是这个数据包具体的，想给接守者的内容。  大家想一个问题，一个桢的长度是 64~1518 个字节，也就是说桢的长度不是固定的，那你觉得标头部分的字节长度是固定的吗？ 它当然是固定的啊，假如不是固定的，每个桢都是单独发的，那计算机怎么知道标头是几个字节，数据是几个字节呢。 所以标头部分的字节是固定的，并且固定为18个字节。   把一台计算的的数据通过物理层和链路层发送给另一台计算机，究竟是谁发给谁的，计算机与计算机之间如何区分，，你总得给他们一个唯一的标识吧？  于是，MAC 地址出现了。</code></pre><h3 id="2-MAC-地址"><a href="#2-MAC-地址" class="headerlink" title="2. MAC 地址"></a>2. MAC 地址</h3><p>连入网络的每一个计算机都会有网卡接口，每一个网卡都会有一个唯一的地址，这个地址就叫做 MAC 地址。 计算机之间的数据传送，就是通过 MAC 地址来唯一寻找、传送的。</p><p>MAC地址 由 48 个二进制位所构成，在网卡生产时就被唯一标识了。</p><h3 id="3-广播与ARP协议"><a href="#3-广播与ARP协议" class="headerlink" title="3. 广播与ARP协议"></a>3. 广播与ARP协议</h3><h4 id="1-广播"><a href="#1-广播" class="headerlink" title="(1). 广播"></a>(1). 广播</h4><p>如图，假如计算机 A 知道了计算机 B 的 MAC 地址，然后计算机 A 想要给计算机 B 传送数据，虽然计算机 A 知道了计算机 B 的 MAC 地址，可是它要怎么给它传送数据呢？ 计算机 A 不仅连着计算机 B，而且计算机 A 也还连着其他的计算机。 虽然计算机 A 知道计算机 B 的 MAC 地址，可是计算机 A 却不知道知道计算机 B 是分布在哪边路线上，为了解决这个问题，于是，有了</p><p>广播的出现。</p><p>在同一个子网中，计算机 A 要向计算机 B 发送一个数据包，这个数据包会包含接收者的 MAC 地址。 当发送时，计算机 A 是通过广播的方式发送的，这时同一个子网中的计算机 C, D 也会收到这个数据包的，然后收到这个数据包的计算机，会把数据包的 MAC 地址取出来，与自身的 MAC 地址对比，如果两者相同，则接受这个数据包，否则就丢弃这个数据包。 这种发送方式我们称之为广播,就像我们平时在广场上通过广播的形式呼叫某个人一样，如果这个名字是你，你就理会一下，如果不是你，你就当作听不见</p><h4 id="2-ARP-协议。"><a href="#2-ARP-协议。" class="headerlink" title="(2). ARP 协议。"></a>(2). ARP 协议。</h4><p>那么问题来了，计算机 A 是如何知道计算机 B 的 MAC 地址的呢？ 这个时候就得由 ARP 协议这个家伙来解决了，不过 ARP 协议会涉及到IP地址，我们下面才会扯到IP地址。 因此我们先放着，就当作是有这么一个 ARP 协议，通过它我们可以知道子网中其他计算机的 MAC 地址。</p><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h2><p>上面我们有说到子网这个关键词，实际上我们所处的网络，是由无数个子网络构成的。 广播的时候，也只有同一个子网里面的计算机能够收到。</p><p>假如没有子网这种划分的话，计算机 A 通过广播的方式发一个数据包给计算机 B , 其他所有计算机也都能收到这个数据包，然后进行对比再舍弃。 世界上有那么多它计算机，每一台计算机都能收到其他所有计算机的数据包，那就不得了了。 那还不得奔溃。 因此产生了子网这么一个东西。</p><p>那么问题来了，我们如何区分哪些 MAC 地址是属于同一个子网的呢？ 假如是同一个子网，那我们就用广播的形式把数据传送给对方，如果不是同一个子网的，我们就会把数据发给网关，让网关进行转发。</p><p>为了解决这个问题，于是，有了 IP 协议。</p><h3 id="3-DNS服务器"><a href="#3-DNS服务器" class="headerlink" title="3. DNS服务器"></a>3. DNS服务器</h3><p>这里再说一个问题，我们是如何知道对方计算机的IP地址的呢？ 这个问题可能有人会觉得很白痴，心想，当然是计算机的操作者来进行输入了。 这没错，当我们想要访问某个网站的时候，我们可以输入IP来进行访问，但是我相信绝大多数人是输入一个网址域名的，例如访问百度是输入 www.baidu.com 这个域名。 其实当我们输入这个域名时，会有一个叫做DNS服务器的家伙来帮我们解析这个域名，然后返回这个域名对应的IP给我们的。</p><p>因此，网络层的功能就是让我们在茫茫人海中，能够找到另一台计算机在哪里，是否属于同一个子网等。</p><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h2><p>通过物理层、数据链路层以及网络层的互相帮助，我们已经把数据成功从计算机A传送到计算机B了，可是，计算机B里面有各种各样的应用程序，计算机该如何知道这些数据是给谁的呢？</p><p>这个时候，端口(Port)这个家伙就上场了，也就是说，我们在从计算机A传数据给计算表B的时候，还得指定一个端口，以供特定的应用程序来接受处理。</p><p>也就是说，传输层的功能就是建立端口到端口的通信。 相比网络层的功能是建立主机到主机的通信。</p><p>也就是说，只有有了IP和端口，我们才能进行准确着通信。 这个时候可能有人会说，我输入IP地址的时候并没有指定一个端口啊。 其实呢，对于有些传输协议，已经有设定了一些默认端口了。 例如http的传输默认端口是80，这些端口信息也会包含在数据包里的。</p><p>传输层最常见的两大协议是 TCP 协议和 UDP 协议，其中 TCP 协议与 UDP 最大的不同就是 TCP 提供可靠的传输，而 UDP 提供的是不可靠传输。</p><h2 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5. 应用层"></a>5. 应用层</h2><p>终于说到应用层了，应用层这一层最接近我们用户了。</p><p>虽然我们收到了传输层传来的数据，可是这些传过来的数据五花八门，有html格式的，有mp4格式的，各种各样。 你确定你能看的懂？</p><p>因此我们需要指定这些数据的格式规则，收到后才好解读渲染。 例如我们最常见的 Http 数据包中，就会指定该数据包是 什么格式的文件了。</p><p>总结<br>五层模型至此讲到这里。 对于有些层讲的比较简洁，就随便概况了一下。 因为如果我说的详细一点的话，篇幅肯定会特别特别长，我着已经是尽最大的努力以最简洁的方式来讲的了。 如果你想详细去了解，可以去买计算机网络相应的资料，强烈推荐《计算机网络：自顶向下》这本书。 希望我的讲解能让你对计算机之间数据的传输有个大概的了解。</p><h3 id="1-IP协议"><a href="#1-IP协议" class="headerlink" title="1. IP协议"></a>1. IP协议</h3><p>IP协议，它所定义的地址，我们称之为IP地址。 IP协议有两种版本，一种是 IPv4,另一种是 IPv6。 不过我们目前大多数用的还是 IPv4，我们现在也只讨论 IPv4 这个版本的协议。</p><p>这个 IP 地址由 32 位的二进制数组成，我们一般把它分成4段的十进制表示，地址范围为0.0.0.0~255.255.255.255。</p><p>每一台想要联网的计算机都会有一个IP地址。 这个IP地址被分为两部分，前面一部分代表网络部分，后面一部分代表主机部分。 并且网络部分和主机部分所占用的二进制位数是不固定的。</p><p>假如两台计算机的网络部分是一模一样的，我们就说这两台计算机是处于同一个子网中。 例如 192.168.43.1 和 192.168.43.2, 假如这两个 IP 地址的网络部分为 24 位，主机部分为 8 位。 那么他们的网络部分都为 192.168.43，所以他们处于同一个子网中。</p><p>可是问题来了，你怎么知道网络部分是占几位，主机部分又是占几位呢？ 也就是说，单单从两台计算机的IP地址，我们是无法判断他们的是否处于同一个子网中的。</p><p>这就引申出了另一个关键词————子网掩码。 子网掩码和IP地址一样也是 32 位二进制数，不过它的网络部分规定全部为 1，主机部分规定全部为 0.也就是说，假如上面那两个IP地址的网络部分为 24 位，主机部分为 8 位的话，那他们的子网掩码都为 11111111.11111111.11111111.00000000，即255.255.255.0。</p><p>那有了子网掩码，如何来判端IP地址是否处于同一个子网中呢。 显然，知道了子网掩码，相当于我们知道了网络部分是几位，主机部分是几位。 我们只需要把 IP 地址与它的子网掩码做与(and)运算，然后把各自的结果进行比较就行了，如果比较的结果相同，则代表是同一个子网，否则不是同一个子网。</p><p>例如，192.168.43.1和192.168.43.2的子码掩码都为255.255.255.0，把IP与子码掩码相与，可以得到他们都为192.168.43.0，进而他们处于同一个子网中。</p><h3 id="2-ARP协议"><a href="#2-ARP协议" class="headerlink" title="2. ARP协议"></a>2. ARP协议</h3><p>有了上面IP协议的知识，我们回来讲一下ARP协议。</p><p>有了两台计算机的IP地址与子网掩码，我们就可以判断出它们是否处于同一个子网之中了。</p><p>假如他们处于同一个子网之中，计算机A要给计算机B发送数据时。 我们可以通过ARP协议来得到计算机B的MAC地址。</p><p>ARP协议也是通过广播的形式给同一个子网中的每台电脑发送一个数据包(当然，这个数据包会包含接收方的IP地址)。 对方收到这个数据包之后，会取出IP地址与自身的对比，如果相同，则把自己的MAC地址回复给对方，否则就丢弃这个数据包。 这样，计算机A就能知道计算机B的MAC地址了。</p><p>可能有人会问，知道了MAC地址之后，发送数据是通过广播的形式发送，询问对方的MAC地址也是通过广播的形式来发送，那其他计算机怎么知道你是要传送数据还是要询问MAC地址呢？ 其实在询问MAC地址的数据包中，在对方的MAC地址这一栏中，填的是一个特殊的MAC地址，其他计算机看到这个特殊的MAC地址之后，就能知道广播想干嘛了。</p><p>假如两台计算机的IP不是处于同一个子网之中，这个时候，我们就会把数据包发送给网关，然后让网关让我们进行转发传送</p><h3 id="注意ARP协议"><a href="#注意ARP协议" class="headerlink" title="注意ARP协议"></a>注意ARP协议</h3><p>arp协议在，在OSI模型中属于链路层。 arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。 它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。 arp协议，也称地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。"><a href="#SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。" class="headerlink" title="SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。"></a>SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</h2><p> 1). SQL注入攻击的总体思路  　</p><p> 　(1). 寻找到SQL注入的位置 　</p><p> 　(2). 判断服务器类型和后台数据库类型 　</p><p> 　(3). 针对不同的服务器和数据库特点进行SQL注入攻击 </p><p>  2). SQL注入攻击实例  比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录： </p><p>   用户名： ‘or 1 = 1 — 密 码： BashCopy 用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?  下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：  String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; JavaCopy</p><pre><code>因此，当输入了上面的用户名和密码，上面的SQL语句变成：  SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’ JavaCopy 分析上述SQL语句我们知道，username= or 1=1 这个语句一定会成功；然后后面加两个 -，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。  </code></pre><h2 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h2><pre><code> (1). 参数绑定  使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和$来获取参数值。   当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入； 当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。   (2). 使用正则表达式过滤传入的参数</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP地址分类（A类 B类 C类 D类 E类）</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%88A%E7%B1%BB%20B%E7%B1%BB%20C%E7%B1%BB%20D%E7%B1%BB%20E%E7%B1%BB%EF%BC%89/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%88A%E7%B1%BB%20B%E7%B1%BB%20C%E7%B1%BB%20D%E7%B1%BB%20E%E7%B1%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    全0和全1的都保留不用。</p><p>A类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</p><p>B类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</p><p>C类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</p><p>D类：是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1]  。</p><p>E类：是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</p><p>在IP地址3种主要类型里，各保留了3个区域作为私有地址，其地址范围如下：<br>A类地址：10.0.0.0～10.255.255.255<br>B类地址：172.16.0.0～172.31.255.255<br>C类地址：192.168.0.0～192.168.255.255</p><p>回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP滑动窗口和拥塞控制详解</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="滑动窗口（流量控制）"><a href="#滑动窗口（流量控制）" class="headerlink" title="滑动窗口（流量控制）"></a>滑动窗口（流量控制）</h2><p>滑动窗口的定义：    1.“窗口”对应的是一段可以被发送的字节序列，其连续的范围称为窗口；2.“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。</p><p>滑动窗口的作用：    是一种流量控制方法，该协议允许发送方在停止等待确认前可以连续发送发个分组。由于发送方不必每发送一个分组就停下来等待确认，因此该协议可以加速数据的传输。</p><p>1 TCP协议的两端分别是发送者A和接受者B，由于是全双工通讯的，因此A and B应该同时维护着一个独立的发送缓冲区和接受缓冲区，由于对等性，我们以A发送B接受的情况作为例子；</p><p>-2 发送窗口是发送缓存的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区了；当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小。</p><p>-3 发送窗口相关的四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）；已发送但未收到确认的数据（位于发送窗口之中）；允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不需要发送的数据。</p><p>-4 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送。(即受到接收方的ACK)</p><p>当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h2 id="拥塞控制原理-原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。"><a href="#拥塞控制原理-原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。" class="headerlink" title="拥塞控制原理 原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。"></a>拥塞控制原理 原因是有可能整个网络环境特别差，容易丢包，那么发送端就应该注意了。</h2><p>主要用三种方法：  </p><h2 id="慢启动阈值-拥塞避免-快速重传-快速恢复-慢启动阈值-拥塞避免"><a href="#慢启动阈值-拥塞避免-快速重传-快速恢复-慢启动阈值-拥塞避免" class="headerlink" title="慢启动阈值 + 拥塞避免 快速重传 快速恢复 慢启动阈值 + 拥塞避免"></a>慢启动阈值 + 拥塞避免 快速重传 快速恢复 慢启动阈值 + 拥塞避免</h2><p>对于拥塞控制来说，TCP 主要维护两个核心状态：  </p><h2 id="拥塞窗口（cwnd）-慢启动阈值（ssthresh）"><a href="#拥塞窗口（cwnd）-慢启动阈值（ssthresh）" class="headerlink" title="拥塞窗口（cwnd） 慢启动阈值（ssthresh）"></a>拥塞窗口（cwnd） 慢启动阈值（ssthresh）</h2><p>在发送端使用拥塞窗口来控制发送窗口的大小。  然后采用一种比较保守的慢启动算法来慢慢适应这个网络，在开始传输的一段时间，发送端和接收端会首先通过三次握手建立连接，确定各自接收窗口大小，然后初始化双方的拥塞窗口，接着每经过一轮 RTT（收发时延），拥塞窗口大小翻倍，直到达到慢启动阈值。  </p><p>然后开始进行拥塞避免，拥塞避免具体的做法就是之前每一轮 RTT，拥塞窗口翻倍，现在每一轮就加一个。  </p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）  </p><p>选择性重传：报文首部可选性中加入 SACK 属性，通过 left edge 和 right edge 标志那些包到了，然后重传没到的包  </p><h2 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h2><p>如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：  会将拥塞阈值降低为 拥塞窗口的一半 然后拥塞窗口大小变为拥塞阈值 接着 拥塞窗口再进行线性增加，以适应网络状况</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%A8%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E5%AE%8C%E4%BA%86_%E8%BF%98%E4%B8%8D%E6%83%B3%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E6%80%8E%E4%B9%88%E5%8A%9E_%E6%80%8E%E4%B9%88%E7%BB%B4%E6%8C%81/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%A8%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E5%AE%8C%E4%BA%86_%E8%BF%98%E4%B8%8D%E6%83%B3%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E6%80%8E%E4%B9%88%E5%8A%9E_%E6%80%8E%E4%B9%88%E7%BB%B4%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<h2 id="在-HTTP-中响应体的-Connection-字段指定为-keep-alive"><a href="#在-HTTP-中响应体的-Connection-字段指定为-keep-alive" class="headerlink" title="在 HTTP 中响应体的 Connection 字段指定为 keep-alive"></a>在 HTTP 中响应体的 Connection 字段指定为 keep-alive</h2><p>connetion:keep-alive;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP状态码301和302的区别，都有哪些用途？</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E9%80%94%EF%BC%9F/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E9%80%94%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="一-301重定向的概念"><a href="#一-301重定向的概念" class="headerlink" title="一. 301重定向的概念"></a>一. 301重定向的概念</h2><p>301重定向（301 Move Permanently），指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息（header）中包含状态码 301 ，表示该资源已经永久改变了位置。</p><p>301重定向是一种非常重要的”自动转向“技术，网址重定向最为可行的一种方法。</p><h2 id="二-哪些情况需要做301重定向？"><a href="#二-哪些情况需要做301重定向？" class="headerlink" title="二. 哪些情况需要做301重定向？"></a>二. 哪些情况需要做301重定向？</h2><p>网页开发过程中，时常会遇到网站目录结构的调整，将页面转移到一个新地址；网页扩展名的改变，这些变化都会导致网页地址发生改变，此时用户收藏夹和搜索引擎数据库中的旧地址是一个错误的地址，访问之后会出现404页面，直接导致网站流量的损失。或者是我们需要多个域名跳转至同一个域名，例如本站主站点域名为 www.conimi.com ，而还有一个域名 www.nico.cc，由于对该域名设置了301重定向，当输入www.nico.cc 时，自动跳转至 www.conimi.com 。</p><h2 id="三-301重定向有什么优点？"><a href="#三-301重定向有什么优点？" class="headerlink" title="三. 301重定向有什么优点？"></a>三. 301重定向有什么优点？</h2><p>有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。例如 www.conimi.com和 conimi.com 是两个不同的域名，但是指向的内容完全相同，搜索引擎会对两个域名收录情况不同，这样导致网站权重和排名被分散；对conimi.com 做301重定向跳转至www.conimi.com 后，权重和排名集中到www.conimi.com，从而提升自然排名。</p><h2 id="四-302重定向又是什么鬼？"><a href="#四-302重定向又是什么鬼？" class="headerlink" title="四. 302重定向又是什么鬼？"></a>四. 302重定向又是什么鬼？</h2><p>302重定向（302 Move Temporarily），指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用。</p><h2 id="五-301与302的区别"><a href="#五-301与302的区别" class="headerlink" title="五. 301与302的区别"></a>五. 301与302的区别</h2><p>302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP常用状态码</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><p>1xx：表示目前是协议的中间状态，还需要后续请求</p><p>2xx：表示请求成功</p><p>3xx：表示重定向状态，需要重新请求</p><p>4xx：表示请求报文错误</p><p>5xx：服务器端错误</p><h2 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h2><p>101 切换请求协议，从 HTTP 切换到 WebSocket</p><p>200 请求成功，有响应体</p><p>301 永久重定向：会缓存</p><p>302 临时重定向：不会缓存</p><p>304 协商缓存命中</p><p>403 服务器禁止访问</p><p>404 资源未找到</p><p>400 请求错误</p><p>500 服务器端错误</p><p>503 服务器繁忙</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GET 和 POST的区别</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/POST%E4%B8%8EGET%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/POST%E4%B8%8EGET%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。  </p><h2 id="参数-GET-和-POST-的请求都能使用额外的参数，"><a href="#参数-GET-和-POST-的请求都能使用额外的参数，" class="headerlink" title="参数 GET 和 POST 的请求都能使用额外的参数，"></a>参数 GET 和 POST 的请求都能使用额外的参数，</h2><p>但是 GET 的参数是以查询字符串出现在 URL 中，</p><p>而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。  因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 1和1.1和2的区别</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1_1.1_2%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1_1.1_2%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP1"><a href="#HTTP1" class="headerlink" title="HTTP1"></a>HTTP1</h2><p>HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，</p><p>HTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p><p>我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0版本的性能比较差。</p><p>HTTP1.0 其实也可以强制开启长链接，例如接受Connection: keep-alive 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p><h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><p>为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。</p><p>由于之前打一次电话只能说一件事儿，效率很低。后来人们提出一种想法，就是电话打完之后，先不直接挂断，而是持续一小段时间，这一小段时间内，如果还有事情沟通可以再次进行沟通。</p><p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。</p><p>HTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。</p><p>也就是说，老板可以同时下达多个命令，员工也可以收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。A请求的两部分响应在组合到一起发给老板。</p><p>而这个负责拆分、组装请求和二进制帧的一层就叫做二进制分帧层。</p><p>除此之外，还有一些其他的优化，比如做Header压缩、服务端推送等。</p><p>Header压缩就是压缩老板和员工之间的对话。</p><p>服务端推送就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。</p><p>目前，主流的HTTP协议还是HTTP/1.1 和 HTTP/2。并且各大网站的HTTP/2的使用率也在逐年增加。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP协议的主要特点"><a href="#TCP协议的主要特点" class="headerlink" title="TCP协议的主要特点"></a>TCP协议的主要特点</h2><p>（1）TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。  </p><p>（2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；  </p><p>（3）TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；<br>（4）TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；<br>（5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。  </p><h2 id="TCP的可靠性原理-可靠传输有如下两个特点"><a href="#TCP的可靠性原理-可靠传输有如下两个特点" class="headerlink" title="TCP的可靠性原理 可靠传输有如下两个特点:"></a>TCP的可靠性原理 可靠传输有如下两个特点:</h2><p>a.传输信道无差错,保证传输数据正确;  </p><p>b.不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;  </p><p>（1）首先，采用三次握手来建立TCP连接，四次挥手来释放TCP连接，从而保证建立的传输信道是可靠的。  </p><p>（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。  </p><p>（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。  </p><h2 id="UDP协议特点"><a href="#UDP协议特点" class="headerlink" title="UDP协议特点"></a>UDP协议特点</h2><p>（１）UDP是无连接的传输层协议；  </p><p>（２）UDP使用尽最大努力交付，不保证可靠交付；  </p><p>（３）UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；  </p><p>（４）UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；  （５）UDP支持一对一　一对多　多对多的交互通信；  </p><p>（６）UDP的首部开销小，只有８字节．  </p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>(1)TCP是可靠传输,UDP是不可靠传输;  </p><p>(2)TCP面向连接,UDP无连接;  </p><p>(3)TCP传输数据有序,UDP不保证数据的有序性; </p><p>(4)TCP不保存数据边界,UDP保留数据边界; </p><p>(5)TCP传输速度相对UDP较慢;  </p><p>(6)TCP有流量控制和拥塞控制,UDP没有; </p><p> (７)TCP是重量级协议,UDP是轻量级协议;  </p><p>(８)TCP首部较长２０字节,UDP首部较短８字节; （如果有可选字段那么TCP最多60） 基于TCP和UDP的常用协议 HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议 </p><h2 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h2><p> TCP应用场景：  效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。  </p><p> UDP应用场景：  效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）</p><h2 id="udp如何实现可靠性传输？"><a href="#udp如何实现可靠性传输？" class="headerlink" title="udp如何实现可靠性传输？"></a>udp如何实现可靠性传输？</h2><p>UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。  </p><p>传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。  </p><p>最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。  </p><p>1、添加seq/ack机制，确保数据发送到对端 </p><p>2、添加发送和接收缓冲区，主要是用户超时重传。 </p><p>3、添加超时重传机制。 详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。  </p><p>目前有如下开源程序利用udp实现了可靠的数据传输。分别为<em>RUDP、RTP、UDT</em>。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP四次挥手</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="刚开始双方都处于-establised-状态，假如是客户端先发起关闭请求，则："><a href="#刚开始双方都处于-establised-状态，假如是客户端先发起关闭请求，则：" class="headerlink" title="刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则："></a>刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：</h2><p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。  </p><p>2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。  </p><p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。  </p><p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态  5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p>这里特别需要主要的就是TIME_WAIT这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 ACK 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。</p><p>至于 TIME_WAIT 持续的时间至少是一个报文的来回时间。一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p><p>这里我给出每个状态所包含的含义，有兴趣的可以看看。</p><p>LISTEN – 侦听来自远方TCP端口的连接请求；</p><p>SYN-SENT -在发送连接请求后等待匹配的连接请求；</p><p>SYN-RECEIVED – 在收到和发送一个连接请求后等待对连接请求的确认；</p><p>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户；</p><p>FIN-WAIT-1 – 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p><p>FIN-WAIT-2 – 从远程TCP等待连接中断请求；</p><p>CLOSE-WAIT – 等待从本地用户发来的连接中断请求；</p><p>CLOSING -等待远程TCP对连接中断的确认；</p><p>LAST-ACK – 等待原来发向远程TCP的连接中断请求的确认；</p><p>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p><p>CLOSED – 没有任何连接状态；</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP三次握手</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="三次握手-当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，"><a href="#三次握手-当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，" class="headerlink" title="三次握手 当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，"></a>三次握手 当面试官问你为什么需要有三次握手、三次握手的作用、讲讲三次三次握手的时候，</h2><p>我想很多人会这样回答： 首先很多人会先讲下握手的过程： </p><p>1、第一次握手：客户端给服务器发送一个 SYN 报文。</p><p>2、第二次握手：服务器收到 SYN 报文之后</p><p>3.第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。</p><p>4、服务器收到 ACK 报文之后，三次握手建立完成</p><p>作用是为了确认双方的接收与发送能力是否正常。</p><h2 id="这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以："><a href="#这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：" class="headerlink" title="这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以："></a>这里我顺便解释一下为啥只有三次握手才能确认双方的接受与发送能力是否正常，而两次却不可以：</h2><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p><h2 id="而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样："><a href="#而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：" class="headerlink" title="而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样："></a>而且描述的详细一点意味着可以扯久一点。加分的描述我觉得应该是这样：</h2><p>刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后</p><p>1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。</p><p>2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。</p><p>3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态。  </p><p>4、服务器收到 ACK 报文之后，也处于 established 状态，此时，双方以建立起了链接</p><h2 id="三次握手的作用也是有好多的，多记住几个，保证不亏。例如："><a href="#三次握手的作用也是有好多的，多记住几个，保证不亏。例如：" class="headerlink" title="三次握手的作用也是有好多的，多记住几个，保证不亏。例如："></a>三次握手的作用也是有好多的，多记住几个，保证不亏。例如：</h2><p>1、确认双方的接受能力、发送能力是否正常。</p><p>2、指定自己的初始化序列号，为后面的可靠传送做准备。</p><h2 id="1、（ISN）是固定的吗"><a href="#1、（ISN）是固定的吗" class="headerlink" title="1、（ISN）是固定的吗"></a>1、（ISN）是固定的吗</h2><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</p><p>如果ISN是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。</p><h2 id="2、什么是半连接队列"><a href="#2、什么是半连接队列" class="headerlink" title="2、什么是半连接队列"></a>2、什么是半连接队列</h2><p>服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p><p>这里在补充一点关于SYN-ACK 重传次数的问题：　服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超 过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s, 2s, 4s, 8s,</p><h2 id="3、三次握手过程中可以携带数据吗"><a href="#3、三次握手过程中可以携带数据吗" class="headerlink" title="3、三次握手过程中可以携带数据吗"></a>3、三次握手过程中可以携带数据吗</h2><p>很多人可能会认为三次握手都不能携带数据，其实第三次握手的时候，是可以携带数据的。也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p><p>为什么这样呢？大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p><p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据页没啥毛病。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络七层协议以及相关的功能是什么</title>
    <link href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p>可以参考 <a href="https://www.cnblogs.com/schips/p/osi_framework_and_tcp-ip.html">https://www.cnblogs.com/schips/p/osi_framework_and_tcp-ip.html</a></p><p>应用层：负责给应⽤程序提供统⼀的接⼝；</p><p>表示层：数据格式的转换，以及一些压缩解压的功能，比如下层给过来的数据是二进制的，转换其为图片让人可以看到图片这就是数据转换。<br>即对数据格式进行转换，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</p><p>会话层：为网络设备提供会话的功能，过程中可能会有身份验证等功能，然后当进程终止时会话不一定是终止的，如果没超时，下次继续连接这个会话还存在，那么就不需要身份验证等事情了。</p><p>传输层：向上提供可靠的透明数据传输功能，是用于网络中两个进程之间的，处理数据包的错误等传输问题。</p><p>网络层：负责数据的路由、转发、分⽚；</p><p>链路层：负责数据的封帧和差错检测，以及 MAC 寻址；</p><p>物理层：负责在物理⽹络中传输数据帧；</p><p>在四层，既传输层数据被称作段（Segments）；</p><p>三层网络层数据被称做包（Packages）；</p><p>二层数据链路层时数据被称为帧（Frames）；</p><p>一层物理层时数据被称为比特流（Bits）。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>push_back and emplace difference</title>
    <link href="/2022/02/20/C++/C++_push_back%E7%9B%B8%E6%AF%94emplace_back/"/>
    <url>/2022/02/20/C++/C++_push_back%E7%9B%B8%E6%AF%94emplace_back/</url>
    
    <content type="html"><![CDATA[<p>push_back 和 emplace_back 的区别在哪里？</p><h2 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h2><p>emplace_back 能就地通过参数构造对象，不需要拷贝或者移动内存，相比 push_back 能更好地避免内存的拷贝与移动，使容器插入元素的性能得到进一步提升。在大多数情况下应该优先使用 emplace_back 来代替 push_back。</p><p>下面的代码节选自 <a href="https://en.cppreference.com/w/cpp/container/vector/emplace_back，可以很好的解释它们的区别，">https://en.cppreference.com/w/cpp/container/vector/emplace_back，可以很好的解释它们的区别，</a></p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">President</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> name;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> country;    <span class="hljs-keyword">int</span> year;    President(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> p_name, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> p_country, <span class="hljs-keyword">int</span> p_year)        : name(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p_name)), country(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(p_country)), year(p_year)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I am being constructed.\n&quot;</span>;    &#125;    President(President&amp;&amp; other)        : name(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.name)), country(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">move</span>(other.country)), year(other.year)    &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;I am being moved.\n&quot;</span>;    &#125;    President&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> President&amp; other) = <span class="hljs-keyword">default</span>;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;President&gt; elections;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;emplace_back:\n&quot;</span>;    elections.emplace_back(<span class="hljs-string">&quot;Nelson Mandela&quot;</span>, <span class="hljs-string">&quot;South Africa&quot;</span>, <span class="hljs-number">1994</span>);    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;President&gt; reElections;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\npush_back:\n&quot;</span>;    reElections.push_back(President(<span class="hljs-string">&quot;Franklin Delano Roosevelt&quot;</span>, <span class="hljs-string">&quot;the USA&quot;</span>, <span class="hljs-number">1936</span>));    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\nContents:\n&quot;</span>;    <span class="hljs-keyword">for</span> (President <span class="hljs-keyword">const</span>&amp; president: elections) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was elected president of &quot;</span>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    &#125;    <span class="hljs-keyword">for</span> (President <span class="hljs-keyword">const</span>&amp; president: reElections) &#123;        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; president.name &lt;&lt; <span class="hljs-string">&quot; was re-elected president of &quot;</span>                  &lt;&lt; president.country &lt;&lt; <span class="hljs-string">&quot; in &quot;</span> &lt;&lt; president.year &lt;&lt; <span class="hljs-string">&quot;.\n&quot;</span>;    &#125;&#125;输出：emplace_back:I am being constructed.push_back:I am being constructed.I am being moved.Contents:Nelson Mandela was elected president of South Africa in <span class="hljs-number">1994.</span>Franklin Delano Roosevelt was re-elected president of the USA in <span class="hljs-number">1936.</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>placement new and delete 用法</title>
    <link href="/2022/02/14/C++/C++_placement_new/"/>
    <url>/2022/02/14/C++/C++_placement_new/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs arduino">运算符重载可以重载<span class="hljs-keyword">new</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">delete</span>。但是第一个参数必须为<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>必须返回值为<span class="hljs-keyword">void</span>*，一般如果重载了<span class="hljs-keyword">new</span>，也要 用相同参数重载<span class="hljs-keyword">delete</span>，因为当使用了某种<span class="hljs-keyword">new</span>，就会使用对应参数的<span class="hljs-keyword">delete</span>来删除，如果没有定义，就不会调用，会发生内存泄漏<span class="hljs-keyword">void</span> * <span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>  <span class="hljs-built_in">size</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>:: <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">size</span>);&#125;Foo* m = <span class="hljs-keyword">new</span> Foo; <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">void</span>* ptr)</span></span><span class="hljs-function"> </span>&#123;     <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;placement new&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">return</span> ptr; &#125; 如果加入其他形参，比如指针，就是placement <span class="hljs-keyword">new</span>。就是实际上没有分配内存，返回了之前给的指针，实际上是用的之前的内存。调用就像下面这样  Foo* m2 = <span class="hljs-keyword">new</span>(m) Foo;  如果定义了placement <span class="hljs-keyword">new</span>，就要使用placement <span class="hljs-keyword">delete</span>，不然会发生内存泄漏。  </code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL:priority_queue 用法</title>
    <link href="/2022/02/14/C++/STL_priority_queue%E7%94%A8%E6%B3%95/"/>
    <url>/2022/02/14/C++/STL_priority_queue%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-comment">// 默认优先从小到大输出</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">priority_queue</span>&lt;Type,Container,Functional&gt;<span class="hljs-comment">//期中type是数据类型，第二个是保存数据的容器，第三个是元素比较函数，默认从大到小operator&lt;</span><span class="hljs-comment">//容器默认为vectord</span><span class="hljs-comment">//如果优先输出小数据则使用，</span><span class="hljs-built_in">priority_queue</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; p;<span class="hljs-comment">// less则是大顶堆，降序</span><span class="hljs-comment">//如果使用自定义的节点</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> x;    <span class="hljs-keyword">int</span> y;    node(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b):x(a),y(b)&#123;&#125;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a,node b)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(a.x==b.x) <span class="hljs-keyword">return</span> a.y&gt;b.y;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> a.x&gt;b.x;<span class="hljs-comment">//从小到大</span>    &#125;&#125;;<span class="hljs-built_in">priority_queue</span>&lt;node,<span class="hljs-built_in">vector</span>&lt;node&gt;,cmp&gt; p;这里很容易混淆的一点是<span class="hljs-built_in">priority_queue</span>是默认大顶堆的，所以a.x&lt;b.x是降序，a.x&gt;b.x是升序。但是sort是默认升序的，所以a.x&lt;b.x是升序，a.x&gt;b.x是降序。优先队列自定义排序方式重载operater&lt;或<span class="hljs-keyword">operator</span>&gt;创建大顶堆时重载<span class="hljs-keyword">operator</span>&lt;，对应less方法，元素降序<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(node a,node b)&#123;    <span class="hljs-keyword">if</span>(a.x==b.x) <span class="hljs-keyword">return</span> a.y&gt;b.y;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> a.x&lt;b.x;<span class="hljs-comment">//从小到大</span>&#125;创建小顶堆时重载<span class="hljs-keyword">operator</span>&gt;，对应greater方法，元素升序声明比较类cmp<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmp</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a,node b)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(a.x==b.x) <span class="hljs-keyword">return</span> a.y&gt;b.y;        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> a.x&gt;b.x;<span class="hljs-comment">//从小到大</span>    &#125;&#125;;但是sort还多一个自定义比较函数cmp<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.x&lt;b.x;&#125;sort(vec.<span class="hljs-built_in">begin</span>(),vec.<span class="hljs-built_in">end</span>(),cmp())两个自定义函数对比<span class="hljs-built_in">priority_queue</span>有两种自定义方式：重载操作符和声明比较类；sort相比于前者增加一个定义比较函数；默认排序方式不同：<span class="hljs-built_in">priority_queue</span>默认为大顶堆，降序；sort默认升序自定义运算方式不同：比如<span class="hljs-string">&quot;a &lt; b&quot;</span>在<span class="hljs-built_in">priority_queue</span>中代表降序，而在sort中代表升序调用方式不同：定义比较类时，<span class="hljs-built_in">priority_queue</span>调用过程中不需要<span class="hljs-string">&quot;()&quot;</span>–&gt;cmp，而sort无论调用自定义比较函数还是比较类都需要加上<span class="hljs-string">&quot;()&quot;</span>–&gt;cmp()</code></pre><p>可以参考这篇文章 </p><p><a href="https://blog.csdn.net/wwrzzu/article/details/106177818">https://blog.csdn.net/wwrzzu/article/details/106177818</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>priority_queue</tag>
      
      <tag>STL，c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>signal和sigaction的用法</title>
    <link href="/2021/12/26/C++/signal%E5%92%8Csigaction/"/>
    <url>/2021/12/26/C++/signal%E5%92%8Csigaction/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/52php/p/5813867.html">参考博客</a></p><h1 id="Linux进程间通信（一）：-信号-signal-、sigaction"><a href="#Linux进程间通信（一）：-信号-signal-、sigaction" class="headerlink" title="Linux进程间通信（一）： 信号 signal()、sigaction()"></a>Linux进程间通信（一）： 信号 signal()、sigaction()</h1><h2 id="一、什么是信号"><a href="#一、什么是信号" class="headerlink" title="一、什么是信号"></a>一、什么是信号</h2><p>用过Windows的我们都知道，当我们无法正常结束一个程序时，可以用任务管理器强制结束这个进程，但这其实是怎么实现的呢？同样的功能在Linux上是通过生成信号和捕获信号来实现的，运行中的进程捕获到这个信号然后作出一定的操作并最终被终止。</p><p>信号是UNIX和Linux系统响应某些条件而产生的一个事件，<br>接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生的。但它们还可以作为进程间通信或修改行为的一种方式，<br>明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。</p><h2 id="二、信号的种类"><a href="#二、信号的种类" class="headerlink" title="二、信号的种类"></a>二、信号的种类</h2><p>信号的名称是在头文件signal.h中定义的，信号都以SIG开头，常用的信号并不多，<br>常用的信号如下：<br>SIGINT一般是由终端敲击的ctrl+C组合键以及预先设置的中断字符</p><p>SIGUSR1,SIGUSR2,进程间使用这个信号通信，如报告状态信息</p><p>SIGPIPE，如果向管道写数据但是没有读进程就会产生这个信号。</p><h2 id="三、信号的处理-——-signal-函数"><a href="#三、信号的处理-——-signal-函数" class="headerlink" title="三、信号的处理 —— signal()函数"></a>三、信号的处理 —— signal()函数</h2><p>程序可用使用signal()函数来处理指定的信号，主要通过忽略和恢复其默认行为来工作。</p><p>void (<em>signal(int sig, void (</em>func)(int)))(int);<br>这是一个相当复杂的声明，耐心点看可以知道signal是一个带有sig和func两个参数的函数，func是一个类型为void (*)(int)的函数指针。该函数返回一个与func相同类型的指针，指向先前指定信号处理函数的函数指针。准备捕获的信号的参数由sig给出，接收到的指定信号后要调用的函数由参数func给出。<br>其实这个函数的使用是相当简单的，通过下面的例子就可以知道。注意信号处理函数的原型必须<br>为void func（int），或者是下面的特殊值：</p><p>SIG_IGN : 忽略信号</p><p>SIG_DFL : 恢复信号的默认行为</p><h2 id="四、信号处理-——-sigaction-函数"><a href="#四、信号处理-——-sigaction-函数" class="headerlink" title="四、信号处理 —— sigaction()函数"></a>四、信号处理 —— sigaction()函数</h2><p>前面我们看到了signal()函数对信号的处理，但是一般情况下我们可以使用一个更加健壮的信号接口 —— sigaction()函数。它的原型为：</p><p>int sigaction(int sig, const struct sigaction <em>act, struct sigaction </em>oact);</p><p>该函数与signal()函数一样，用于设置与信号sig关联的动作，而oact如果不是空指针的话，就用它来保存原先对该信号的动作的位置，<br>act则用于设置指定信号的动作。</p><p>sigaction结构体定义在signal.h中，但是它至少包括以下成员：</p><p>void (*) (int) sa_handler：处理函数指针，相当于signal函数的func参数。</p><p>sigset_t sa_mask： 指定一个。信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被加入到进程的信号屏蔽字中。信号屏蔽字是指当前被阻塞的一组信号，它们不能被当前进程接收到</p><p>int sa_flags：信号处理修改器;</p><p>sa_mask 的值通常是通过使用信号集函数来设置的，关于信号集函数，我将会在我的下一篇文章 —— Linux进程间通信——信号集函数，详细讲述。</p><p>sa_flags，通常可以取以下的值：例如SA_NODEFER,捕捉到信号时不添加到信号屏蔽字中。</p><p>此外，现在有一个这样的问题，我们使用signal()或sigaction()函数来指定处理信号的函数，但是如果这个信号处理函数建立之前就接收到要处理的信号的话，进程会有怎样的反应呢？它就不会像我们想像的那样用我们设定的处理函数来处理了。sa_mask就可以解决这样的问题，sa_mask指定了一个信号集，在调用sa_handler所指向的信号处理函数之前，该信号集将被<br>加入到进程的信号屏蔽字中，设置信号屏蔽字可以防止信号在它的处理函数还未运行结束时就被接收到的情况，即使用sa_mask字段可以消除这一竞态条件。</p><h2 id="五、发送信号"><a href="#五、发送信号" class="headerlink" title="五、发送信号"></a>五、发送信号</h2><p>上面说到的函数都是一些进程接收到一个信号之后怎么对这个信号作出反应，即信号的处理的问题，有没有什么函数可以向一个进程主动地发出一个信号呢？我们可以通过两个函数kill()和alarm()来发送一个信号。</p><p>1、kill()函数</p><p>先来看看kill()函数，进程可以通过kill()函数向包括它本身在内的其他进程发送一个信号，如果程序没有发送这个信号的权限，对kill()函数的调用就将失败，而失败的常见原因是目标进程由另一个用户所拥有。想一想也是容易明白的，你总不能控制别人的程序吧，当然超级用户root，这种上帝般的存在就除外了。</p><p>kill()函数的原型为：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <sys types.h></sys></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <signal.h></signal.h></h1><p>int kill(pid_t pid, int sig);</p><p>它的作用把信号sig发送给进程号为pid的进程，成功时返回0。</p><p>kill()调用失败返回-1，调用失败通常有三大原因：</p><p>1、给定的信号无效（errno = EINVAL)<br>2、发送权限不够( errno = EPERM ）<br>3、目标进程不存在( errno = ESRCH )</p><p>2、alarm()函数</p><p>这个函数跟它的名字一样，给我们提供了一个闹钟的功能，进程可以调用alarm()函数在经过预定时间后向发送一个SIGALRM信号。</p><p>alarm()函数的型如下：</p><p>alarm()函数用来在seconds秒之后安排发送一个SIGALRM信号，如果seconds为0，将取消所有已设置的闹钟请求。alarm()函数的返回值是以前设置的闹钟时间的余留秒数，如果返回失败返回-1。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>signal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>select和poll和epoll的区别</title>
    <link href="/2021/12/26/C++/select%E5%92%8Cepoll%E5%92%8Cpoll%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/12/26/C++/select%E5%92%8Cepoll%E5%92%8Cpoll%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>参考博客<a href="https://zhuanlan.zhihu.com/p/272891398">参考博客</a></p><p>参考博客<a href="https://www.cnblogs.com/anker/p/3265058.html">参考博客</a></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>select本质上是通过设置或检查存放fd标志位的数据结构进行下一步处理。 这带来缺点：</p><p>FD_SETSIZE宏定义，其大小是32个整数的大小<br>当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，<br>这需要进一步的测试 一般该数和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认1024个，64位默认2048</p><p>对socket是线性扫描，即轮询，效率较低： 仅知道有I/O事件发生，却不知是哪几个流，<br>只会无差异轮询所有流，找出能读数据或写数据的流进行操作。同时处理的流越多，无差别轮询时间越长 - O(n)。</p><p>（1）使用copy_from_user从用户空间拷贝fd_set到内核空间</p><p>（2）注册回调函数__pollwait</p><p>（3）遍历所有fd，调用其对应的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll）</p><p>（4）以tcp_poll为例，其核心实现就是__pollwait，也就是上面注册的回调函数。</p><p>（5）__pollwait的主要工作就是把current（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。在设备收到一条消息（网络设备）或填写完文件数据（磁盘设备）后，会唤醒设备等待队列上睡眠的进程，这时current便被唤醒了。</p><p>（6）poll方法返回时会返回一个描述读写操作是否就绪的mask掩码，根据这个mask掩码给fd_set赋值。</p><p>（7）如果遍历完所有的fd，还没有返回一个可读写的mask掩码，则会调用schedule_timeout是调用select的进程（也就是current）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</p><p>（8）把fd_set从内核空间拷贝到用户空间。</p><p>缺点：</p><p>内核需要将消息传递到用户空间，都需要内核拷贝动作。需要维护一个用来存放大量fd的数据结构，使得用户空间和内核空间在传递该结构时复制开销大。</p><p>每次调用select，都需把fd集合从用户态拷贝到内核态，fd很多时开销就很大</p><p>同时每次调用select都需在内核遍历传递进来的所有fd，fd很多时开销就很大</p><p>select支持的文件描述符数量太小了，默认最大支持1024个</p><p>主动轮询效率很低</p><p>poll</p><p>和select类似，只是描述fd集合的方式不同，poll使用pollfd结构而非select的fd_set结构。 管理多个描述符也是进行轮询，根据描述符的状态进行处理，但poll没有最大文件描述符数量的限制。<br>因为pollfd使用的是链表</p><p>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</p><p>它将用户传入的数组拷贝到内核空间</p><p>然后查询每个fd对应的设备状态：</p><p>如果设备就绪 在设备等待队列中加入一项继续遍历</p><p>若遍历完所有fd后，都没发现就绪的设备 挂起当前进程，直到设备就绪或主动超时，被唤醒后它又再次遍历fd。这个过程经历多次无意义的遍历。</p><p>没有最大连接数限制，因其基于链表存储，其缺点：</p><p>大量fd数组被整体复制于用户态和内核地址空间间，而不管是否有意义</p><p>如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd</p><p>epoll</p><p>epoll模型修改主动轮询为被动通知，当有事件发生时，被动接收通知。所以epoll模型注册套接字后，主程序可做其他事情，当事件发生时，接收到通知后再去处理。</p><p>可理解为event poll，epoll会把哪个流发生哪种I/O事件通知我们。所以epoll是事件驱动（每个事件关联fd），此时我们对这些流的操作都是有意义的。复杂度也降到O(1)。</p><p>epoll的触发模式，两种水平触发和边缘触发，EPOLLLT和EPOLLET两种：</p><h3 id="LT"><a href="#LT" class="headerlink" title="LT"></a>LT</h3><p><a href="https://github.com/yedf2/handy/blob/master/raw-examples/epoll.cc">LT的一个例子</a></p><p>默认的模式（水平触发） 只要该fd还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作，</p><h3 id="ET"><a href="#ET" class="headerlink" title="ET"></a>ET</h3><p><a href="https://github.com/yedf/handy/blob/master/raw-examples/epoll-et.cc">ET的一个例子</a></p><p>是“高速”模式（边缘触发），只会提示一次，直到下次再有数据流入之前都不会再提示，无论fd中是否还有数据可读。<br>所以在ET模式下，read一个fd的时候一定要把它的buffer读完，即读到read返回值小于请求值或遇到EAGAIN错误</p><p>epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似回调机制激活该fd，epoll_wait便可收到通知。</p><p>若用EPOLLLT，系统中一旦有大量无需读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这大大降低处理程序检索自己关心的<br>就绪文件描述符的效率。 而采用EPOLLET，当被监控的文件描述符上有可读写事件发生时，epoll_wait会通知处理程序去读写。如果<br>这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait时，它不会通知你，<br>即只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p><h3 id="epoll优点"><a href="#epoll优点" class="headerlink" title="epoll优点"></a>epoll优点</h3><p>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</p><p>效率提升，不是轮询，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数 即Epoll最大的优点就在<br>于它只关心“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</p><p>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><p>epoll通过内核和用户空间共享一块内存来实现的</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，<br>而select则应该是POSIX所规定，一般操作系统均有实现。</p><p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时<br>（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了<br>每个fd在整个过程中只会拷贝一次。</p><p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，<br>而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，<br>唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。<br>epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，O(1)复杂度<br>和select实现中的第7步是类似的）。</p><p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器<br>上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
      <tag>epoll</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红黑树知识点</title>
    <link href="/2021/12/24/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2021/12/24/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>一般来说红黑树有以下的知识点</p><ol><li><p>根是黑色</p></li><li><p>叶节点是黑色的（即为空的黑色的哨兵节点）</p></li><li><p>从跟到叶子经过相同数目的黑色节点</p></li><li><p>红色节点的子节点一定是两个黑色的</p></li><li><p>节点为红色或者黑色</p></li></ol><p>可以参考这个链接来使用<a href="https://www.jianshu.com/p/e136ec79235c">30张图带你彻底理解红黑树</a></p><p>红黑树主要是通过左旋右旋和节点变色来实现的。这个左旋右旋和b树b+树的都是一样的。</p><h2 id="红黑树查找"><a href="#红黑树查找" class="headerlink" title="红黑树查找"></a>红黑树查找</h2><p>与二叉搜索树差不多的，但是由于红黑树总是黑色平衡的，<br>所以最坏是O(2lgN)，也即整颗树刚好红黑相隔的时候。能有这么好的查找效率得益于红黑树自平衡的特性</p><h2 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h2><p>首先必须先找到插入位置，把插入结点放到正确的位置就可以啦，但插入结点是应该是什么颜色呢？答案是红色。理由很简单，红色在父结点（如果存在）为黑色结点时，<br>红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所<br>在的子树黑色结点总是多1，必须做自平衡。</p><p>一般来说加入红节点会破坏1或者4。</p><h3 id="1-如果此时树为空树，那么必须把插入的节点改成黑色。"><a href="#1-如果此时树为空树，那么必须把插入的节点改成黑色。" class="headerlink" title="1. 如果此时树为空树，那么必须把插入的节点改成黑色。"></a>1. 如果此时树为空树，那么必须把插入的节点改成黑色。</h3><h3 id="2-如果插入的节点父节点为黑节点，那么可以直接插入。"><a href="#2-如果插入的节点父节点为黑节点，那么可以直接插入。" class="headerlink" title="2. 如果插入的节点父节点为黑节点，那么可以直接插入。"></a>2. 如果插入的节点父节点为黑节点，那么可以直接插入。</h3><h3 id="3-如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论"><a href="#3-如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论" class="headerlink" title="3. 如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论"></a>3. 如果插入的节点的父节点为红色节点，破坏了4，同时此时的爷爷节点一定为黑色，需要分三种情况讨论</h3><h4 id="3-1-叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。"><a href="#3-1-叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。" class="headerlink" title="3.1 叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。"></a>3.1 叔叔节点为红色，直接爷爷父亲叔叔变为红黑黑，如果爷爷层级颜色被破坏就还需要继续修改，没有就ok了。</h4><h4 id="3-2-叔叔节点为黑色或者不存在，且父亲是爷爷的左节点"><a href="#3-2-叔叔节点为黑色或者不存在，且父亲是爷爷的左节点" class="headerlink" title="3.2 叔叔节点为黑色或者不存在，且父亲是爷爷的左节点"></a>3.2 叔叔节点为黑色或者不存在，且父亲是爷爷的左节点</h4><h5 id="3-2-1-自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。"><a href="#3-2-1-自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。" class="headerlink" title="3.2.1 自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。"></a>3.2.1 自己插入的是父亲节点的左节点，将父亲改为黑色，爷爷改为红色，右旋。</h5><h5 id="3-2-2-自己插入的是父亲节点的右节点，对父亲节点左旋变成3-2-1"><a href="#3-2-2-自己插入的是父亲节点的右节点，对父亲节点左旋变成3-2-1" class="headerlink" title="3.2.2 自己插入的是父亲节点的右节点，对父亲节点左旋变成3.2.1"></a>3.2.2 自己插入的是父亲节点的右节点，对父亲节点左旋变成3.2.1</h5><h4 id="3-3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在"><a href="#3-3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在" class="headerlink" title="3.3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在"></a>3.3叔叔节点为黑色或者不存在（此时应该是不存在的，因为插入的地方是叶子节点的地方，如果叔叔节点存在</h4><p>且为黑色，那么自己的路径和叔叔路径的黑色数目就不一样了），且父亲是爷爷的右节点（是3.2的另外一个方向的版本）</p><h5 id="3-3-1-自己插入的是父亲节点的左节点，右旋，变成3-3-2。"><a href="#3-3-1-自己插入的是父亲节点的左节点，右旋，变成3-3-2。" class="headerlink" title="3.3.1 自己插入的是父亲节点的左节点，右旋，变成3.3.2。"></a>3.3.1 自己插入的是父亲节点的左节点，右旋，变成3.3.2。</h5><h5 id="3-3-2-自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。"><a href="#3-3-2-自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。" class="headerlink" title="3.3.2 自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。"></a>3.3.2 自己插入的是父亲节点的右节点，对父亲节点左旋，然后将父亲改为黑色，爷爷改为红色。</h5><h3 id="插入节点的key已经存在，那么此时更新节点的value。"><a href="#插入节点的key已经存在，那么此时更新节点的value。" class="headerlink" title="插入节点的key已经存在，那么此时更新节点的value。"></a>插入节点的key已经存在，那么此时更新节点的value。</h3><h2 id="红黑树删除"><a href="#红黑树删除" class="headerlink" title="红黑树删除"></a>红黑树删除</h2><p>删除的情况主要有几个点</p><p>1.删除的节点没有子节点，直接删除。</p><ol><li><p>删除的节点有一个子节点，用子节点代替删除的节点（可以认为是删除了子节点）</p></li><li><p>删除的节点有两个子节点，用后继节点代替删除的节点。（也可以用前驱节点代替，这里以后继节点为例）。<br>把二叉树所有结点投射在X轴上，所有结点都是从左到右排好序的，所有目标结点的前后结点就是对应前继和后继结点。（即中序遍历的后面一个节点）<br>这里可以认为是删除了后继节点，转成情况2或者通过情况2（不存在左节点）转情况1</p></li></ol><p>我们目的都是可以把情况2，3认为是情况1</p><p>综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。</p><ol><li>替换节点是红色节点</li></ol><p>我们把替换结点换到了删除结点的位置时，<br>由于替换结点时红色，删除也了不会影响红黑树的平衡，只要把替换结点的颜色设为删除的结点的颜色即可重新平衡。</p><p>2.替换节点是黑色节点</p><p>2.1.1 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点，兄弟节点的父节点和子节点都是黑色。</p><p>此时把替换节点，父节点，兄弟节点变成黑红黑，然后左旋。</p><p>2.1.2 替换结点是其父结点的左子结点，替换结点的兄弟结点是红结点，</p><p>2.1.2.1替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色</p><p>此时由于会删除黑色节点导致不平衡，所以兄弟节点改成父节点的颜色，将父节点改为黑色，<br>兄弟节点的右节点改为黑色。然后左旋。</p><p>2.1.2.2 替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点</p><p>删除黑色的替换节点会不平衡，所以将S设置为红色，对兄弟节点右旋，然后得到2.1.2.1的情况。</p><p>2.1.2.3 替换结点的兄弟结点的右子结点为黑结点，左子结点为黑结点</p><p>将兄弟节点设置为红色。将父节点作为新的替换节点。然后重新进行删除节点处理。</p><p>2.2：替换结点是其父结点的左子结点</p><p>这个情况和2.1相同，只是方向相反。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1705. 吃苹果的最大数目（可以用红黑树即map或者优先队列priority_queue实现）</title>
    <link href="/2021/12/24/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/12/24/%E7%AE%97%E6%B3%95/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>一般可以用优先队列的也可以用红黑树实现，可以比较一下。</p><p>优先队列实现<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eatenApples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; apples, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; days)&lt;/span&gt; &lt;/span&gt;&#123;</span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-built_in&quot;&gt;priority_queue&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;, greater&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; pq;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, n = apples.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(); i &amp;lt; n || !pq.empty(); ++i) &amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; n  &amp;amp;&amp;amp; apples[i] != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123;        pq.emplace(i + days[i], apples[i]);    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!pq.empty() &amp;amp;&amp;amp; pq.top().first &amp;lt;= i) &amp;#123;        pq.pop();    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!pq.empty()) &amp;#123;        res++;        &lt;span class=&quot;hljs-built_in&quot;&gt;pair&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&amp;gt; mypair = pq.top();        mypair.second--;        pq.pop();        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (mypair.second&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) &amp;#123;            pq.emplace(mypair);        &amp;#125;    &amp;#125;&amp;#125;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;</code></pre><p>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;<br>红黑树实现<br><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eatenApples</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; apples, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; days)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n=apples.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; m;        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n||!m.empty();i++)        &#123;            m.erase(i);            <span class="hljs-keyword">if</span>(i&lt;n&amp;&amp;apples[i]!=<span class="hljs-number">0</span>)                m[i+days[i]]=apples[i];            <span class="hljs-keyword">if</span>(!m.empty())            &#123;                <span class="hljs-keyword">auto</span> tmp=m.<span class="hljs-built_in">begin</span>();                tmp-&gt;second--;                <span class="hljs-keyword">if</span>(tmp-&gt;second==<span class="hljs-number">0</span>)                    m.erase(tmp);                res++;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
      <tag>红黑树</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++虚函数虚表内容</title>
    <link href="/2021/12/21/C++/c++%E8%99%9A%E5%87%BD%E6%95%B0_%E8%99%9A%E8%A1%A8%E5%86%85%E5%AE%B9/"/>
    <url>/2021/12/21/C++/c++%E8%99%9A%E5%87%BD%E6%95%B0_%E8%99%9A%E8%A1%A8%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="知乎这个答案讲的很详细可以看下"><a href="#知乎这个答案讲的很详细可以看下" class="headerlink" title="知乎这个答案讲的很详细可以看下"></a><a href="https://zhuanlan.zhihu.com/p/41309205">知乎这个答案讲的很详细可以看下</a></h2><p>总结以下就是，指针在64位系统中占8字节，在32位系统占4字节</p><h2 id="单继承包含虚函数"><a href="#单继承包含虚函数" class="headerlink" title="单继承包含虚函数"></a>单继承包含虚函数</h2><pre><code class="hljs routeros">    假设B继承A，那么B虚表的构建规则:将A虚表中内容拷贝一份保存到B的虚表中如果B重写了A的虚函数，那么将B的虚表对应的函数指针替换为对应的函数地址如果类型B中出现了基类型A中没有的虚函数，新的虚函数将会被附加在虚函数表的最后对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time<span class="hljs-built_in"> Type </span>Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前</code></pre><h2 id="多继承内存模型"><a href="#多继承内存模型" class="headerlink" title="多继承内存模型"></a>多继承内存模型</h2><p><a href="http://www.008ct.top/blog/2020/01/03/%E5%8D%95%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/">参考的文章</a><br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript">假设类型C同时继承了两个独立的基类A和B,假设A有<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>虚函数，B有<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>虚函数，C有<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>虚函数</code></pre></p><p>首先在每个虚函数表的类型信息RTTI之前还有一个偏移量offset_to_top假设是<span class="hljs-number">-8</span>，表示当前这个虚函数表地址距离对象顶部地址的偏移量</p><p>首先A和B的虚函数指针都会被继承，然后会选一个虚函数表作为主虚函数表，假设选A，那么C的有P_A,P_B,此时P_A会包含<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>的函数指针，即包括A中的都会在，以及C重写的，C加的同时基类都没有的，P_B包含的是<span class="hljs-number">3</span> <span class="hljs-number">4</span>，即C类有的，但是没有被重写的，被重写的会被替换为thunk，这个会加上offset_to_top偏移到C的主的虚表中，然后找到对应的虚函数<br>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><h2 id="菱形继承（使用-虚继承）"><a href="#菱形继承（使用-虚继承）" class="headerlink" title="菱形继承（使用 虚继承）"></a>菱形继承（使用 虚继承）</h2><p><a href="https://blog.csdn.net/zhying719/article/details/107526987">可以参考的文章</a><br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs less">假设<span class="hljs-selector-tag">B</span>，<span class="hljs-selector-tag">C</span>都继承<span class="hljs-selector-tag">A</span>，<span class="hljs-selector-tag">D</span>继承<span class="hljs-selector-tag">B</span>，<span class="hljs-selector-tag">C</span>，使用虚继承</code></pre></p><p><span class="hljs-selector-tag">B</span>，<span class="hljs-selector-tag">C</span>会有两个虚表指针，包括<span class="hljs-selector-tag">A</span>和自己的（因为使用了虚继承），这个和单继承的情况有所区别，假设看<span class="hljs-selector-tag">B</span>，<span class="hljs-selector-tag">B</span>的虚表指针在前，然后<span class="hljs-selector-tag">A</span>的虚表指针在后，在<span class="hljs-selector-tag">offset_to_top</span>的前面还会出现一个<span class="hljs-selector-tag">vbase_offset</span>，代表距离基类虚函数表的指针地址的偏移量</p><p>同时还会出现<span class="hljs-selector-tag">vcall_offset</span>(X)：当<span class="hljs-selector-tag">Base</span>的引用或指针<span class="hljs-selector-tag">base</span>实际接受的是<span class="hljs-selector-tag">Derive</span>类型的对象，执行<span class="hljs-selector-tag">base-</span>&gt;<span class="hljs-selector-tag">FuncC</span>()时候，由于<span class="hljs-selector-tag">FuncC</span>()没有被重写，所以不需要对<span class="hljs-selector-tag">this</span>指针进行调整，就是<span class="hljs-selector-tag">vcall_offset</span>(<span class="hljs-number">0</span>)，之后调用<span class="hljs-selector-tag">FuncC</span>(),如果重写了就会偏移<span class="hljs-selector-tag">X</span>，然后调用。只要需要偏移函数对应的虚表才会出现<span class="hljs-selector-tag">vcall_offset</span>(X).</p><p>当出现虚继承的时候，<span class="hljs-selector-tag">D</span>只会有<span class="hljs-selector-tag">3</span>份虚表指针，<span class="hljs-selector-tag">B</span>,<span class="hljs-selector-tag">C</span>的主的虚表指针，<span class="hljs-selector-tag">A</span>只会保留一份,然后也会像多继承一样选择一个主的虚表，然后有的对应的函数在<span class="hljs-selector-tag">B</span>，或者<span class="hljs-selector-tag">A</span>的虚表中，有些在主的虚表中，当虚基类<span class="hljs-selector-tag">Base</span>的引用或指针<span class="hljs-selector-tag">base</span>实际接受的是<span class="hljs-selector-tag">Derive</span>类型的对象，执行<span class="hljs-selector-tag">base-</span>&gt;<span class="hljs-selector-tag">FuncB</span>()时候，由于<span class="hljs-selector-tag">FuncB</span>()已经被重写，而此时的<span class="hljs-selector-tag">this</span>指针指向的是<span class="hljs-selector-tag">Base</span>类型的对象，需要对<span class="hljs-selector-tag">this</span>指针进行调整，就是<span class="hljs-selector-tag">vcall_offset</span>(-<span class="hljs-number">32</span>)，所以<span class="hljs-selector-tag">this</span>指针向上调整了<span class="hljs-selector-tag">32</span>字节，之后调用<span class="hljs-selector-tag">FuncB</span>()，就调用到了被重写后的<span class="hljs-selector-tag">FuncB</span>()函数。</p><p>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><h2 id="为什么需要虚继承"><a href="#为什么需要虚继承" class="headerlink" title="为什么需要虚继承"></a>为什么需要虚继承</h2><pre><code class="hljs dns">为了防止二义性，非虚继承时，显然D会继承两次<span class="hljs-keyword">A</span>，内部就会存储两份<span class="hljs-keyword">A</span>的数据浪费空间，而且还有二义性，D调用<span class="hljs-keyword">A</span>的方法时，由于有两个<span class="hljs-keyword">A</span>，究竟时调用哪个<span class="hljs-keyword">A</span>的方法呢，编译器也不知道，就会报错，所以有了虚继承，解决了空间浪费以及二义性问题。在虚拟继承下，只有一个共享的基类子对象被继承，而无论该基类在派生层次中出现多少次。共享的基类子对象被称为虚基类。在虚继承下，基类子对象的复制及由此而引起的二义性都被消除了。</code></pre><h2 id="为什么虚函数表中有两个析构函数"><a href="#为什么虚函数表中有两个析构函数" class="headerlink" title="为什么虚函数表中有两个析构函数"></a>为什么虚函数表中有两个析构函数</h2><pre><code class="hljs vim">我们可以看到虚函数表中有两个析构函数，一个标志为deleting，一个标志为<span class="hljs-built_in">complete</span>（不执行<span class="hljs-keyword">delete</span>），因为对象有两种构造方式，栈构造和堆构造，所以对应的实现上，对象也有两种析构方式，其中堆上对象的析构和栈上对象的析构不同之处在于，栈内存的析构不需要执行 <span class="hljs-keyword">delete</span> 函数，会自动被回收。为什么构造函数不能是虚函数？构造函数就是为了在编译阶段确定对象的类型以及为对象分配空间，如果类中有虚函数，那就会在构造函数中初始化虚函数表，虚函数的执行却需要依赖虚函数表。如果构造函数是虚函数，那它就需要依赖虚函数表才可执行，而只有在构造函数中才会初始化虚函数表，鸡生蛋蛋生鸡的问题，很矛盾，所以构造函数不能是虚函数。</code></pre><h2 id="为什么基类析构函数要是虚函数？"><a href="#为什么基类析构函数要是虚函数？" class="headerlink" title="为什么基类析构函数要是虚函数？"></a>为什么基类析构函数要是虚函数？</h2><pre><code class="hljs plain">一般基类的析构函数都要设置成虚函数，因为如果不设置成虚函数，在析构的过程中只会调用到基类的析构函数而不会调用到子类的析构函数，可能会产生内存泄漏。</code></pre><h2 id="构造函数和析构函数中为什么不可以调用虚函数-不会出现多态-？"><a href="#构造函数和析构函数中为什么不可以调用虚函数-不会出现多态-？" class="headerlink" title="构造函数和析构函数中为什么不可以调用虚函数(不会出现多态)？"></a>构造函数和析构函数中为什么不可以调用虚函数(不会出现多态)？</h2><pre><code class="hljs plain">背景知识：构造子类对象时，首先调用父类构造函数初始化对象的父类部分，在执行父类的构造函数时，对象的子类部分都是未初始化的，实际上此时对象还不是一个子类对象析构子类对象时，先析构子类部分，然后按照构造顺序逆序析构父类部分所以在运行子类的构造和析构函数时，对象都是不完整的，为了适应这种不完整，编译器视对象类型为当前构造或析构函数所在类的类型，由此造成的结果就是：在父类的构造或析构函数中，会将子类对象当作父类对象看待在这样的背景下，如果我们在父类的构造或析构函数中调用虚函数，调用的往往是当前类的虚函数，达不到多态的效果，跟普通函数调用没有区别</code></pre><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><pre><code class="hljs cpp">offset_to_top：对象在对象布局中与对象顶部地址的偏移量。RTTI指针：指向存储运行时类型信息(type_info)的地址，用于运行时类型识别，用于<span class="hljs-keyword">typeid</span>和<span class="hljs-keyword">dynamic_cast</span>。vbase_offset：对象在对象布局中与指向虚基类虚函数表的指针地址的偏移量。vcall_offset：父类引用或指针指向子类对象，调用被子类重写的方法时，用于对虚函数执行指针地址调整，方便成功调用被重写的方法。thunk: 表示上面虚函数表中带有adjustment字段的函数调用需要先进行<span class="hljs-keyword">this</span>指针调整，才可以调用到被子类重写的函数。</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>虚函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>const and static and volatile用法</title>
    <link href="/2021/12/21/C++/const_static_votatile%E7%94%A8%E6%B3%95/"/>
    <url>/2021/12/21/C++/const_static_votatile%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="static用法"><a href="#static用法" class="headerlink" title="static用法"></a>static用法</h1><p>主要是表明某个变量是模块私有的，放在静态区，和全局变量放在一个区域，默认初始化为0，在类实例化之前，静态变量区域的变量就已经初始化好了。</p><p>具体分为几种情况：<br>1类成员变量，初始化后不可改变，只能在类外初始化，可由类直接访问，也可以用对象访问。</p><p>2类成员函数，只能访问静态成员变量，可有类直接访问，而且由于是修饰类的，没有this指针。</p><p>3局部变量，在模块外不可使用，实际上变成全局的，但是只能在这个模块内用。</p><p>4某个文件全局变量，不可在文件外使用，即使用了extern</p><p>5静态函数，只能在本文件调用，其他文件不可以调用</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>规则：const离谁近，谁就不能被修改；</p><p>const修饰一个变量时，一定要给这个变量初始化，若不初始化，在后面也不能初始化。</p><p>例如const int *p=1;<br>p指向的内容是不可以改变的，可以去除int来看，易于理解。</p><p> int* const p=1;<br>指针的地址是不可改变的。</p><p>这个和&amp;的语法糖是一样的T * const p</p><p>C++ 在函数前面使用const 代表返回值为const的</p><p>在函数后面使用const代表函数不可以修改数据成员，同时只能用在非静态成员函数中。 </p><h1 id="关键字volatile有什么含意？并给出三个不同的例子。"><a href="#关键字volatile有什么含意？并给出三个不同的例子。" class="headerlink" title="关键字volatile有什么含意？并给出三个不同的例子。"></a>关键字volatile有什么含意？并给出三个不同的例子。</h1><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><p>1：并行设备的硬件寄存器（如：状态寄存器）</p><p>2：一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</p><p>3：多线程应用中被几个任务共享的变量</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏定义</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言宏定义和一些小用法</title>
    <link href="/2021/12/21/C++/c%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%94%A8%E6%B3%95/"/>
    <url>/2021/12/21/C++/c%E8%AF%AD%E8%A8%80%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>UL后缀代表无符号长整型后缀<br><pre><code class="hljs angelscript">#define SEC_YEAR  (<span class="hljs-number">365</span>*<span class="hljs-number">24</span>*<span class="hljs-number">60</span>*<span class="hljs-number">60</span>)UL</code></pre></p><p>下面的宏定义代表最小值，但是会有副作用<br><pre><code class="hljs lisp">#define MIN(<span class="hljs-name">a</span>,b)  ((<span class="hljs-name">a</span>)&lt;=(<span class="hljs-name">b</span>)?(<span class="hljs-name">a</span>):(<span class="hljs-name">b</span>))</code></pre><br>例如使用MIN(a++,b),此时可以使用下面的代替<br><pre><code class="hljs sqf"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min_i(x,y)    ((x)&lt;=(y)?(x):(y))      <span class="hljs-comment">//（1）</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min_t(type,x,y) (&#123;type _x = x;\       <span class="hljs-comment">//（2）</span></span>                        <span class="hljs-built_in">type</span> <span class="hljs-variable">_y</span> = y;\                        <span class="hljs-variable">_x</span>&lt;<span class="hljs-variable">_y</span>?<span class="hljs-variable">_x</span>:<span class="hljs-variable">_y</span>;\                        &#125;)<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> min(x,y)    &#123;const typeof(x)  _x = (x);\  <span class="hljs-comment">//（3）</span></span>                    const <span class="hljs-built_in">typeof</span>(y) <span class="hljs-variable">_y</span> = (y);\                    (void)(&amp;<span class="hljs-variable">_x</span>=&amp;<span class="hljs-variable">_y</span>);\      <span class="hljs-comment">//（4）</span>                    <span class="hljs-variable">_x</span>&lt;<span class="hljs-variable">_y</span>?<span class="hljs-variable">_x</span>:<span class="hljs-variable">_y</span>;\                    &#125;)</code></pre><br>这个定义计算x和y分别两次（x和y中的小者被计算两次)，当参数由副作用时，将产生不正确的结果<br>使用语句表达式只计算参数一次，避免了可能的错误，语句表达式通常用于宏定义<br>typeof(x)表示x的值类型<br>检查参数x和y的类型是否相同(如果x和y的类型不同编译器将会发出warning，并不影响后面语句的运行</p><p>e)int <em>a[10]指针数组，</em>修饰后面的每个元素，数组的每个元素都是指针</p><p>f)int (<em>a)[10]，指向数组的指针，</em>修饰a，</p><p>g)int (*a)(int a)，函数指针a，这个函数返回值为int，参数为int</p><p>h)int (*a[10])(int)，用指针数组指向函数，该函数有一个整型参数并返回一个整型数</p><p>访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。</p><pre><code class="hljs apache"><span class="hljs-attribute">ptr</span> = (int *)<span class="hljs-number">0</span>x<span class="hljs-number">67</span>a<span class="hljs-number">9</span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏定义</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL的图形界面设置</title>
    <link href="/2021/12/21/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/WSL%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/"/>
    <url>/2021/12/21/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/WSL%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="安装xserver"><a href="#安装xserver" class="headerlink" title="安装xserver"></a>安装xserver</h2><p>首先是Windows上Xserver的安装，<br>作者这里选择的是VcXsrv X Server，下载之后按照所有默认设置进行安装即可。安装完毕之后打开防火墙配置，允许所有的Xserver连接。</p><p>然后安装apt-get install xfce4和xfce4-terminal</p><p>打开XLaunch，在Display settings里面将Display number改为0，在Extra settings里面勾选Disable access control，启动Xserver。</p><p>然后是WSL2里面的配置，作者是用Ubuntu，其他发行版也类似。首先<br><pre><code class="hljs jboss-cli">sudo vim ~<span class="hljs-string">/.zshrc</span><span class="hljs-comment"># sudo vim ~/.bashrc</span></code></pre></p><pre><code class="hljs reasonml"># export DISPLAY=:<span class="hljs-number">0</span> # <span class="hljs-keyword">in</span> WSL <span class="hljs-number">1</span>export DISPLAY=<span class="hljs-constructor">$(<span class="hljs-params">awk</span> &#x27;<span class="hljs-operator">/</span><span class="hljs-params">nameserver</span> <span class="hljs-operator">/</span> &#123;<span class="hljs-params">print</span> $2; <span class="hljs-params">exit</span>&#125;&#x27; <span class="hljs-operator">/</span><span class="hljs-params">etc</span><span class="hljs-operator">/</span><span class="hljs-params">resolv</span>.<span class="hljs-params">conf</span> 2&gt;<span class="hljs-operator">/</span><span class="hljs-params">dev</span><span class="hljs-operator">/</span><span class="hljs-params">null</span>)</span>:<span class="hljs-number">0</span> # <span class="hljs-keyword">in</span> WSL <span class="hljs-number">2</span></code></pre><p>然后source  ~/.zshrc就可以了</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WSL</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树压缩和解压缩</title>
    <link href="/2021/12/21/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2021/12/21/%E7%AE%97%E6%B3%95/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>主要是把字符串读到vector中，然后记录每个字符出现的次数，然后构建哈夫曼树，然后再生成哈夫曼编码，再写入。</p><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt; </span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bitset&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">long</span> byteNum = <span class="hljs-number">0</span>;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> weight;    <span class="hljs-keyword">int</span> parent, lchild, rchild;&#125;HafuNode, * HufumanTree;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span>* data;    <span class="hljs-keyword">int</span>* num;    <span class="hljs-keyword">int</span> length;&#125;TNode;<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">char</span>* data;    <span class="hljs-keyword">char</span>** HM;&#125;Code;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span>** HuffmanCode;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hafuman</span></span><span class="hljs-class">&#123;</span><span class="hljs-keyword">private</span>:    HuffmanCode code;    TNode tnod;    HufumanTree hafutree;    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">char</span>&gt; hafumanHash;    <span class="hljs-comment">//存文件内容</span>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">char</span>&gt; str;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">compression</span><span class="hljs-params">(<span class="hljs-built_in">string</span> decomFile,<span class="hljs-built_in">string</span> comFile)</span></span><span class="hljs-function">    </span>&#123;        Read(comFile);        TNodeCount();        CreateHuffmanTree();        CreatHuffmanCode();        <span class="hljs-keyword">int</span> i, j, k;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">bit</span> = <span class="hljs-number">0</span>;        <span class="hljs-function">ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;compression.txt&quot;</span>, ios::out)</span></span>;        <span class="hljs-function">ofstream <span class="hljs-title">outComFile</span><span class="hljs-params">(decomFile, ios::out)</span></span>;        <span class="hljs-keyword">if</span> (!outfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-comment">//写入编码</span>        outComFile &lt;&lt; tnod.length &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tnod.length; i++)        &#123;            outComFile &lt;&lt; tnod.data[i];            outComFile &lt;&lt; code[i + <span class="hljs-number">1</span>];            outComFile &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        &#125;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)        &#123;            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; tnod.length; j++)            &#123;                <span class="hljs-keyword">if</span> (tnod.data[j] == str[i])                &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; code[j + <span class="hljs-number">1</span>][k] != <span class="hljs-string">&#x27;\0&#x27;</span>; k++)            &#123;                outfile &lt;&lt; code[j + <span class="hljs-number">1</span>][k];                <span class="hljs-keyword">if</span> (code[j + <span class="hljs-number">1</span>][k] == <span class="hljs-string">&#x27;0&#x27;</span>)                &#123;                    tmp = tmp | <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    tmp = (tmp | <span class="hljs-number">1</span>);                &#125;                <span class="hljs-built_in">bit</span> = (<span class="hljs-built_in">bit</span> + <span class="hljs-number">1</span>) % <span class="hljs-number">32</span>;                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">bit</span>)                &#123;                    outComFile &lt;&lt; tmp &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;                    tmp = <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span>                    tmp = tmp &lt;&lt; <span class="hljs-number">1</span>;                byteNum++;            &#125;        &#125;        tmp = tmp &lt;&lt; (<span class="hljs-number">32</span> - byteNum % <span class="hljs-number">32</span> - <span class="hljs-number">1</span>);        outComFile &lt;&lt; tmp &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;        outComFile &lt;&lt; byteNum;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;文件的总的字符数为 &quot;</span> &lt;&lt; byteNum &lt;&lt; <span class="hljs-built_in">endl</span>;        outfile.<span class="hljs-built_in">close</span>();        <span class="hljs-comment">//写总共的位数</span>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;压缩成功!,可以到compression.txt中查看具体二进制码，压缩文件为 &quot;</span>&lt;&lt;decomFile &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-comment">//outComFile.seekg(0, ios::beg);</span>        <span class="hljs-comment">//streampos size = outComFile.tellg();</span>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;压缩文件大小为：&quot;</span> &lt;&lt; byteNum/<span class="hljs-number">8</span> &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        outComFile.<span class="hljs-built_in">close</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decompression</span><span class="hljs-params">(<span class="hljs-built_in">string</span> decomFilename, <span class="hljs-built_in">string</span> comfilename)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">char</span> a[<span class="hljs-number">30</span>];        <span class="hljs-function">ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(comfilename, ios::out)</span></span>;        <span class="hljs-function">ifstream <span class="hljs-title">inComfile</span><span class="hljs-params">(decomFilename, ios::in)</span></span>;        <span class="hljs-keyword">if</span> (!outfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">if</span> (!inComfile)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">int</span> bytenum;        inComfile.seekg(<span class="hljs-number">-2L</span>, ios::<span class="hljs-built_in">end</span>);        inComfile &gt;&gt; bytenum;        inComfile.seekg(<span class="hljs-number">0</span>, ios::beg);        <span class="hljs-keyword">int</span> codeNum;        inComfile &gt;&gt; codeNum;        <span class="hljs-keyword">char</span>* code = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">100</span>];        <span class="hljs-keyword">char</span> ch;        <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">char</span>&gt; hash;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; codeNum; i++)        &#123;            inComfile &gt;&gt; ch;            inComfile &gt;&gt; code;            <span class="hljs-built_in">string</span> tmp = code;            hash[tmp] = ch;        &#125;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> m;        <span class="hljs-built_in">string</span> mystr = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span> (; bytenum &gt;= <span class="hljs-number">32</span>; bytenum -= <span class="hljs-number">32</span>)        &#123;            inComfile &gt;&gt; m;            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0x80000000</span>;            <span class="hljs-keyword">int</span> countForByte = <span class="hljs-number">32</span>;            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">if</span> (!(mask &amp; m))                    mystr.append(<span class="hljs-string">&quot;0&quot;</span>);                <span class="hljs-keyword">else</span>                    mystr.append(<span class="hljs-string">&quot;1&quot;</span>);                m = m &lt;&lt; <span class="hljs-number">1</span>;                countForByte--;                <span class="hljs-keyword">if</span> (hash.count(mystr))                &#123;                    outfile &lt;&lt; hash[mystr];                    mystr = <span class="hljs-string">&quot;&quot;</span>;                &#125;                <span class="hljs-keyword">if</span> (countForByte &lt;= <span class="hljs-number">0</span>)                    <span class="hljs-keyword">break</span>;            &#125;        &#125;        inComfile &gt;&gt; m;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">0x80000000</span>;        <span class="hljs-keyword">int</span> countForByte = bytenum;        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">if</span> (!(mask &amp; m))                mystr.append(<span class="hljs-string">&quot;0&quot;</span>);            <span class="hljs-keyword">else</span>                mystr.append(<span class="hljs-string">&quot;1&quot;</span>);            m = m &lt;&lt; <span class="hljs-number">1</span>;            countForByte--;            <span class="hljs-keyword">if</span> (hash.count(mystr))            &#123;                outfile &lt;&lt; hash[mystr];                mystr = <span class="hljs-string">&quot;&quot;</span>;            &#125;            <span class="hljs-keyword">if</span> (countForByte &lt;= <span class="hljs-number">0</span>)                <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;解压成功！解压文件为&quot;</span> &lt;&lt; comfilename&lt;&lt;<span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">delete</span> code;        code = <span class="hljs-literal">nullptr</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreatHuffmanCode</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = tnod.length;        <span class="hljs-keyword">int</span> pare, child, start;        code = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>* [n + <span class="hljs-number">1</span>];        <span class="hljs-keyword">char</span>* cd = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];        cd[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            start = n - <span class="hljs-number">1</span>;            child = i;            pare = hafutree[i].parent;            <span class="hljs-keyword">while</span> (pare != <span class="hljs-number">0</span>)            &#123;                start--;                <span class="hljs-keyword">if</span> (child == hafutree[pare].lchild)                &#123;                    cd[start] = <span class="hljs-string">&#x27;0&#x27;</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    cd[start] = <span class="hljs-string">&#x27;1&#x27;</span>;                &#125;                child = pare;                pare = hafutree[child].parent;            &#125;            code[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n - start];            <span class="hljs-built_in">strcpy</span>(code[i], &amp;cd[start]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            <span class="hljs-built_in">cerr</span> &lt;&lt; tnod.data[i<span class="hljs-number">-1</span>] &lt;&lt; <span class="hljs-string">&quot;权重 : &quot;</span> &lt;&lt; tnod.num[i<span class="hljs-number">-1</span>];            <span class="hljs-built_in">cerr</span> &lt;&lt;<span class="hljs-string">&quot;二进制编码为&quot;</span>&lt;&lt; code[i] &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">delete</span> cd;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initTnode</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        tnod.data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">256</span>];        tnod.num = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];        <span class="hljs-keyword">if</span> (tnod.data == <span class="hljs-literal">NULL</span> || tnod.num == <span class="hljs-literal">NULL</span>)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;发生错误&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        tnod.length = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Read</span><span class="hljs-params">( <span class="hljs-built_in">string</span> filename)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">char</span> ch;        <span class="hljs-function">ifstream <span class="hljs-title">infile</span><span class="hljs-params">(filename, ios::in)</span></span>;        <span class="hljs-keyword">if</span> (!infile)        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;open error&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">while</span> (infile.<span class="hljs-built_in">peek</span>() != EOF)        &#123;            infile.<span class="hljs-built_in">get</span>(ch);            str.push_back(ch);        &#125;        infile.seekg(<span class="hljs-number">0</span>, ios::<span class="hljs-built_in">end</span>);        streampos <span class="hljs-built_in">size</span> = infile.tellg();        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;源文件大小为：&quot;</span> &lt;&lt; <span class="hljs-built_in">size</span> &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        infile.<span class="hljs-built_in">close</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> ch, TNode t)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length; i++)        &#123;            <span class="hljs-keyword">if</span> (t.data[i] == ch)            &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TNodeCount</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> m = str.<span class="hljs-built_in">size</span>(), j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">char</span> ch;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)        &#123;            ch = str[i];            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">find</span>(ch, tnod))            &#123;                tnod.data[j] = ch;                tnod.num[j] = count(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), ch);                tnod.length++;                j++;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Select</span><span class="hljs-params">(HufumanTree&amp; tree, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>&amp; b, <span class="hljs-keyword">int</span>&amp; c)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> min1, min2, minweight = <span class="hljs-number">10000</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)        &#123;            <span class="hljs-keyword">if</span> (tree[i].parent == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (tree[i].weight &lt; minweight)                &#123;                    minweight = tree[i].weight;                    min1 = i;                &#125;            &#125;        &#125;        tree[min1].parent = <span class="hljs-number">1</span>;        minweight = <span class="hljs-number">10000</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= a; i++)        &#123;            <span class="hljs-keyword">if</span> (tree[i].parent == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">if</span> (tree[i].weight &lt; minweight)                &#123;                    minweight = tree[i].weight;                    min2 = i;                &#125;            &#125;        &#125;        tree[min2].parent = <span class="hljs-number">1</span>;        b = min1;        c = min2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateHuffmanTree</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> n = tnod.length;        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>)        &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">int</span> m = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>;        hafutree = <span class="hljs-keyword">new</span> HafuNode[m + <span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<span class="hljs-comment">//为0表示没有左右节点，父节点</span>        &#123;            hafutree[i].lchild = <span class="hljs-number">0</span>;            hafutree[i].parent = <span class="hljs-number">0</span>;            hafutree[i].rchild = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        &#123;            hafutree[i].weight = tnod.num[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">int</span> s1, s2;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= m; i++)        &#123;            Select(hafutree, i - <span class="hljs-number">1</span>, s1, s2);            hafutree[s1].parent = i;            hafutree[s2].parent = i;            hafutree[i].lchild = s1;            hafutree[i].rchild = s2;            hafutree[i].weight = hafutree[s1].weight + hafutree[s2].weight;        &#125;    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Hafuman  hafumanClass;    hafumanClass.initTnode();    <span class="hljs-built_in">string</span> command;    <span class="hljs-keyword">char</span> commandOpt;    <span class="hljs-built_in">string</span> comFile, deComFile;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    &#123;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;请输入选择的功能&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;1.压缩文件（SZip A  xx.haf test.txt（需要压缩的文件名）)&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;2.解压文件（SZip X  xx.haf test1.txt(解压的文件名))&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cin</span> &gt;&gt; command;        <span class="hljs-built_in">cin</span> &gt;&gt; commandOpt;        <span class="hljs-keyword">if</span> (command != <span class="hljs-string">&quot;SZip&quot;</span>||(commandOpt!=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp; commandOpt != <span class="hljs-string">&#x27;X&#x27;</span>))        &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;命令输入错误，请重新输入 &quot;</span> ;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">cin</span> &gt;&gt; deComFile &gt;&gt; comFile;        <span class="hljs-keyword">switch</span> (commandOpt)        &#123;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:            hafumanClass.compression(deComFile, comFile);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:            hafumanClass.decompression(deComFile,comFile);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>:            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;输入错误！请重新输入&quot;</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>树</category>
      
      <category>压缩算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
      <tag>哈夫曼树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex中文使用miktex，ctexart</title>
    <link href="/2021/12/21/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/latex%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/21/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/latex%E4%B8%AD%E6%96%87%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="latex中文使用miktex，ctexart"><a href="#latex中文使用miktex，ctexart" class="headerlink" title="latex中文使用miktex，ctexart"></a>latex中文使用miktex，ctexart</h2><pre><code class="hljs latex"><span class="hljs-tag">\<span class="hljs-name">documentclass</span><span class="hljs-string">[UTF8]</span><span class="hljs-string">&#123;ctexart&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">[T1]</span><span class="hljs-string">&#123;fontenc&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;listings&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;graphicx&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;xcolor&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;fancyhdr&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">usepackage</span><span class="hljs-string">&#123;lastpage&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">pagestyle</span><span class="hljs-string">&#123;fancy&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">chead</span><span class="hljs-string">&#123;西安邮电大学实验报告&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">lhead</span><span class="hljs-string">&#123;&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">rhead</span><span class="hljs-string">&#123;&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">lstset</span><span class="hljs-string">&#123;numbers=left,   %用来设置代码块的</span></span><span class="hljs-tag"><span class="hljs-string">numberstyle= \tiny,keywordstyle= \color&#123; blue!70&#125;</span></span>,commentstyle=<span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123;red!50!green!50!blue!50&#125;</span></span>,   frame=shadowbox, rulesepcolor= <span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123; red!20!green!20!blue!20&#125;</span></span>,   escapeinside=``&#125; <span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;document&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">tableofcontents</span></span><span class="hljs-tag">\<span class="hljs-name">clearpage</span></span><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;lstlisting&#125;</span><span class="hljs-string">[language=&#123;[ANSI]</span></span>C&#125;,numbers=left,numberstyle=<span class="hljs-tag">\<span class="hljs-name">tiny</span></span>,<span class="hljs-comment">%frame=shadowbox,  </span>    rulesepcolor=<span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123;red!20!green!20!blue!20&#125;</span></span>,      keywordstyle=<span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123;blue!70!black&#125;</span></span>,      commentstyle=<span class="hljs-tag">\<span class="hljs-name">color</span><span class="hljs-string">&#123;blue!90!&#125;</span></span>,      basicstyle=<span class="hljs-tag">\<span class="hljs-name">ttfamily</span></span>] <span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;document&#125;</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学公式</tag>
      
      <tag>latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode29_两数相除</title>
    <link href="/2021/12/19/%E7%AE%97%E6%B3%95/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/"/>
    <url>/2021/12/19/%E7%AE%97%E6%B3%95/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="方法主要是用了倍增的思想-位运算"><a href="#方法主要是用了倍增的思想-位运算" class="headerlink" title="方法主要是用了倍增的思想+位运算"></a>方法主要是用了倍增的思想+位运算</h2><p>如果能用long，就用位运算，再判断溢出的特例。<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> divide(<span class="hljs-built_in">int</span> dividend, <span class="hljs-built_in">int</span> divisor)     &#123;        <span class="hljs-built_in">int</span> flag;        <span class="hljs-keyword">if</span>((dividend&gt;<span class="hljs-number">0</span>&amp;&amp;divisor&gt;<span class="hljs-number">0</span>)||(divisor&lt;<span class="hljs-number">0</span>&amp;&amp;dividend&lt;<span class="hljs-number">0</span>))            flag=<span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>            flag=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(dividend==<span class="hljs-number">0x80000000</span>&amp;&amp;divisor==<span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0x7fffffff</span>;        long long div1=abs(long(dividend)),div2=abs(long(divisor));        long long res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(div1&gt;=div2)        &#123;            <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>((div1&gt;&gt;(tmp+<span class="hljs-number">1</span>))&gt;=(div2))            &#123;                tmp++;            &#125;            div1-=(div2&lt;&lt;(tmp));            res+=(<span class="hljs-number">1</span>&lt;&lt;tmp);        &#125;        <span class="hljs-keyword">return</span> res*flag;    &#125;&#125;;</code></pre></p><p>如果不能用long，就用倍增的方法+同时将数全部化为负数，然后要控制数小于INT_MIN/2的情况。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> divide(<span class="hljs-built_in">int</span> dividend, <span class="hljs-built_in">int</span> divisor) &#123;    <span class="hljs-built_in">int</span> flag;    <span class="hljs-keyword">if</span>((dividend&gt;<span class="hljs-number">0</span>&amp;&amp;divisor&gt;<span class="hljs-number">0</span>)||(divisor&lt;<span class="hljs-number">0</span>&amp;&amp;dividend&lt;<span class="hljs-number">0</span>))        flag=<span class="hljs-number">1</span>;    <span class="hljs-keyword">else</span>        flag=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(dividend==<span class="hljs-number">0x80000000</span>&amp;&amp;divisor==<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0x7fffffff</span>;    <span class="hljs-built_in">int</span> div1=dividend,div2=divisor;    <span class="hljs-keyword">if</span>(dividend&gt;<span class="hljs-number">0</span>)        div1=-dividend;    <span class="hljs-keyword">if</span>(divisor&gt;<span class="hljs-number">0</span>)        div2=-divisor;    <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(div1&lt;=div2)    &#123;        <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">-1</span>;        <span class="hljs-built_in">int</span> div2tmp=div2;        <span class="hljs-keyword">while</span>(div2tmp&gt;=INT_MIN/<span class="hljs-number">2</span>&amp;&amp;((div1)&lt;=(div2tmp+div2tmp)))        &#123;            div2tmp+=div2tmp;            tmp+=tmp;        &#125;        div1-=div2tmp;        res+=tmp;    &#125;    <span class="hljs-keyword">return</span> res*-flag;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>leettcode</tag>
      
      <tag>位运算</tag>
      
      <tag>倍增思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft算法</title>
    <link href="/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8F/raft%20%E7%AE%97%E6%B3%95/"/>
    <url>/2021/05/25/%E5%88%86%E5%B8%83%E5%BC%8F/raft%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h1><p>实现raft算法（一种共识算法），raft相比 paxos更容易理解，是一种强leader，日志只能从leader复制日志到其他服务器，复制是用来解决分布式系统的容错的问题的。</p><p>复制状态机就是这种用来解决分布式系统的容错的问题的，在怎么做的呢？<br>复制状态机是通过复制日志来实现的，每个服务器都有相同的日志</p><p>raft算法不依赖于时间</p><p>raft这种一致性算法就是为了实现分布式的容错性，通过保证复制日志的一致性来实现的。<br>为了解决这个问题，实际上是通过raft实际上只有三个问题。</p><p>主要是选择一个确定的Leader，然后通过leader管理日志的复制，leader接收来自客户端的请求并追加到本地日志，然后把日志复制到其他机器并告诉它们什么时候可以安全的将日志提交到状态机。</p><p>raft主要是三个问题：</p><p>1 是如何选举出leader</p><p>2 如何复制日志，leader接受来自客户端的请求并把日志复制到集群来保证其他机器的日志与自己的相同</p><p>3 怎么保证安全，安全指的是，一旦有一个机器将特定的日志复制到自己的状态机，那么其他机器不能够应用一条不同的日志到自己的状态机。（主要是在选举时增加额外的规则约束）</p><h1 id="当客户端连接到follewer"><a href="#当客户端连接到follewer" class="headerlink" title="当客户端连接到follewer"></a>当客户端连接到follewer</h1><p>那么参与者会将其重定向到leader。</p><h1 id="raft的任期"><a href="#raft的任期" class="headerlink" title="raft的任期"></a>raft的任期</h1><p>任期是一个任意长度的间隔，每个任期由连续的整数组成，而且任期是单调递增的，server通讯会交换互相的任期。</p><p>如果发现自己的任期小于对方的，会变更自己的任期到大的那个任期。如果candidate或者leader发现自己的任期过期，那么就会变为follower。任意的server接收到过期的请求就会拒绝请求。</p><h1 id="raft的RPC通讯"><a href="#raft的RPC通讯" class="headerlink" title="raft的RPC通讯"></a>raft的RPC通讯</h1><p>raft是通过RPC通讯的，主要是两个RPC，一个是requestVoteRPC（请求投票） 和AppendentriesRPC（进行日志复制和心跳）以及doInstallSnapshotRPC（传送快照）</p><h1 id="1-如何选举leader"><a href="#1-如何选举leader" class="headerlink" title="1.如何选举leader"></a>1.如何选举leader</h1><p>server一开始启动都是参与者，然后经过一段时间的超时（即没有收到leader的心跳），那么就会发起选举，转换为candidate，然后增加自己的任期，投票给自己，然后向其他的server发起requestVoteRPC（请求投票）,只要收到超过一半的server投票给自己，那么就转变为leader。一旦成为leader，就会发送心跳给其他人，说明自己胜出。</p><p>只有在发起requestVoteRPC（请求投票）的server的任期更新或者日志不更旧的情况下才可以给他投票，否则就会拒绝投票。</p><p>同时为了防止没有一个机器拿到一半以上的投票，leader超时的时间是随机150ms到300ms之间。</p><h1 id="2-如何进行日志的复制"><a href="#2-如何进行日志的复制" class="headerlink" title="2.如何进行日志的复制"></a>2.如何进行日志的复制</h1><p>当有一个server是leader，他会处理来自client的请求，首先会将请求追加到自己日志记录，然后发送AppendentriesRPC进行日志复制，日志复制成功之后，leader会将日志应用到自己的状态机并将结果返回给客户端。如果follower宕机或者丢包了，会重复发送AppendentriesRPC直到安全的复制。</p><p>日志包括command，以及term，以及index(记录在日志中的位置)</p><p>当日志被应用到状态机，这样的日志被称为已经提交。</p><p>raft保证所有被提交的日志都会被应用到状态机。如果当前日志被提交那么由前任leader或者由当前leader之前创建的日志记录也都被提交了。</p><p>leader维护了被提交日志记录的索引，这个索引会放在AppendentriesRPC（进行日志复制和心跳）中，当参与者收到RPC中的提交的索引的时候，会将本地该索引的日志应用到状态机。</p><h2 id="日志匹配原则："><a href="#日志匹配原则：" class="headerlink" title="日志匹配原则："></a>日志匹配原则：</h2><p>1.如果两条日志记录的索引和任期是一样的，那么这两条日志记录的命令也是一样的</p><p>2.如果两条日志记录的索引和任期是一样的，那么这两条日志记录的之前的日志记录也是一样的。</p><p>给定日期的日志索引是递增的，并且创建之后不会改变他在日志中的位置（保证了第一条）</p><p>AppendentriesRPC（进行日志复制和心跳）会包含当前正在复制的日志记录的前继日志记录的索引和任期，如果follower发现自己的日志中没有这一条就会拒绝请求。（保证了第二条）</p><h2 id="follower与leader日志不同的时候"><a href="#follower与leader日志不同的时候" class="headerlink" title="follower与leader日志不同的时候"></a>follower与leader日志不同的时候</h2><p>follwer可能比leader日志多或者少，可能日志不一致。</p><p>raft强制follower只能复制leader的日志来解决不一致问题，即follower与leader冲突的时候，follower会重写或者删除。</p><p>这个时候需要确认它们相同的最后一条日志，然后让follower删除之后的，然后再把leader剩下的复制给follower。</p><p>leader为每一个follower维护了nextIndex(记录需要复制给follower的下一个日志索引，初始值为leader最后一条日志的索引)。当出现不匹配的时候可能需要找nextindex，那么每次leader发RPC会nextindex减一尝试寻找一致的位置，但是效率会很低，所以为了提速可以follower直接响应这个任期的第一条日志（相当于这个任期的日志都不要了，重新从leader复制过来）</p><h1 id="3-如何保持安全"><a href="#3-如何保持安全" class="headerlink" title="3.如何保持安全"></a>3.如何保持安全</h1><p>安全指的是，一旦有一个机器将特定的日志复制到自己的状态机，那么其他机器不能够应用一条不同的日志到自己的状态机。（主要是在选举时增加额外的规则约束）</p><p>这里添加的约束有这些</p><h2 id="1选举约束"><a href="#1选举约束" class="headerlink" title="1选举约束"></a>1选举约束</h2><p>每个raft的leader必须包含之前已经提交的日志。在选举中，一个candidate必须包含所有已经提交的日志才会胜出。</p><p>requestVoteRPC（请求投票）实现这个约束：在RPC中包含leader的日志信息，如果投票者的日志比候选者更新那么其拒绝投票（这是通过比较日志的最后一条的任期和索引来比较的，任期大的更新，任期一样，索引大的更新）</p><h2 id="2-提交上一个任期的日志"><a href="#2-提交上一个任期的日志" class="headerlink" title="2.提交上一个任期的日志"></a>2.提交上一个任期的日志</h2><p>为了解决fig8的问题，即一个日志已经被复制到大部分的机器，但是leader在提交日志之前宕机了。</p><p>这种情况下虽然日志被复制到大部分机器，但是仍然可能被后面的leader覆盖掉，为了防止这个情况，raft不能够提交上一个任期的日志，只有当前任期的日志才可以被提交，在提交当前任期的时候，顺手提交之前的日志。</p><h2 id="细说fig8"><a href="#细说fig8" class="headerlink" title="细说fig8"></a>细说fig8</h2><p>在时刻(a), s1是leader，在term2提交的日志只赋值到了s1 s2两个节点就crash了。在时刻（b), s5成为了term 3的leader，日志只赋值到了s5，然后crash。</p><p>关键点在于c,在(c)时刻，s1又成为了term 4的leader，开始复制日志，于是把term2的日志复制到了s3，此刻，可以看出term2对应的日志已经被复制到了majority，假设上个任期的日志可以被提交（例如term2，但是实际上是不行的），那么term2被提交，应用到状态机。</p><p>那么接下来（d）时刻，s1又crash了，s5重新当选（S2,s3,s4)，然后将term3的日志复制到所有节点,这个时候就冲突了，因为按道理s5没有已经提交的最新的日志（1，2），是不可以当选leader的。</p><p>究其根本，是因为 term4的时候leader s1 在（c）时刻提交了之前term2任期的日志。</p><p>为了杜绝这种情况：在某个leader选举成功后，不可以直接提交前任leader 时期的日志，可以复制日志，比如说把term2和term4复制到大多数，然后提交term4，顺手提交了term2，而是通过提交当前任期的日志的时候，‘顺手’把之前的日志提交了。如果leader 选举之后没有收到客户端的请求呢？，在任期来时的时候立即尝试复制、提交一条空 log。</p><p>因此在c图中，term2不会被提交，只有4被复制到大多数，才会1，2，4一起被提交。</p><p>如果我们假设term4没有被复制到大多数s1就宕机了，s5任期增加编程term5，赢得任期，那么它可以只有1，3，5被复制到大多数的情况下才可以提交term5的时候顺便提交term3.</p><p>因此 在上图中不会出现（c）的情况，即term4任期的leader s1不会复制term2 的日志到s3。而是如同（e）描述的情况，通过复制-提交term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2 的日志也一定提交成功，此时，即使 s1 crash，s5也不会重新当选。</p><h2 id="如果参与者和候选者宕机"><a href="#如果参与者和候选者宕机" class="headerlink" title="如果参与者和候选者宕机"></a>如果参与者和候选者宕机</h2><p>如果候选者或者参与者宕机，leader会重复发送RPC，raft请求是可重入的，重试没有危害，如果候选者接受的AppendentriesRPC（进行日志复制和心跳）日志已经被存储，那么就会直接忽略这些请求。</p><h2 id="时基和可用性"><a href="#时基和可用性" class="headerlink" title="时基和可用性"></a>时基和可用性</h2><p>设server并行发送RPC，并接收到它们回应的平均时间设为broadtime</p><p>设单台机器的平均故障间隔时间为MTBF</p><p>设选举时间为electtime</p><p>需要满足broadtime《electtime《MTBF</p><h1 id="集群成员变更"><a href="#集群成员变更" class="headerlink" title="集群成员变更"></a>集群成员变更</h1><p>待更新</p><p>暂时可以参考<a href="https://segmentfault.com/a/1190000022796386">raft成员变更</a></p><h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>集群的日志会不断增长，维克可用性，需要压缩日志。</p><p>快照是最简单的压缩办法。</p><p>每个机器独立的进行快照压缩，快照只会覆盖已经提交的日志。</p><p>快照包含最后一条被快照取代的日志的索引。（lastIncludeIndex）</p><p>快照包含最后一条被快照取代的日志的任期。（lastIncludeTerm）</p><p>这些要被持久化（即写到磁盘）</p><p>一旦机器完成快照，在lastIncludeIndex之前的日志可以删除。</p><p>正常情况日志是单独进行快照的，但是如果某个机器的日志太老了，即下一条该发给他的已经被删除了，那么就发送InstallsnapshotRPC,这个情况下，follower删除整个日志然后用快照取代，如果重复收到，那么快照之前的可以删除，快照之后的是正常的需要保留。</p><p>做snapshot既不要做的太频繁，否则消耗磁盘带宽， 也不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。推荐当日志达到某个固定的大小做一次snapshot。</p><p>  做一次snapshot可能耗时过长，会影响正常日志同步。可以通过使用copy-on-write技术避免snapshot过程影响正常日志同步。</p><h1 id="与客户端交互"><a href="#与客户端交互" class="headerlink" title="与客户端交互"></a>与客户端交互</h1><p>客户端将请求发送到leader，然后他会随机选取server发起请求，如果对方不是leader，那么他会告知客户端leader，然后客户端去请求leader，如果leader宕机，那么就随机选择机器重试。</p><p>为了保持幂等性，就算客户端多次请求只会被执行一次。方法是客户端有一个独立的编号，命令有一个独立的编号，然后状态机记录客户端处理的最新的编号，如果接受到一个客户端的请求已经被执行了，直接返回不执行。</p><p>只读操作可能会导致返回脏数据，即（出现脑裂，旧leader在少数派中，多数派选出新leader同时写了新内容，此时客户端请求旧leader会返回脏数据），</p><p>使用两个方法避免，</p><p>1.leader必须知道已经提交的所有日志记录的最新信息。选举制度保证leader一定有所有已经提交的日志，但是任期刚刚开始它可能不知道哪些日志已经提交了，所以需要在当选的时候追加一条空日志到自己的日志中。</p><p>leader在处理只读任务（即Get)的时候需要知道自己这个leader是不是有效的（防止出现脑裂），在响应get的时候需要与半数以上的机器交换心跳信息。或者通过心跳值来提供租约（这样会使得安全依赖于时间）。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kmp算法，模板</title>
    <link href="/2021/04/27/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/27/%E7%AE%97%E6%B3%95/kmp%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在求next数组和求相似数组很相似，只是i的起始点要为1，一个为0</p><p><a href="https://leetcode-cn.com/problems/implement-strstr/solution/dai-ma-sui-xiang-lu-kmpsuan-fa-xiang-jie-mfbs/">可以参考leetcode链接</a></p><pre><code class="hljs reasonml">void get<span class="hljs-constructor">Next(List&lt;Integer&gt; <span class="hljs-params">next</span>,String <span class="hljs-params">s1</span>)</span>&#123;    <span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;s1.length<span class="hljs-literal">()</span>;i++)    &#123;        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span>&amp;&amp;(s1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>!=s1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>))            j=next.get(j-<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(s1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>==s1.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>)            j++;        next.set(i,j);    &#125;&#125;public <span class="hljs-built_in">int</span> str<span class="hljs-constructor">Str(String <span class="hljs-params">haystack</span>, String <span class="hljs-params">needle</span>)</span> &#123;    <span class="hljs-keyword">if</span>(needle.length<span class="hljs-literal">()</span>==<span class="hljs-number">0</span>)        return <span class="hljs-number">0</span>;    List&lt;Integer&gt; next=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>n<span class="hljs-constructor">Copies(<span class="hljs-params">needle</span>.<span class="hljs-params">length</span>()</span>,<span class="hljs-number">0</span>));    get<span class="hljs-constructor">Next(<span class="hljs-params">next</span>,<span class="hljs-params">needle</span>)</span>;    <span class="hljs-built_in">int</span> i,j=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;haystack.length<span class="hljs-literal">()</span>;i++)    &#123;        <span class="hljs-keyword">while</span>((j&gt;<span class="hljs-number">0</span>)&amp;&amp;(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>!=needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>))            j=next.get(j-<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>==needle.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">j</span>)</span>)            j++;        <span class="hljs-keyword">if</span>(j==needle.length<span class="hljs-literal">()</span>)            return i-j+<span class="hljs-number">1</span>;    &#125;    return -<span class="hljs-number">1</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>字符串算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>kmp</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马拉车算法</title>
    <link href="/2021/04/12/%E7%AE%97%E6%B3%95/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/12/%E7%AE%97%E6%B3%95/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>关键之处在于要利用镜像的信息，对于镜像已经知道的及时跳过。</p><p>然后还有一点就是扩充字符串#，然后两端加@！，这个时候我们如果得到最长回文串，那么怎么获得原始的最长回文串呢，是最右边的-中心得到最左边的位置，然后最左边的位置除2就是原始的起始值，这个很容易理解，因为是刚好扩充了两倍的，用#隔开的。</p><p>还有一点关键是更新的是每个点已经以他为中心扩充的字符串，dp数组记录的是长度</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;    public String longest<span class="hljs-constructor">Palindrome(String <span class="hljs-params">s</span>)</span>     &#123;        StringBuilder sb=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-string">&quot;!#&quot;</span>)</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length<span class="hljs-literal">()</span>;i++)        &#123;            sb.append(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>);            sb.append(<span class="hljs-string">&quot;#&quot;</span>);        &#125;        sb.append(<span class="hljs-string">&quot;@&quot;</span>);        <span class="hljs-built_in">int</span> dp<span class="hljs-literal">[]</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-identifier">sb</span>.<span class="hljs-identifier">length</span>()]</span>;        <span class="hljs-built_in">int</span> C=<span class="hljs-number">0</span>,R=<span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> maxlen=<span class="hljs-number">0</span>,center=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;sb.length<span class="hljs-literal">()</span>;i++)        &#123;            <span class="hljs-built_in">int</span> slen=<span class="hljs-number">1</span>;<span class="hljs-comment">//子串长度</span>            <span class="hljs-keyword">if</span>(i&lt;R)<span class="hljs-comment">//如果包含在内</span>            &#123;                <span class="hljs-built_in">int</span> mirror=<span class="hljs-number">2</span>*C-i;<span class="hljs-comment">//如果镜像没超过边界，那么直接赋值，否则还要验证</span>                dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(dp<span class="hljs-literal">[<span class="hljs-identifier">mirror</span>]</span>,R-i);<span class="hljs-comment">//直接取镜像的dp值和到边界距离的最小值</span>                slen=dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;            &#125;            <span class="hljs-keyword">while</span>((i-slen)&gt;=<span class="hljs-number">0</span>&amp;&amp;(i+slen)&lt;sb.length<span class="hljs-literal">()</span>&amp;&amp;(sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>-<span class="hljs-params">slen</span>)</span>==sb.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>+<span class="hljs-params">slen</span>)</span>))            &#123;                slen++;            &#125;            <span class="hljs-keyword">if</span>(i+slen-<span class="hljs-number">1</span>&gt;R)            &#123;                R=i+slen-<span class="hljs-number">1</span>;                C=i;            &#125;            dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>=slen-<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;maxlen)            &#123;                maxlen=dp<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;                center=i;            &#125;        &#125;        <span class="hljs-comment">// System.out.println(maxlen);</span>        return s.substring((center-maxlen)/<span class="hljs-number">2</span>,(center-maxlen)/<span class="hljs-number">2</span>+maxlen);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>字符串算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>马拉车算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146. LRU 缓存机制</title>
    <link href="/2021/03/29/%E7%AE%97%E6%B3%95/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/03/29/%E7%AE%97%E6%B3%95/146.%20LRU%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供 有序，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照插入的顺序，一种是按照读取的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;&lt;/span&gt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cap;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer, Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();  <span class="hljs-comment">// 保持插入顺序</span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LRUCache&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.cap = capacity;&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;get&lt;/span&gt;(key);        &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key);                   &lt;span class=&quot;hljs-comment&quot;&gt;// 保证每次查询后，都在末尾&lt;/span&gt;        &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value);        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.keySet().contains(key)) &amp;#123;        &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;(key);    &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;() == cap) &amp;#123;        Iterator&amp;lt;Map.E***y&amp;lt;Integer, Integer&amp;gt;&amp;gt; iterator = &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.e***ySet().iterator();        iterator.next();        iterator.&lt;span class=&quot;hljs-built_in&quot;&gt;remove&lt;/span&gt;();        &lt;span class=&quot;hljs-comment&quot;&gt;// int firstKey = map.e***ySet().iterator().next().getValue();&lt;/span&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// map.remove(firstKey);&lt;/span&gt;    &amp;#125;    &lt;span class=&quot;hljs-built_in&quot;&gt;map&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;put&lt;/span&gt;(key, value);&amp;#125;</code></pre><p>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>另外一个方法是采用双向链表，然后用hashmap存每个节点的key和地址。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs csharp"><br><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">myLinked</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-keyword">int</span> key;<br>        myLinked next;<br>        myLinked prev;<br>        myLinked()&#123;&#125;<br>        myLinked(<span class="hljs-keyword">int</span> _key,<span class="hljs-keyword">int</span> _value)&#123;key=_key;val=_value;&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">Integer</span>,<span class="hljs-title">myLinked</span>&gt; m&lt;/span&gt;=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> myLinked head,tail;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> capacity&lt;/span&gt;) &lt;/span&gt;<br><span class="hljs-function">&lt;/span&gt;    &#123;<br>        <span class="hljs-keyword">this</span>.size=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity=capacity;<br>        head=<span class="hljs-keyword">new</span> myLinked();<br>        tail=<span class="hljs-keyword">new</span> myLinked();<br>        head.next=tail;<br>        tail.next=head;<br>    &#125;</span></span></span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key&lt;/span&gt;)&lt;/span&gt; &amp;#123;    myLinked l=m.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(key);    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(l==&lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;)        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;    movetohead(l);    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; l.val;&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; key, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;</code></pre><p><span class="hljs-function">&lt;/span&gt;    &#123;<br>        myLinked l=m.<span class="hljs-keyword">get</span>(key);<br>        <span class="hljs-keyword">if</span>(l!=<span class="hljs-literal">null</span>)<br>        &#123;<br>            l.val=<span class="hljs-keyword">value</span>;<br>            movetohead(l);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            myLinked tmp=<span class="hljs-keyword">new</span> myLinked(key,<span class="hljs-keyword">value</span>);<br>            m.put(key,tmp);<br>            addtohead(tmp);<br>            ++size;<br>            <span class="hljs-keyword">if</span>(size&gt;capacity)<br>            &#123;<br>                myLinked tt=removetail();<br>                m.<span class="hljs-keyword">remove</span>(tt.key);<br>                size—;<br>            &#125;<br>        &#125;<br>    &#125;</span></p><pre><code>&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addtohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123;    node.prev = head;    node.next = head.next;    head.next.prev = node;    head.next = node;&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeNode&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123;    node.prev.next = node.next;    node.next.prev = node.prev;&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;movetohead&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;myLinked node&lt;/span&gt;)&lt;/span&gt; &amp;#123;    removeNode(node);    addtohead(node);&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; myLinked &lt;span class=&quot;hljs-title&quot;&gt;removetail&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;&lt;/span&gt;)&lt;/span&gt; &amp;#123;    myLinked res = tail.prev;    removeNode(res);    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&amp;#125;</code></pre><p>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>java</tag>
      
      <tag>源码解析</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5. 最长回文子串 和马拉车算法</title>
    <link href="/2021/02/19/%E7%AE%97%E6%B3%95/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/19/%E7%AE%97%E6%B3%95/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>主要是利用了回文串中的对称性质。将回文串分成两部分来看待，左边的已知结果，右边的未知，然后利用左边的信息，需要特殊讨论的情况就是左边回文串超出最左边的时候，超出中心并不需要讨论，因为超出中间的时候不会影响右边的结果，因为右边也只是超出中心，并没有超出最右边。算法效率很好。<br><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> longestPalindrome(<span class="hljs-keyword">String</span> s) &#123;    <span class="hljs-built_in">int</span> C=<span class="hljs-number">0</span>,R=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> len=s.length();    StringBuilder sbd=<span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;&quot;</span>);    sbd.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;!&quot;</span>);    sbd.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;#&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        sbd.<span class="hljs-built_in">append</span>(s.charAt(i));        sbd.<span class="hljs-built_in">append</span>(<span class="hljs-string">&#x27;#&#x27;</span>);    &#125;    sbd.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;?&quot;</span>);    <span class="hljs-built_in">int</span> n=sbd.length();    <span class="hljs-built_in">int</span> a[]=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-built_in">int</span> mirror=<span class="hljs-number">2</span>*C-i;        <span class="hljs-keyword">if</span>(i&lt;R)        &#123;            a[i]=Math.<span class="hljs-built_in">min</span>(a[mirror&lt;<span class="hljs-number">0</span>?C:mirror],R-i);            a[i]=Math.<span class="hljs-built_in">min</span>(a[i],i-C);        &#125;        <span class="hljs-keyword">else</span>        &#123;            a[i]=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">while</span>(sbd.charAt(i-a[i]<span class="hljs-number">-1</span>)==sbd.charAt(i+a[i]+<span class="hljs-number">1</span>))        &#123;            a[i]++;        &#125;        <span class="hljs-keyword">if</span>(i+a[i]&gt;R)        &#123;            R=i+a[i];            C=i;        &#125;        <span class="hljs-comment">// System.out.println(a[i]);</span>    &#125;    <span class="hljs-built_in">int</span> maxlen=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> center=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;n<span class="hljs-number">-1</span>;i++)    &#123;        <span class="hljs-keyword">if</span>(a[i]&gt;maxlen)        &#123;            maxlen=a[i];            center=i;        &#125;    &#125;    <span class="hljs-keyword">String</span> res=sbd.substring(center-maxlen,center+maxlen);    <span class="hljs-built_in">int</span> reslen=res.length();    StringBuilder s1=<span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;reslen;i+=<span class="hljs-number">2</span>)    &#123;        s1.<span class="hljs-built_in">append</span>(res.charAt(i));    &#125;    <span class="hljs-keyword">return</span> s1.toString();&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>字符串算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>马拉车算法</tag>
      
      <tag>leettcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>327. 区间和的个数（树状数组+前缀和+离散化）</title>
    <link href="/2021/01/23/%E7%AE%97%E6%B3%95/327.%20%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/01/23/%E7%AE%97%E6%B3%95/327.%20%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>依然考虑前缀和数组 \textit{preSum}preSum。</p><p>对于每个下标 jj，以 jj 为右端点的下标对的数量，就等于数组 \textit{preSum}[0..j-1]preSum[0..j−1] 中的所有整数，出现在区间 [\textit{preSum}[j]-\textit{upper}, \textit{preSum}[j]-\textit{lower}][preSum[j]−upper,preSum[j]−lower] 的次数。</p><p>区间和的问题比较适合用线段树和树状数组</p><p>很多人都把constexpr和const相比较。</p><p>其实，const并不能代表“常量”，它仅仅是对变量的一个修饰，告诉编译器这个变量只能被初始化，且不能被直接修改（实际上可以通过堆栈溢出等方式修改）。而这个变量的值，可以在运行时也可以在编译时指定。</p><p>constexpr可以用来修饰变量、函数、构造函数。一旦以上任何元素被constexpr修饰，那么等于说是告诉编译器 “请大胆地将我看成编译时就能得出常量值的表达式去优化我”。</p><p><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组可以参考</a><br><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BIT</span></span><span class="hljs-class">    &#123;</span>        <span class="hljs-keyword">private</span>:            <span class="hljs-keyword">int</span> n;            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;        <span class="hljs-keyword">public</span>:            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowerbit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function">            </span>&#123;                <span class="hljs-keyword">return</span> i&amp;(-i);            &#125;            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span><span class="hljs-comment">//求A[1 - i]的和</span></span><span class="hljs-function">            </span>&#123;                <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span>(i)                &#123;                    res+=arr[i];                    i-=lowerbit(i);                &#125;                <span class="hljs-keyword">return</span> res;            &#125;            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> x)</span><span class="hljs-comment">//在i位置加上k</span></span><span class="hljs-function">            </span>&#123;                <span class="hljs-keyword">while</span>(i&lt;=n)<span class="hljs-comment">//树状数组是从1开始的，所以需要有等号</span>                &#123;                    arr[i]+=x;                    i+=lowerbit(i);                &#125;            &#125;            BIT(<span class="hljs-keyword">int</span> _n): n(_n),arr(_n+<span class="hljs-number">1</span>)&#123;&#125;    &#125;;    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRangeSum</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> lower, <span class="hljs-keyword">int</span> upper)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> len=nums.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">vector</span>&lt;ll&gt; presum=&#123;<span class="hljs-number">0</span>&#125;;        ll sum=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            sum+=nums[i];            presum.push_back(sum);        &#125;        <span class="hljs-built_in">set</span>&lt;ll&gt; se;        <span class="hljs-keyword">for</span>(ll p: presum)        &#123;            se.insert(p);            se.insert(p-upper);            se.insert(p-lower);        &#125;        <span class="hljs-built_in">unordered_map</span>&lt;ll,<span class="hljs-keyword">int</span>&gt; m;        <span class="hljs-keyword">int</span> index=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(ll p: se)        &#123;            m[p]=index;            index++;        &#125;        <span class="hljs-keyword">int</span> result=<span class="hljs-number">0</span>;        <span class="hljs-function">BIT <span class="hljs-title">tree</span><span class="hljs-params">(m.<span class="hljs-built_in">size</span>())</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;presum.<span class="hljs-built_in">size</span>();i++)        &#123;            <span class="hljs-keyword">int</span> left=m[presum[i]-upper];            <span class="hljs-keyword">int</span> right=m[presum[i]-lower];            result+=tree.query(right+<span class="hljs-number">1</span>)-tree.query(left);<span class="hljs-comment">//这里有点迷惑，不懂为什么这样弄</span>            tree.add(m[presum[i]]+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>c++</tag>
      
      <tag>树状数组</tag>
      
      <tag>离散化</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1584. 连接所有点的最小费用（最小生成树Prime）</title>
    <link href="/2021/01/22/%E7%AE%97%E6%B3%95/1584.%20%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/"/>
    <url>/2021/01/22/%E7%AE%97%E6%B3%95/1584.%20%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>朴素版Prim O(n^2)</p><p>适用于稠密图</p><p>稀疏图的 最小生成树</p><p>这个是prim的情况</p><p>学习STL，发现STL默认都是使用()比较的，默认比较使用less（即’&lt;’运算符），如sort(a,a+n)，默认将数组按照递增的顺序来排序（前面的元素&lt;后面的嘛），但是优先队列的源码比较奇特，虽然按道理使用less比较应该默认是小根堆（即堆顶元素最小），但是priority_queue&lt;&gt;默认是大根堆的，这是因为优先队列队首指向最后，队尾指向最前面的缘故！每次入队元素进去经排序调整后，优先级最大的元素排在最前面，也就是队尾指向的位置，这时候队首指向优先级最小的元素！所以虽然使用less但其实相当于greater，我们重载运算符的时候比较函数里面写&gt;就相当于&lt;排序方式，这点需要花点时间想想，再来说一说优先队列的这个类型，其实有三个参数：priority_queue<class type,class container,class compare>，即类型，容器和比较器，后两个参数可以缺省，这样默认的容器就是vector，比较方法是less，也就是默认大根堆，可以自定义写比较方法，但此时若有比较方法参数，则容器参数不可省略！priority_queue&lt;&gt;的可支持的容器必须是用数组实现的容器，如vector，deque，但不能是list（推荐vector），比较方法可以写结构体重载()运算符，也可以用less，greater这些语言实现了的，但是灵活性不够，建议手写重载结构体，或者——如果不想写比较结构体的话，就将后面的两个参数缺省，直接重载类型的&lt;运算符，所以这里写的时候要注意优先队列和其他容器比较器的区别。</class></p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> a[<span class="hljs-number">1002</span>][<span class="hljs-number">1002</span>];<span class="hljs-built_in">int</span> sta[<span class="hljs-number">1002</span>];    struct node    &#123;        <span class="hljs-built_in">int</span> weight,p1,p2;    &#125;;    struct cmp    &#123;        <span class="hljs-built_in">bool</span> operator()(node a,node b) &#123; <span class="hljs-keyword">return</span>  a.weight &gt; b.weight; &#125;    &#125;;    <span class="hljs-built_in">int</span> minCostConnectPoints(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; points)     &#123;        <span class="hljs-built_in">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;        <span class="hljs-built_in">int</span> len=points.size();        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; dist(len+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">int</span>&gt;(len+<span class="hljs-number">1</span>,INF));        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;points.size();i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;points.size();j++)            &#123;                dist[j][i]=dist[i][j]=abs(points[i][<span class="hljs-number">0</span>]-points[j][<span class="hljs-number">0</span>])+abs(points[i][<span class="hljs-number">1</span>]-points[j][<span class="hljs-number">1</span>]);            &#125;        &#125;        vector&lt;<span class="hljs-built_in">int</span>&gt; po;        po.push_back(<span class="hljs-number">0</span>);        sta[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;        <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;        priority_queue &lt;node,vector&lt;node&gt;,cmp&gt; qu;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)        &#123;            node tt = &#123;weight:dist[<span class="hljs-number">0</span>][i], p1:<span class="hljs-number">0</span>,p2:i&#125;;            qu.push(tt);        &#125;        <span class="hljs-keyword">while</span>(po.size()&lt;len)        &#123;            <span class="hljs-keyword">while</span>(!qu.empty())            &#123;                node tmp1=qu.top();                <span class="hljs-keyword">if</span>(sta[tmp1.p2]==<span class="hljs-number">1</span>&amp;&amp;sta[tmp1.p1]==<span class="hljs-number">1</span>)                &#123;                    qu.pop();                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">else</span>                    <span class="hljs-keyword">break</span>;            &#125;            node tmp=qu.top();            <span class="hljs-comment">// cout&lt;&lt;tmp.p1&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;endl;</span>            qu.pop();            sta[tmp.p2]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)            &#123;                <span class="hljs-keyword">if</span>(sta[i]==<span class="hljs-number">1</span>||i==tmp.p2)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// cout&lt;&lt;dist[tmp.p2][i]&lt;&lt;&quot; &quot;&lt;&lt;tmp.p2&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span>                node tt = &#123;weight:dist[tmp.p2][i], p1:tmp.p2,p2:i&#125;;                qu.push(tt);            &#125;              result+=tmp.weight;            po.push_back(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
      <tag>最小生成树</tag>
      
      <tag>prim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>能谱CT物理原理</title>
    <link href="/2021/01/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E8%83%BD%E8%B0%B1CT%E7%89%A9%E7%90%86%E5%8E%9F%E7%90%86/"/>
    <url>/2021/01/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E8%83%BD%E8%B0%B1CT%E7%89%A9%E7%90%86%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>CNR = contrast-to-noise ratio, EID = energy-integrating detector, PCD<br>= photon-counting detector</p><p>相对于传统的能量集成探测器CT，光子计数CT将允许减少辐射剂量，提高空间分辨率，纠正光束硬化伪影，并使用替代对比剂，同时为定量成像创造机会。</p><p>EID CT， x光打到一个吸收层上，吸收层吸收x射线光子，然后转化为可见光光子，可见光光子被一个由半导体材料制成的光电二极管吸收，光电二极管测量入射光的数量，并产生一个电信号，该电信号与在测量期间沉积的总能量成比例，而不是单个x射线光子的能量。</p><p>光子计数探测器(PCDs)，另一方面，不需要一个单独的层来转换x射线到光，但由一个单一的厚层半导体二极管(1.6-30毫米取决于材料)，在上面施加一个大的电压。如果入射的x射线被半导体吸收，它就会产生一团正负电荷(6)，迅速地彼此分离。移动的电荷在连接在电极上的电线上产生一个电脉冲，并被电子读出电路记录下来。因此，pcd直接将单个x射线光子转换成电信号，不像当前CT中使用的EIDs，需要额外的步骤将光子转换成可见光。</p><p>每一个光子撞击探测器元件，都会产生一个电脉冲，其高度与光子储存的能量成正比。探测器的电子系统计算高度超过预设阈值水平的脉冲的数目。阈值设置在高于电子噪声水平但低于入射光子产生的脉冲水平。此外，通过将每个脉冲与几个阈值水平进行比较，探测器可以根据光子的能量将入射光子分类成若干个能量箱(通常为2到8个)(图3)。因此，电子噪声有效地排除在光子和/或脉冲计数之外，所以一次射线可以产生很多个能谱段。</p><p>PCD计数器暂时没有商业应用。<br>使用特定能量测量和能量阈值来拒绝电子噪声。促进新的成像方法，如k-边缘减法<br>原因：<br>造成性能下降的影响取决于探测器中使用的传感器材料的类型。PCDs的研究主要集中在碲化镉、碲化镉锌和硅(6)</p><p>康普顿效应</p><p>在理想PCD中，光子只在它所撞击的探测器元件中产生信号。在现实中，有几个物理效应可能导致单个光子在多个探测器元素中被登记为计数事件。在硅探测器中，很大一部分光子在探测器材料中通过康普顿散射相互作用，将一小部分能量沉积在探测器元素中。然后，散射光子就会向一个新的、随机的方向移动，可能会把剩余的能量储存在另一个探测器元素中，对于碲化镉和碲化镉锌，康普顿散射概率较低。然而，在原始相互作用中沉积的部分能量可能会以荧光x射线的形式释放，它可以被邻近的探测器元素吸收，如图4,a(8,9)所示。尽管康普顿散射和x射线荧光是不同的物理效应，但它们都导致光子的能量范围不正确，并且可能被多次计算。</p><p>电荷共享效应</p><p>在硅和镉碲化或镉锌碲化探测器中，探测器元件之间的串扰也可以归因于一种称为电荷共享的效应。如图4,B所示，每个被吸收的x射线光子都会在传感器材料中产生大量的正负电荷。如果光子在两个探测器元件之间的边界附近被吸收，电荷云的一部分可能会延伸到相邻的探测器元件，这可以记录光子能量的一部分。结果是光子被计数两次。</p><p>各种各样的串扰在不同的方面降低了图像质量。首先，它们会降低空间分辨率(即模糊图像)，因为它们会导致光子被记录在错误的探测器元件中。其次，它们可能会导致光子被多次计数。这降低了图像的对比度-噪声比(CNR)，因为所有在计数光子数量中引入额外随机性的影响都会产生额外的图像噪声。第三，不同形式的串扰降低了探测器的能量分辨率，降低了能量信息的可靠性，并导致材料选择性图像中的图像噪声增加。</p><p>堆积效应</p><p>需要一个快速探测器来计数单个光子。每平方毫米每秒有几亿光子撞击探测器，因此传感器材料必须能够快速传输释放的电荷，读出电子必须能够足够快地计算产生的脉冲。对足够快速和稳定的探测器的需求是光子计数CT扫描仪最近才开始用于临床CT剂量水平的原因之一(13)。然而，PCDs广泛应用于PET、SPECT和双能量x线吸收仪，并已被引入一种商业乳房x线成像系统(微剂量;Philips Healthcare, Best，荷兰)，那里的计数率要低得多。如果光子到达得太快，一些由此产生的电脉冲会相互叠加，这种现象被称为脉冲堆积</p><p>如果两个连续脉冲几乎同时发生，它们将被记录为一个能量等于两个入射光子能量之和的单个脉冲。如果脉冲到达时间的差异稍微大一些，探测器可能会将它们记录为两个单独的计数，但部分重叠仍然会导致测量光子能量的误差(图5,B)。堆积对图像质量有两种影响。首先，计数损失增加了图像噪声，因为较少的光子有助于测量(14)。第二，能量分辨率下降，类似于相声(14-16)的效果。因为在高计数率下会发生堆积，所以它不会降低图像的所有部分<br>这些影响可以通过设计更小的探测器元件和更快的计数器来最小化。然而，当探测器元件变得更小时，在堆积和电荷共享之间有一个折衷。</p><p>由于具有不同能量的光子的加权方式，理想PCD可以产生比理想EID更低的图像噪声。由于EID测量的是吸收的总x射线能量，高能光子对总信号的贡献相对于低能量光子。然而，这种加权并不能产生最佳的CNR，因为在高能量时组织对比度较低。为了优化图像的CNR，可以将最大的权重分配给能量较低、组织间对比度最高的光子，如图7所示。能量分解PCD能够为低能量箱分配更高的权重因子，从而提高CNR(4,18,19)。给予低能量光子更高重量的一个缺点是，由于x射线光谱中低能量部分的组织衰减更加非均匀，因此会导致光束硬化现象的增加(20)</p><p>在x射线计算机断层扫描(CT)中，具有不同元素组成的材料可以用CT图像上的相同像素值(即CT数)表示，这取决于材料的质量密度</p><p>在双能量CT中，以第二能量获得额外的衰减测量，允许两种材料的区分，这个双能CT，就是加两个能量kev，和能谱CT划分能量箱有所不同。</p><p>双能量CT的技术途径</p><p>Two Temporally Sequential Scans 两个时间顺序扫描,进行了两次时间顺序扫描，以获取两个管电位处的数据,由于数据不是同时获得的，患者在两次扫描之间发生的运动导致结果图像和材料组成信息的严重退化,后面有一种单轴旋转改进的方法，但是效果应该也不是很好，然后我也没太看懂，尴尬。这个方法可以在任何CT扫描仪上执行(不需要特殊硬件</p><p>Rapid Switching of X-Ray Tube Potential x射线管电位的快速切换，允许在低和高管电位下获得交替投影测量，应用主要是骨骼密度测量。然而，在低管电位测量中，管电流不能迅速增加到足够快的程度，从而在低管电位和高管电位数据集中都能达到相当的噪声水平。这种噪音上的差异限制了该技术在骨密度测量之外的应用<br>在连续视图之间切换管电位要求从低到高管电位的转换时间小于一毫秒。此外，过渡必须尽可能突然，以最大限度地分离测量数据的能量，尽管快速调制x射线管电流的困难可能在低能量数据中造成高噪音水平或来自高能量投影的过量剂量。然而，这个问题可以通过对低和高能量投影使用不对称采样来解决。通过这种方式，在不迅速改变管电流的情况下，获得了低能量投影所需的增加管电流-时间积<br>低能量和高能量数据集的近同时数据采集。允许通过使用投影数据或重建图像来实现双能量物质分解算法。减少计算出的“虚拟单能量”图像中的光束硬化现象，需要专门的硬件。能量谱的高重叠</p><p>Multilayer Detector 多层探测器<br>就是探测头有两层，里层的获得低能量的信息，外层的获得高能量的信息。<br>低能耗数据收集从前面或内层的探测器层和高能数据收集从后面或外层探测器层(图5)。这类似于多层探测器的使用双能x线摄影(6 - 8)。为了在低和高能量图像中获得相同的噪声，使用了不同的探测器厚度。<br>低能量数据集和高能量数据集的同时数据采集。所有图像数据都以支持特定材料成像的方式获取，但是需要专门的硬件。能量谱的高重叠。低和高能量图像的噪声水平可能不同</p><p>Dual x-ray sources<br>双x射线源<br>双源CT是将两个x射线源和两个数据采集系统安装在同一架龙门上，相互垂直放置的CT系统<br>因为两个管同时被激发，原始主光子来自一个管的散射辐射可能被另一个管的探测器探测到，反之亦然。这将降低光谱分离，并要求实现适当的散射校正算法(12)。双源方法的一个优点是能够独立优化每个管-探测器对的光谱过滤，从而增加在特定物质图像中光谱分离和增加信噪比<br>管电流和管过滤可以分别优化每个管电位。相对较低的光谱重叠程度，这提高了材料特定图像的对比噪声比。光束硬化校正应用于图像重建之前，允许在图像域中创建特定材料的图像。<br>需要专门的硬件。在低能和高能数据之间有90度的相移。同时使用这两种x射线源允许散射辐射，其原始的主光子来自一个管被另一个管的探测器检测到，需要专门的散射校正。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像</tag>
      
      <tag>物理原理</tag>
      
      <tag>能谱CT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>匈牙利算法（二分图）</title>
    <link href="/2021/01/16/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE_%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <url>/2021/01/16/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE_%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>匹配：在图论中，一个匹配（matching）是指一个边的集合，其中任意两条边都没有公共顶点。</p><p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配</p><p>完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突），但并非每个图都存在完美匹配。</p><p>交替路径：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径称为交替路径。</p><p>增广路径：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。</p><p>增广路径性质：<br>    （1）P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。<br>    （2）P经过取反操作可以得到一个更大的匹配M’。<br>    （3）M为G的最大匹配当且仅当不存在相对于M的增广路径。</p><p>匈牙利算法：利用增广路径求二分图的最大匹配算法称作匈牙利算法。（匈牙利数学家Edmonds于1965年提出）。<br>基本思想：通过寻找增广路径，把增广路径中的匹配边和非匹配边的相互交换，这样就会多出一条匹配边，直到找不到增广路径为止。</p><p>就是每次从一个未匹配点出发，然后依次经过非匹配边、匹配边、非匹配边，并且途径另一个未匹配点，然后匹配边和非匹配边的相互交换，这样就会多出一个匹配边，直到找不到增广路径。</p><p>这是leetcode<br>LCP 04. 覆盖<br>你有一块棋盘，棋盘上有一些格子已经坏掉了。你还有无穷块大小为1 * 2的多米诺骨牌，你想把这些骨牌不重叠地覆盖在完好的格子上，请找出你最多能在棋盘上放多少块骨牌？这些骨牌可以横着或者竖着放。</p><p>输入：n, m代表棋盘的大小；broken是一个b * 2的二维数组，其中每个元素代表棋盘上每一个坏掉的格子的位置。</p><p>输出：一个整数，代表最多能在棋盘上放的骨牌数。</p><p>该题看上去与二分图匹配无关，但其实可以转化成二分图匹配。一个骨牌恰好覆盖两格，而这两格必须是相邻的。因此如果把相邻的两格看成分别属于X、Y两个集合的节点，相邻的节点之间认为有一条（黑色）边相连，放骨牌看做将被覆盖的两格之间的边染成红色；由于一格（一个节点）只能被一个骨牌覆盖（被一条红边连接），那么连接的方式整个就是二分图的一个匹配。如何构建这张图呢？由于相邻的点属于不同的集合，因此仿照国际象棋的棋盘“间隔地”染色就好了。于是，相邻格子之间对应的边连接的都是属于不同集合的节点，相同集合的节点因为对应的不是相邻格子都不直接相连，形成了二分图。最后，能放置骨牌的最大数量就是二分图最大匹配中的边数。</p><p>二分图最大匹配可以用匈牙利算法解决，也可以转化成最大流解决，本次使用前者。匈牙利算法的核心操作其实与后者还挺像，后者是寻找增流路径，而前者是寻找一个“交互道路”（节点颜色交替的道路），其实都可以理解为增广道路（augmentation path）。只不过，由于在二分图匹配中一条边要么就是选要么就是不选，相当于是特殊的“流”，0或者1，因此最大流的“退流”操作，被简化为了异或操作。无论是从算</p><p>示例 1：</p><p>输入：n = 2, m = 3, broken = [[1, 0], [1, 1]]<br>输出：2<br>解释：我们最多可以放两块骨牌：[[0, 0], [0, 1]]以及[[0, 2], [1, 2]]。（见下图）<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">int</span> row=<span class="hljs-number">0</span>,col=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> grid[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">int</span> erge[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">int</span> matchvi[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">int</span> belong[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">int</span> domino(<span class="hljs-built_in">int</span> n, <span class="hljs-built_in">int</span> m, vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; broken)<br>    &#123;<br>        row=n,col=m;<br>        <span class="hljs-built_in">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> g: broken)<br>        &#123;<br>            grid[g[<span class="hljs-number">0</span>]][g[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;row;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;col;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j])<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)<span class="hljs-comment">//构造边</span><br>                &#123;<br>                    <span class="hljs-built_in">int</span> arow=a[k][<span class="hljs-number">0</span>]+i,acol=a[k][<span class="hljs-number">1</span>]+j;<br>                    <span class="hljs-keyword">if</span>(arow&lt;<span class="hljs-number">0</span>||arow&gt;=row||acol&lt;<span class="hljs-number">0</span>||acol&gt;=col||grid[arow][acol])<br>                        <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-comment">// cout&lt;&lt;1;</span><br>                    erge[i<em>col+j][arow</em>col+acol]=erge[arow<em>col+acol][i</em>col+j]=<span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hug();<br>    &#125;<br>    <span class="hljs-built_in">int</span> hug()<br>    &#123;</code></pre></p><pre><code>    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; res=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++)    &amp;#123;        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col;        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(grid[tmp1][tmp2])            &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//为偶数格子跳过，对奇数找匹配&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;        memset(matchvi, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, sizeof(matchvi));        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(match(i))            res++;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; res;&amp;#125;&lt;span class=&quot;hljs-built_in&quot;&gt;bool&lt;/span&gt; match(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; x)&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;row*col;i++)    &amp;#123;        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp1=i/col;        &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; tmp2=i%col;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(((tmp1+tmp2)&amp;amp;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))&lt;span class=&quot;hljs-comment&quot;&gt;//如果是偶数跳过&lt;/span&gt;            &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;((erge[x][i]==&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&amp;amp;&amp;amp;(matchvi[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;))        &amp;#123;            matchvi[i]=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(belong[i]==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;||match(belong[i]))            &amp;#123;&lt;span class=&quot;hljs-comment&quot;&gt;//如果i没有确定，或者确定的人可以换&lt;/span&gt;                belong[i]=x;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;            &amp;#125;        &amp;#125;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&amp;#125;</code></pre><p>&#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>c++</tag>
      
      <tag>匈牙利算法</tag>
      
      <tag>二分图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>785. 判断二分图（染色法）</title>
    <link href="/2021/01/14/%E7%AE%97%E6%B3%95/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <url>/2021/01/14/%E7%AE%97%E6%B3%95/785.%20%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>一个图是二分图，当且仅当图中不含有奇数环<br>二分图的方法，染色法，就是通过对节点进行着色，算法就是深搜的方法</p><pre><code class="hljs arduino"><span class="hljs-keyword">bool</span> res=<span class="hljs-literal">true</span>;<span class="hljs-keyword">int</span> sta[<span class="hljs-number">105</span>];<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;graph.<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(sta[i]==<span class="hljs-number">0</span>)            paint(i,<span class="hljs-number">1</span>,graph);    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">paint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t,<span class="hljs-keyword">int</span> color,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; g)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(res==<span class="hljs-literal">false</span>)        <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;g[t].<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(sta[g[t][i]]==<span class="hljs-number">0</span>)        &#123;            sta[g[t][i]]=-color;            paint(g[t][i],-color,g);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sta[g[t][i]]==-color)            <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">else</span>        &#123;            res=<span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span> ;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>c++</tag>
      
      <tag>二分图</tag>
      
      <tag>染色法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>787. K 站中转内最便宜的航班（bellman-ford）</title>
    <link href="/2021/01/13/%E7%AE%97%E6%B3%95/787.%20K%20%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/"/>
    <url>/2021/01/13/%E7%AE%97%E6%B3%95/787.%20K%20%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD/</url>
    
    <content type="html"><![CDATA[<p>循环n次<br>遍历所有边u-&gt;v,权w (松弛操作)<br>dist[v]=min(dist[v], dist[u]+w)</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>处理有负权边的图<br>循环次数的含义：循环K次后，表示不超过K条边的最短距离<br>有边数限制的最短路，只能用Bellman-Ford算法，不能用spfa算法<br>如果有负权回路，最短路不一定存在 -</p><p>Bellman-Ford算法可以求出是否有负环<br>第n循环后，还有更新，说明路径上有n+1个点，也就是存在环，还有更新，说明环是负环<br>循环n次后, 所有的边u-&gt;v,权w满足三角不等式:dist[v]&lt;=dist[u]+w<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> findCheapestPrice(<span class="hljs-built_in">int</span> n, vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; flights, <span class="hljs-built_in">int</span> src, <span class="hljs-built_in">int</span> dst, <span class="hljs-built_in">int</span> K) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; res(n+<span class="hljs-number">1</span>,INF);    res[src]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;=K;i++)    &#123;        vector&lt;<span class="hljs-built_in">int</span>&gt; tmp(res);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;flights.size();j++)        &#123;            <span class="hljs-keyword">if</span>(flights[j][<span class="hljs-number">2</span>]+tmp[flights[j][<span class="hljs-number">0</span>]]&lt;res[flights[j][<span class="hljs-number">1</span>]])                res[flights[j][<span class="hljs-number">1</span>]]=flights[j][<span class="hljs-number">2</span>]+tmp[flights[j][<span class="hljs-number">0</span>]];        &#125;    &#125;    <span class="hljs-keyword">if</span>(res[dst]==INF)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> res[dst];&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
      <tag>ford算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>743. 网络延迟时间（迪杰斯特拉+SPFA+floyd)</title>
    <link href="/2021/01/13/%E7%AE%97%E6%B3%95/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/"/>
    <url>/2021/01/13/%E7%AE%97%E6%B3%95/743.%20%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>有 N 个网络节点，标记为 1 到 N。</p><p>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。</p><p>现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。</p><p>输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2<br>输出：2</p><p>主要就是迪杰斯特拉的代码<br>这个是没有优化的结果，每次选的是距离初始点最小距离的点。<br>集合S：当前已经确定最短距离的点</p><p>dist[1] = 0, dist[i] = 正无穷<br>for v: 1 ~ n<br>t &lt;- 不在s中的距离最近的点<br>s &lt;- t<br>用t更新其他点的距离<br>朴素的Dijkstra算法往往是稠密图，用邻接矩阵来存储<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> networkDelayTime(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; times, <span class="hljs-built_in">int</span> N, <span class="hljs-built_in">int</span> K)     &#123;        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; mat(N+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">int</span>&gt;(N+<span class="hljs-number">1</span>,<span class="hljs-number">0x3f3f3f3f</span>));        vector&lt;<span class="hljs-built_in">int</span>&gt; res(N+<span class="hljs-number">1</span>,<span class="hljs-number">0x3f3f3f3f</span>);        vector&lt;<span class="hljs-built_in">int</span>&gt; sta(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//值为1点被被选，为0没被选</span>        <span class="hljs-built_in">int</span> result=<span class="hljs-number">-1</span>;        sta[K]=<span class="hljs-number">1</span>;        res[K]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;times.size();i++)        &#123;            mat[times[i][<span class="hljs-number">0</span>]][times[i][<span class="hljs-number">1</span>]]=times[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span>(times[i][<span class="hljs-number">0</span>]==K)            &#123;                res[times[i][<span class="hljs-number">1</span>]]=times[i][<span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-comment">// cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;N<span class="hljs-number">-1</span>;i++)        &#123;            <span class="hljs-built_in">int</span> t=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=N;j++)            &#123;                <span class="hljs-keyword">if</span>(sta[j]==<span class="hljs-number">0</span>&amp;&amp;(t==<span class="hljs-number">-1</span>||res[j]&lt;res[t]))                &#123;                    t=j;                &#125;            &#125;            sta[t]=<span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=N;j++)            &#123;                <span class="hljs-keyword">if</span>(res[t]+mat[t][j]&lt;res[j])                &#123;                    res[j]=res[t]+mat[t][j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)        &#123;            <span class="hljs-keyword">if</span>(res[i]==<span class="hljs-number">0x3f3f3f3f</span>)                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>(i==K)                <span class="hljs-keyword">continue</span>;            result=max(result,res[i]);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></p><p>集合S：当前已经确定最短距离的点</p><p>dist[1] = 0, dist[i] = 正无穷<br>for v: 1 ~ n<br>t &lt;- 不在s中的 与起始点距离最近的点 ；小顶堆维护 O(logN)<br>s &lt;- t; O(1)<br>用t更新其他点的距离 ; O(mlogN)<br>稀疏图用堆优化版的Dijkstra算法<br>这个是优化之后的，主要是用稀疏图替换邻接矩阵，同时用优先队列替换遍历搜寻最小的边。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> networkDelayTime(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; times, <span class="hljs-built_in">int</span> N, <span class="hljs-built_in">int</span> K) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; stat(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    vector&lt;<span class="hljs-built_in">int</span>&gt; res(N+<span class="hljs-number">1</span>,INF);    vector&lt;vector&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;&gt; m(N+<span class="hljs-number">1</span>);    priority_queue&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;&gt; queue;    queue.push(&#123;<span class="hljs-number">0</span>,K&#125;);    res[K]=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;times.size();i++)    &#123;        m[times[i][<span class="hljs-number">0</span>]].push_back(&#123;times[i][<span class="hljs-number">2</span>],times[i][<span class="hljs-number">1</span>]&#125;);    &#125;    <span class="hljs-keyword">while</span>(!queue.empty())    &#123;        <span class="hljs-built_in">auto</span> tmp=queue.top();        queue.pop();        <span class="hljs-keyword">if</span>(stat[tmp.second]==<span class="hljs-number">1</span>)            <span class="hljs-keyword">continue</span>;        stat[tmp.second]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> &amp;p: m[tmp.second])        &#123;            <span class="hljs-keyword">if</span>(p.first+tmp.first&lt;res[p.second])<span class="hljs-comment">//tmp代表我们找到的下一个加入的点，然后找这个点的所有的边来更新</span>            &#123;                res[p.second]=p.first+tmp.first;                queue.push(&#123;p.first+tmp.first,p.second&#125;);            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)    &#123;        <span class="hljs-keyword">if</span>(res[i]==INF)            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(i==K)            <span class="hljs-keyword">continue</span>;        result=max(result,res[i]);    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>SPFA算法</p><p>首先相比Dijkstra算法，SPFA可以处理带有负权变的图。<br>（个人认为原因是SPFA在进行松弛操作时就是那个更新距离的地方可以对某一条边重复进行松弛，因为可能某一个点会被多次加入队列，这个可以这么理解，如果在没有负边的情况下松弛一次就是说一条最短路径最多只能经过松弛的这个点一次，这个在没有负边的情况下是显而易见的，当有负边的情况下，经过这个点多次就可能获得更小的最短路径。当我们松弛了某个点超过N次，就可以认为出现了负环，为什么是超过N次呢，极端情况下如果没有负环那么每次加入一次点我们都可以认为这个点与其他点连成的一条边加入最短路径中，如果加了N-1条边还不是最短路径，到第n次那肯定就是有负环了。（大家都写的大于N次），我个人交代码试了以下，好像到n就可以了，但是保险还是大于N更好）</p><p>实现方法：</p><p>　　建立一个队列，初始时队列里只有起始点，再建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点作为起始点去刷新到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。</p><p>判断有无负环：<br>　　如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图，但是可以判断是否出现负权环）,这一点和ford算法是一样的，超过N次松弛就代表出现的最短路径长度是大于等于N的，这样的简单路径是不存在的。</p><p>我们可以看出代码上其实是和迪杰斯特拉算法很像的。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript">    <span class="hljs-built_in">int</span> networkDelayTime(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; times, <span class="hljs-built_in">int</span> N, <span class="hljs-built_in">int</span> K)<br>    &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> INF=<span class="hljs-number">0x3f3f3f3f</span>;<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; stat(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        vector&lt;<span class="hljs-built_in">int</span>&gt; res(N+<span class="hljs-number">1</span>,INF);<br>        vector&lt;vector&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;&gt; m(N+<span class="hljs-number">1</span>);<span class="hljs-comment">//距离队列</span><br>        priority_queue&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;,vector&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt;&gt; queue;<span class="hljs-comment">//刷新队列</span><br>        queue.push(&#123;<span class="hljs-number">0</span>,K&#125;);<br>        res[K]=<span class="hljs-number">0</span>;<br>        stat[K]=<span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;times.size();i++)<br>        &#123;<br>            m[times[i][<span class="hljs-number">0</span>]].push_back(&#123;times[i][<span class="hljs-number">2</span>],times[i][<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!queue.empty())<br>        &#123;<br>            <span class="hljs-built_in">auto</span> tmp=queue.top();<br>            queue.pop();<br>            stat[K]=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// if(stat[tmp.second]==1)</span><br>            <span class="hljs-comment">//     continue;</span><br>            <span class="hljs-comment">// stat[tmp.second]=1;</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span> &amp;p: m[tmp.second])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p.first+tmp.first&lt;res[p.second])<span class="hljs-comment">//first 距离，second 目的点</span><br>                &#123;<br>                    res[p.second]=p.first+tmp.first;<br>                    <span class="hljs-keyword">if</span>(stat[K]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        queue.push(&#123;p.first+tmp.first,p.second&#125;);<br>                        stat[p.second]=<span class="hljs-number">1</span>;<br>                    &#125;</code></pre></p><pre><code>            &amp;#125;        &amp;#125;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=N;i++)    &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(res[i]==INF)            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==K)            &lt;span class=&quot;hljs-keyword&quot;&gt;continue&lt;/span&gt;;        result=max(result,res[i]);    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;&amp;#125;</code></pre><p>&#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>floyd算法</p><p>这个也是求最短路径的算法，是求任意两点之间的最短路径，可以有负边，时间复杂度为O(N^3),空间复杂度为O(N^2),<br>算法主要是考虑的是从i到j经过的点的号不超过k的路径<br>dist[k][i][j]=min(dist[k-1][i][j],dist[k-1][i][k]+dist[k-1][k][j]);</p><p>这个可以通过动态规划进行空间优化。<br><pre><code class="hljs processing"><span class="hljs-comment">//主要的代码如下</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++)     &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)         &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)             &#123;                <span class="hljs-built_in">dist</span>[i][j] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist</span>[i][j], <span class="hljs-built_in">dist</span>[i][k] + <span class="hljs-built_in">dist</span>[k][j]);            &#125;        &#125;    &#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>c++</tag>
      
      <tag>最短路径</tag>
      
      <tag>迪杰斯特拉</tag>
      
      <tag>SPFA</tag>
      
      <tag>floyd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>177. 第N高的薪水</title>
    <link href="/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/"/>
    <url>/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。</p><p>+——+————+<br>| Id | Salary |<br>+——+————+<br>| 1  | 100    |<br>| 2  | 200    |<br>| 3  | 300    |<br>+——+————+<br>例如上述 Employee 表，n = 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。</p><p>+————————————+<br>| getNthHighestSalary(2) |<br>+————————————+<br>| 200                    |<br>+————————————+</p><pre><code class="hljs routeros">SELECT     e1.salary<span class="hljs-keyword">FROM</span>     employee e1 JOIN employee e2 ON e1.salary &lt;= e2.salaryGROUP BY     e1.salaryHAVING     count(DISTINCT e2.salary) = N</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>601. 体育馆的人流量</title>
    <link href="/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql601.%20%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/"/>
    <url>/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql601.%20%E4%BD%93%E8%82%B2%E9%A6%86%E7%9A%84%E4%BA%BA%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>表：Stadium<br>+———————-+————-+<br>| Column Name   | Type    |<br>+———————-+————-+<br>| id            | int     |<br>| visit_date    | date    |<br>| people        | int     |<br>+———————-+————-+<br>visit_date 是表的主键<br>每日人流量信息被记录在这三列信息中：序号 (id)、日期 (visit_date)、 人流量 (people)<br>每天只有一行记录，日期随着 id 的增加而增加</p><p>编写一个 SQL 查询以找出每行的人数大于或等于 100 且 id 连续的三行或更多行记录。</p><p>返回按 visit_date 升序排列的结果表。</p><p>查询结果格式如下所示。</p><p>Stadium table:<br>+———+——————+—————-+<br>| id   | visit_date | people    |<br>+———+——————+—————-+<br>| 1    | 2017-01-01 | 10        |<br>| 2    | 2017-01-02 | 109       |<br>| 3    | 2017-01-03 | 150       |<br>| 4    | 2017-01-04 | 99        |<br>| 5    | 2017-01-05 | 145       |<br>| 6    | 2017-01-06 | 1455      |<br>| 7    | 2017-01-07 | 199       |<br>| 8    | 2017-01-09 | 188       |<br>+———+——————+—————-+</p><p>Result table:<br>+———+——————+—————-+<br>| id   | visit_date | people    |<br>+———+——————+—————-+<br>| 5    | 2017-01-05 | 145       |<br>| 6    | 2017-01-06 | 1455      |<br>| 7    | 2017-01-07 | 199       |<br>| 8    | 2017-01-09 | 188       |<br>+———+——————+—————-+<br>id 为 5、6、7、8 的四行 id 连续，并且每行都有 &gt;= 100 的人数记录。<br>请注意，即使第 7 行和第 8 行的 visit_date 不是连续的，输出也应当包含第 8 行，因为我们只需要考虑 id 连续的记录。<br>不输出 id 为 2 和 3 的行，因为至少需要三条 id 连续的记录。</p><pre><code class="hljs mipsasm">select <span class="hljs-keyword">distinct </span><span class="hljs-built_in">t1</span>.* from Stadium <span class="hljs-built_in">t1</span>,Stadium <span class="hljs-built_in">t2</span>, Stadium <span class="hljs-built_in">t3</span> where <span class="hljs-built_in">t1</span>.people&gt;=<span class="hljs-number">100</span> <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.people&gt;=<span class="hljs-number">100</span> <span class="hljs-keyword">and </span><span class="hljs-built_in">t3</span>.people&gt;=<span class="hljs-number">100</span> <span class="hljs-keyword">and </span>( (<span class="hljs-built_in">t1</span>.id=<span class="hljs-built_in">t2</span>.id<span class="hljs-number">-1</span> <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.id=<span class="hljs-built_in">t3</span>.id<span class="hljs-number">-1</span>)<span class="hljs-keyword">or </span>(<span class="hljs-built_in">t1</span>.id=<span class="hljs-built_in">t2</span>.id+<span class="hljs-number">1</span> <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.id=<span class="hljs-built_in">t3</span>.id<span class="hljs-number">-2</span>)<span class="hljs-keyword">or </span>(<span class="hljs-built_in">t1</span>.id=<span class="hljs-built_in">t2</span>.id+<span class="hljs-number">1</span> <span class="hljs-keyword">and </span><span class="hljs-built_in">t2</span>.id=<span class="hljs-built_in">t3</span>.id+<span class="hljs-number">1</span>))<span class="hljs-keyword">order </span><span class="hljs-keyword">by </span>id;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>626. 换座位</title>
    <link href="/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql626.%20%E6%8D%A2%E5%BA%A7%E4%BD%8D/"/>
    <url>/2021/01/04/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql626.%20%E6%8D%A2%E5%BA%A7%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p>小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</p><p>其中纵列的 id 是连续递增的</p><p>小美想改变相邻俩学生的座位。</p><p>你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</p><p>示例：</p><p>+————-+————-+<br>|    id   | student |<br>+————-+————-+<br>|    1    | Abbot   |<br>|    2    | Doris   |<br>|    3    | Emerson |<br>|    4    | Green   |<br>|    5    | Jeames  |<br>+————-+————-+<br>假如数据输入的是上表，则输出结果如下：</p><p>+————-+————-+<br>|    id   | student |<br>+————-+————-+<br>|    1    | Doris   |<br>|    2    | Abbot   |<br>|    3    | Green   |<br>|    4    | Emerson |<br>|    5    | Jeames  |<br>+————-+————-+<br>注意：</p><p>如果学生人数是奇数，则不需要改变最后一个同学的座位。</p><p>我第一次发现mysql还能这样写判断，学习一个。<br><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">id</span>%<span class="hljs-number">2</span>=<span class="hljs-number">0</span>,            <span class="hljs-keyword">id</span><span class="hljs-number">-1</span>,            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">id</span>=(<span class="hljs-keyword">select</span> <span class="hljs-keyword">count</span>(*) <span class="hljs-keyword">from</span> seat),            <span class="hljs-keyword">id</span>,            <span class="hljs-keyword">id</span>+<span class="hljs-number">1</span>            ))<span class="hljs-keyword">as</span> <span class="hljs-keyword">id</span>,student         <span class="hljs-keyword">from</span> seat         <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">id</span>;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>886. 可能的二分法（二分图+染色法）</title>
    <link href="/2020/12/24/%E7%AE%97%E6%B3%95/886.%20%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <url>/2020/12/24/%E7%AE%97%E6%B3%95/886.%20%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>染色，一个染色成-1，一个染色成1.，出现冲突就false,否则为true。</p><p>我之前只记录单向边，然后dfs中间也没判断，然后就有样例一直过不了，很奇怪。<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;    <span class="hljs-built_in">bool</span> ans = <span class="hljs-literal">true</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">bool</span> possibleBipartition(<span class="hljs-built_in">int</span> N, vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; dislikes) &#123;        <span class="hljs-keyword">if</span>(dislikes.size() &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        vector&lt;<span class="hljs-built_in">int</span>&gt; color(N+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; link(N+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">auto</span>&amp; d : dislikes)<span class="hljs-comment">//建图</span>        &#123;            link[d[<span class="hljs-number">0</span>]].push_back(d[<span class="hljs-number">1</span>]);            link[d[<span class="hljs-number">1</span>]].push_back(d[<span class="hljs-number">0</span>]);<span class="hljs-comment">//这里反向的也要选择不然容易出错</span>        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)        &#123;            <span class="hljs-keyword">if</span>(color[i] == <span class="hljs-number">0</span>&amp;&amp;link[i].size()!=<span class="hljs-number">0</span>)<span class="hljs-comment">//未着色的</span>            &#123;                color[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//着色为1</span>                dfs(link,i, <span class="hljs-number">1</span>, color);                <span class="hljs-keyword">if</span>(!ans)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-built_in">void</span> dfs(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; link,<span class="hljs-built_in">int</span> id, <span class="hljs-built_in">int</span> col, vector&lt;<span class="hljs-built_in">int</span>&gt; &amp;color)    &#123;        <span class="hljs-keyword">if</span>(!ans) <span class="hljs-keyword">return</span>;        <span class="hljs-built_in">int</span> nextcol = -col;<span class="hljs-comment">//跟我相连的(不喜欢的人)颜色相反</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;link[id].size();i++)        &#123;            <span class="hljs-keyword">if</span>(color[link[id][i]] == col)<span class="hljs-comment">//颜色相同，出错</span>                ans = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span>(color[link[id][i]] == <span class="hljs-number">0</span>)<span class="hljs-comment">//没有访问过的，继续着色</span>            &#123;                color[link[id][i]] = nextcol;                dfs(link,link[id][i], nextcol, color);            &#125;        &#125;    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>图</tag>
      
      <tag>dfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>127. 单词接龙</title>
    <link href="/2020/12/24/%E7%AE%97%E6%B3%95/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2020/12/24/%E7%AE%97%E6%B3%95/127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<p>我一开始用的dfs，然后超时了，剪支了还是超时，写普通的广度优先搜索还是超时，<br>这个是双向的bfs.</p><p>具体地，可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p><p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; wordId;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; link;    <span class="hljs-keyword">int</span> nodeNum = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addword</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp; s)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(!wordId.count(s))        &#123;            wordId[s]=nodeNum++;            link.emplace_back();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">geneword</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp; s)</span></span><span class="hljs-function">    </span>&#123;        addword(s);        <span class="hljs-keyword">int</span> n1=wordId[s];        <span class="hljs-keyword">int</span> len=s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span>&amp; it : s)        &#123;            <span class="hljs-keyword">char</span> a=it;            it=<span class="hljs-string">&#x27;*&#x27;</span>;            addword(s);            <span class="hljs-keyword">int</span> n2=wordId[s];            it=a;            <span class="hljs-comment">// cout&lt;&lt;1;</span>            link[n1].push_back(n2);            link[n2].push_back(n1);            <span class="hljs-comment">// cout&lt;&lt;2;</span>        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(<span class="hljs-built_in">string</span> beginWord, <span class="hljs-built_in">string</span> endWord, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; wordList)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp; <span class="hljs-keyword">word</span> : wordList)        &#123;            geneword(<span class="hljs-keyword">word</span>);        &#125;        geneword(beginWord);        <span class="hljs-keyword">if</span>(!wordId.count(endWord))            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> endnum=wordId[endWord];        <span class="hljs-keyword">int</span> beginnum=wordId[beginWord];        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qbegin;        <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; qend;        qbegin.push(beginnum);        qend.push(endnum);        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">disbegin</span><span class="hljs-params">(nodeNum+<span class="hljs-number">2</span>,INT_MAX)</span></span>;        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">disend</span><span class="hljs-params">(nodeNum+<span class="hljs-number">2</span>,INT_MAX)</span></span>;        disbegin[beginnum]=<span class="hljs-number">0</span>;        disend[endnum]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!qbegin.empty()&amp;&amp;!qend.empty())        &#123;            <span class="hljs-keyword">int</span> beginlen=qbegin.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;beginlen;i++)            &#123;                <span class="hljs-keyword">int</span> w=qbegin.front();                qbegin.pop();                <span class="hljs-keyword">if</span>(disend[w]!=INT_MAX)                    <span class="hljs-keyword">return</span> (disend[w]+disend[w])/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;link[w].<span class="hljs-built_in">size</span>();j++)                &#123;                    <span class="hljs-keyword">if</span>(disbegin[link[w][j]]==INT_MAX)                    &#123;                        qbegin.push(link[w][j]);                        disbegin[link[w][j]]=disbegin[w]+<span class="hljs-number">1</span>;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">int</span> endlen=qend.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;endlen;i++)            &#123;                <span class="hljs-keyword">int</span> w=qend.front();                qend.pop();                <span class="hljs-keyword">if</span>(disbegin[w]!=INT_MAX)                &#123;                    <span class="hljs-keyword">return</span> (disend[w]+disend[w])/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;link[w].<span class="hljs-built_in">size</span>();j++)                &#123;                    <span class="hljs-keyword">if</span>(disend[link[w][j]]==INT_MAX)                    &#123;                        qend.push(link[w][j]);                        disend[link[w][j]]=disend[w]+<span class="hljs-number">1</span>;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>bfs+dfs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>图</tag>
      
      <tag>bfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1293. 网格中的最短路径(状压dp+记忆化搜索）</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/1293.%20%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/1293.%20%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>状态空间搜索解题模板<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    struct State    &#123;        <span class="hljs-built_in">int</span> x,y;        <span class="hljs-built_in">int</span> r;        State(<span class="hljs-built_in">int</span> x1,<span class="hljs-built_in">int</span> y1,<span class="hljs-built_in">int</span> r1)        &#123;            x=x1;            y=y1;            r=r1;        &#125;    &#125;;    <span class="hljs-built_in">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-built_in">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;    <span class="hljs-built_in">int</span> shortestPath(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; g, <span class="hljs-built_in">int</span> k)     &#123;        <span class="hljs-built_in">int</span> m=g.size();        <span class="hljs-built_in">int</span> n=g[<span class="hljs-number">0</span>].size();        <span class="hljs-keyword">if</span>(k&gt;=m+n<span class="hljs-number">-3</span>)            <span class="hljs-keyword">return</span> m+n<span class="hljs-number">-2</span>;        vector&lt;vector&lt;vector&lt;<span class="hljs-built_in">bool</span>&gt;&gt;&gt; visited(m, vector&lt;vector&lt;<span class="hljs-built_in">bool</span>&gt;&gt;(n, vector&lt;<span class="hljs-built_in">bool</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));        queue&lt;State&gt; Q;        Q.emplace(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);        <span class="hljs-built_in">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!Q.empty()) &#123;            <span class="hljs-built_in">int</span> s = Q.size();            <span class="hljs-keyword">while</span>(s--) &#123;                <span class="hljs-built_in">auto</span> p = Q.front();                Q.pop();                <span class="hljs-built_in">int</span> x = p.x, y = p.y;                <span class="hljs-built_in">int</span> r = p.r;                <span class="hljs-keyword">if</span>(x == m - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">1</span> &amp;&amp; r &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> step;                <span class="hljs-keyword">if</span>(visited[x][y][r] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;                visited[x][y][r] = <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)                 &#123;                    <span class="hljs-keyword">if</span>(x + dx[k] &gt;= <span class="hljs-number">0</span> &amp;&amp; x + dx[k] &lt; m &amp;&amp; y + dy[k] &gt;= <span class="hljs-number">0</span> &amp;&amp; y + dy[k] &lt; n)                     &#123;                        <span class="hljs-keyword">if</span>(g[x + dx[k]][y + dy[k]] == <span class="hljs-number">1</span> &amp;&amp; r &gt;= <span class="hljs-number">1</span>)                             Q.emplace(x + dx[k], y + dy[k], r - <span class="hljs-number">1</span>);                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(g[x + dx[k]][y + dy[k]] == <span class="hljs-number">0</span>)                            Q.emplace(x + dx[k], y + dy[k], r);                    &#125;                &#125;            &#125;            step++;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>记忆化搜索</tag>
      
      <tag>解题模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>901. 股票价格跨度</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/901.%20%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>答案的题解用的是单调栈<br>我用的不是，但是总体来说也是dp的方法，速度好像还快一点的，击败了99.8%。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">StockSpanner</span> &#123;<span class="hljs-keyword">public</span>:        vector&lt;<span class="hljs-built_in">int</span>&gt; num;        vector&lt;<span class="hljs-built_in">int</span>&gt; res;    StockSpanner()     &#123;        num.clear();        res.clear();        num.push_back(<span class="hljs-number">-1</span>);        res.push_back(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-built_in">int</span> next(<span class="hljs-built_in">int</span> price)     &#123;         <span class="hljs-built_in">int</span> len=num.size();        <span class="hljs-built_in">int</span> top=num[len<span class="hljs-number">-1</span>];        <span class="hljs-keyword">if</span>(top&lt;=price)        &#123;            <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">0</span>;<span class="hljs-comment">//最后的结果</span>            <span class="hljs-built_in">int</span> p=len<span class="hljs-number">-1</span>;<span class="hljs-comment">//最后的位置</span>            <span class="hljs-keyword">while</span>(top&lt;=price&amp;&amp;p!=<span class="hljs-number">0</span>)            &#123;                tmp+=res[p];                p=p-res[p];                top=num[p];            &#125;            num.push_back(price);            res.push_back(tmp+<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> tmp+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            num.push_back(price);            res.push_back(<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>576. 出界的路径数（记忆化搜索）</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/576.%20%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/576.%20%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs maxima">class Solution &#123;public:    long res[<span class="hljs-number">55</span>][<span class="hljs-number">55</span>][<span class="hljs-number">55</span>];    int findPaths(int m, int n, int N, int i, int j)     &#123;        res[<span class="hljs-number">0</span>][i][j]=<span class="hljs-number">1</span>;        int <span class="hljs-built_in">mod</span> = <span class="hljs-number">1000000007</span>;        <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">num</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">num</span>&lt;N;<span class="hljs-built_in">num</span>++)        &#123;            <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">row</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">row</span>&lt;m;<span class="hljs-built_in">row</span>++)            &#123;                <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">col</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">col</span>&lt;n;<span class="hljs-built_in">col</span>++)                &#123;                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span>-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>)                        res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>]=(res[<span class="hljs-built_in">num</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">row</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>]+res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])<span class="hljs-symbol">%</span>(<span class="hljs-built_in">mod</span>);                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>&lt;m)                        res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>]=(res[<span class="hljs-built_in">num</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">row</span>+<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>]+res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])<span class="hljs-symbol">%</span>(<span class="hljs-built_in">mod</span>);                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>&gt;=<span class="hljs-number">0</span>)                        res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>]=(res[<span class="hljs-built_in">num</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>-<span class="hljs-number">1</span>]+res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])<span class="hljs-symbol">%</span>(<span class="hljs-built_in">mod</span>);                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>&lt;n)                        res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>]=(res[<span class="hljs-built_in">num</span>-<span class="hljs-number">1</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>+<span class="hljs-number">1</span>]+res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-built_in">col</span>])<span class="hljs-symbol">%</span>(<span class="hljs-built_in">mod</span>);                &#125;            &#125;        &#125;        long result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">num</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">num</span>&lt;N;<span class="hljs-built_in">num</span>++)        &#123;            <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">row</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">row</span>&lt;m;<span class="hljs-built_in">row</span>++)            &#123;                result+=res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][<span class="hljs-number">0</span>];                result%=<span class="hljs-built_in">mod</span>;                result+=res[<span class="hljs-built_in">num</span>][<span class="hljs-built_in">row</span>][n-<span class="hljs-number">1</span>];                result%=<span class="hljs-built_in">mod</span>;            &#125;            <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">col</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">col</span>&lt;n;<span class="hljs-built_in">col</span>++)            &#123;                result+=res[<span class="hljs-built_in">num</span>][<span class="hljs-number">0</span>][<span class="hljs-built_in">col</span>];                result%=<span class="hljs-built_in">mod</span>;                result+=res[<span class="hljs-built_in">num</span>][m-<span class="hljs-number">1</span>][<span class="hljs-built_in">col</span>];                result%=<span class="hljs-built_in">mod</span>;            &#125;            // cout&lt;&lt;result&lt;&lt;endl;        &#125;        <span class="hljs-built_in">return</span> int(result);    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 794. Valid Tic-Tac-Toe State (medium)（ 博弈dp）</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/LeetCode%20794.%20%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/LeetCode%20794.%20%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>因为X先下，所以如果X和O的数目关系要么相等，要么X比O多1，只有这两种关系，其次再判断如果X已经赢了，O没法下，此时O的数目只能比X小1，或者O赢了，X的数目只能和O一样。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> check(vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; board,char key)&#123;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==board[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]&amp;&amp;board[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]==board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]&amp;&amp;board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==board[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]&amp;&amp;board[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]==board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]&amp;&amp;board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]==board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&amp;&amp;board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">if</span>(board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]==board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&amp;&amp;board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]==board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]&amp;&amp;board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]==key)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-built_in">bool</span> validTicTacToe(vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; board) &#123;    <span class="hljs-built_in">int</span> ansX=<span class="hljs-number">0</span>,ansO=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;X&#x27;</span>)            ansX++;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(board[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)            ansO++;        &#125;    &#125;    <span class="hljs-keyword">if</span>(ansX&lt;ansO)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(ansX-ansO&gt;<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(check(board,<span class="hljs-string">&#x27;X&#x27;</span>)&amp;&amp;ansX==ansO)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(check(board,<span class="hljs-string">&#x27;O&#x27;</span>)&amp;&amp;ansX!=ansO)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>博弈dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>博弈dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1349. 参加考试的最大学生数</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/1349.%20%E5%8F%82%E5%8A%A0%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/1349.%20%E5%8F%82%E5%8A%A0%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>方法就是每次求前n排的人数和前n-1排的人数的关系，重点在于相邻两排斜着的人是否都有，一排是否有相邻的，是否坐在坏的座位上。<br>一一排除。遍历，所有的状态，一排最多2^8个状态。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats)     &#123;        <span class="hljs-built_in">int</span> m=seats.size();        <span class="hljs-built_in">int</span> n=seats[<span class="hljs-number">0</span>].size();        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; dp(m+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">1</span>&lt;&lt;n));         <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;(<span class="hljs-number">1</span>&lt;&lt;n);j++)            &#123;                bitset&lt;<span class="hljs-number">8</span>&gt; bs(j);                <span class="hljs-built_in">bool</span> state=<span class="hljs-literal">true</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;n;k++)                &#123;                    <span class="hljs-keyword">if</span>((seats[i<span class="hljs-number">-1</span>][k]==<span class="hljs-string">&#x27;#&#x27;</span>&amp;&amp;bs[k])||(k&lt;n<span class="hljs-number">-1</span>&amp;&amp;bs[k]&amp;&amp;bs[k+<span class="hljs-number">1</span>]))                    &#123;                        state=<span class="hljs-literal">false</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(state==<span class="hljs-literal">false</span>)                &#123;                    dp[i][j]=<span class="hljs-number">-1</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;n);k++)                &#123;                    <span class="hljs-keyword">if</span>(dp[i<span class="hljs-number">-1</span>][k]==<span class="hljs-number">-1</span>)                    &#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    bitset&lt;<span class="hljs-number">8</span>&gt; lastbs(k);                    <span class="hljs-built_in">bool</span> state1=<span class="hljs-literal">true</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> r=<span class="hljs-number">0</span>;r&lt;n;r++)                    &#123;                        <span class="hljs-keyword">if</span>(lastbs[r]&amp;&amp;(r&gt;<span class="hljs-number">0</span>&amp;&amp;bs[r<span class="hljs-number">-1</span>]||r&lt;n<span class="hljs-number">-1</span>&amp;&amp;bs[r+<span class="hljs-number">1</span>]))                        &#123;                            state1=<span class="hljs-literal">false</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                    <span class="hljs-keyword">if</span>(state1==<span class="hljs-literal">true</span>)                    &#123;                        dp[i][j]=max(dp[i][j],dp[i<span class="hljs-number">-1</span>][k]+<span class="hljs-built_in">int</span>(bs.count()));                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;n);i++)        &#123;            result=max(result,dp[m][i]);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>状压dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>状态压缩dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1125. 最小的必要团队</title>
    <link href="/2020/11/02/%E7%AE%97%E6%B3%95/1125.%20%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F/"/>
    <url>/2020/11/02/%E7%AE%97%E6%B3%95/1125.%20%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F/</url>
    
    <content type="html"><![CDATA[<p>这个题一开始不会做，做出来一直超时，看的别人的思路<br>先把某些技能树是别人子集的人去掉，<br>然后做dp。<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;<span class="hljs-built_in">int</span>&gt; smallestSufficientTeam(vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; req_skills, vector&lt;vector&lt;<span class="hljs-built_in">string</span>&gt;&gt;&amp; people) &#123;        <span class="hljs-built_in">int</span> bitmap=<span class="hljs-number">0</span>;<span class="hljs-comment">//代表技能，比如111这种</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;req_skills.size();i++)        &#123;            bitmap=bitmap|(<span class="hljs-number">1</span>&lt;&lt;i);        &#125;        vector&lt;pair&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt;&gt; peo2map;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;people.size();i++)        &#123;            <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;people[i].size();j++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;req_skills.size();k++)                &#123;                    <span class="hljs-keyword">if</span>(people[i][j]==req_skills[k])                    &#123;                        tmp=tmp|(<span class="hljs-number">1</span>&lt;&lt;k);                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;            &#125;            peo2map.push_back(&#123;i,tmp&#125;);        &#125;        vector&lt;<span class="hljs-built_in">bool</span>&gt; issame(peo2map.size(),<span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;issame.size();i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=i+<span class="hljs-number">1</span>;j&lt;issame.size();j++)            &#123;                <span class="hljs-keyword">if</span>((peo2map[i].second|peo2map[j].second)==peo2map[i].second)                &#123;                    issame[j]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((peo2map[i].second|peo2map[j].second)==peo2map[j].second)                &#123;                    issame[i]=<span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        decltype(peo2map) peo2map1;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;peo2map.size();i++)        &#123;            <span class="hljs-keyword">if</span>(issame[i]==<span class="hljs-number">0</span>)            &#123;                peo2map1.push_back(peo2map[i]);            &#125;        &#125;        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;res(bitmap+<span class="hljs-number">1</span>);<span class="hljs-comment">//每一个数组代表一组技能</span>        vector&lt;<span class="hljs-built_in">int</span>&gt;skill(bitmap+<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>);<span class="hljs-comment">//记录每种技能组合对应的人数，最低位表示没有技能</span>        skill[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<span class="hljs-comment">//位图为00000..的技能被获得，某个技能树需要的人数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;peo2map1.size();i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=bitmap;j++)            &#123;                <span class="hljs-keyword">if</span>(skill[j]==<span class="hljs-number">-1</span>)                    <span class="hljs-keyword">continue</span>;                <span class="hljs-built_in">int</span> newskill=(peo2map1[i].second)|j;                <span class="hljs-keyword">if</span>(skill[newskill]==<span class="hljs-number">-1</span>||skill[newskill]&gt;skill[j]+<span class="hljs-number">1</span>)                &#123;                    skill[newskill]=skill[j]+<span class="hljs-number">1</span>;<span class="hljs-comment">//从j那边技能树走人数会更少</span>                    res[newskill]=res[j];                    res[newskill].push_back(peo2map1[i].first);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res[bitmap];    &#125;&#125;;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>状压dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>状态压缩dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库的三级模式：外模式、模式和内模式</title>
    <link href="/2020/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A4%96%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A4%96%E6%A8%A1%E5%BC%8F%E3%80%81%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%86%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一、模式（Schema）</p><p>定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p><p>理解： ① 一个数据库只有一个模式； ② 是数据库数据在逻辑级上的视图； ③ 数据库模式以某一种数据模型为基础； ④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p><p>二、外模式（External Schema）</p><p>定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p><p>理解： ① 一个数据库可以有多个外模式； ② 外模式就是用户视图； ③ 外模式是保证数据安全性的一个有力措施。</p><p>三、内模式（Internal Schema）</p><p>定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。</p><p>理解： ① 一个数据库只有一个内模式； ② 一个表可能由多个文件组成，如：数据文件、索引文件。 它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法 其目的有： ① 为了减少数据冗余，实现数据共享； ② 为了提高存取效率，改善性能。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL - ON &amp; WHERE 条件区别和执行顺序</title>
    <link href="/2020/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%20-%20ON%20&amp;%20WHERE%20%E6%9D%A1%E4%BB%B6%E5%8C%BA%E5%88%AB%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2020/10/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%20-%20ON%20&amp;%20WHERE%20%E6%9D%A1%E4%BB%B6%E5%8C%BA%E5%88%AB%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-ON-amp-WHERE-条件区别和执行顺序"><a href="#MySQL-ON-amp-WHERE-条件区别和执行顺序" class="headerlink" title="MySQL - ON &amp; WHERE 条件区别和执行顺序"></a><a href="https://blog.csdn.net/Dream_Weave/article/details/83542138?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">MySQL - ON &amp; WHERE 条件区别和执行顺序</a></h2><p>on是在生成临时表的时候使用的条件，不管on的条件是否起到作用，都会返回左表 (table_name1) 的行。<br>where则是在生成临时表之后使用的条件，此时已经不管是否使用了left join了，只要条件不为真的行，全部过滤掉。</p><h2 id="内连接，外连接，笛卡尔积连接"><a href="#内连接，外连接，笛卡尔积连接" class="headerlink" title="内连接，外连接，笛卡尔积连接"></a><a href="https://blog.csdn.net/qq_32763643/article/details/79187931">内连接，外连接，笛卡尔积连接</a></h2><h2 id="自然连接和等值连接"><a href="#自然连接和等值连接" class="headerlink" title="自然连接和等值连接"></a>自然连接和等值连接</h2><p>1、自然连接(Naturaljoin)是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果中把重复的属性列去掉。而等值连接并不去掉重复的属性列。</p><p>2、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。</p><p>3、自然连接与等值连接</p><p>在连接运算当中，一种最常用的连接是自然连接。</p><p>所谓自然连接就是在等值连接的情况下，当连接属性X与Y具有相同属性组时，把在连接结果中重复的属性列去掉。</p><p>自然连接是在广义笛卡尔积R×S中选出同名属性上符合相等条件元组，再进行投影，去掉重复的同名属性，组成新的关系。</p><p>4、等值连接与自然连接的区别：</p><p>1）等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。</p><p>2）等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。</p><p>5、事实上，我们一般使用的都是自然连接。</p><p>select FirstName, LastName, City, State from Person left join Address on Person.PersonId  =Address.PersonId;</p><p>很纠结的一点是为啥这个on不能是where，然后才发现其实因为是因为在address没有的情况下Address.PersonId;这个本身就是不对的，on因为是就算为空也会生成，所以是对的。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>486. 预测赢家</title>
    <link href="/2020/10/07/%E7%AE%97%E6%B3%95/486.%20%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/"/>
    <url>/2020/10/07/%E7%AE%97%E6%B3%95/486.%20%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<p>我考虑的是在i，j区间中获胜的人的分数，题解考虑的是分数差值，更好一点。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> PredictTheWinner(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;    <span class="hljs-built_in">int</span> len=nums.size();    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; sum(len,vector&lt;<span class="hljs-built_in">int</span>&gt;(len,<span class="hljs-number">0</span>));    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; res(len,vector&lt;<span class="hljs-built_in">int</span>&gt;(len,<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        sum[i][i]=nums[i];        res[i][i]=nums[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;i++)<span class="hljs-comment">//长度</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;i+j<span class="hljs-number">-1</span>&lt;len;j++)<span class="hljs-comment">//左边起始位置</span>        &#123;            sum[j][i+j<span class="hljs-number">-1</span>]=sum[j+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>]+nums[j];        &#125;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;i++)<span class="hljs-comment">//长度</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;i+j<span class="hljs-number">-1</span>&lt;len;j++)<span class="hljs-comment">//左边起始位置</span>        &#123;            res[j][i+j<span class="hljs-number">-1</span>]=max(sum[j+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>]-res[j+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>]+nums[j],sum[j][i+j<span class="hljs-number">-2</span>]-res[j][i+j<span class="hljs-number">-2</span>]+nums[i+j<span class="hljs-number">-1</span>]);        &#125;    &#125;    <span class="hljs-keyword">if</span>(res[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>]&gt;=(sum[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>]/<span class="hljs-number">2.0</span>))        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>博弈dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>博弈dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>837. 新21点</title>
    <link href="/2020/10/06/%E7%AE%97%E6%B3%95/837.%20%E6%96%B021%E7%82%B9/"/>
    <url>/2020/10/06/%E7%AE%97%E6%B3%95/837.%20%E6%96%B021%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>我们以 N = 21，K = 17，W = 10 来思考。<br>因为我们的结果是求手上点数为 0 时，赢得游戏的概率。</p><p>所以我们需要从后往前逆向求，比如在这里，我们就需要知道在手上点数为 16 时赢得游戏的概率，从而在往前求手上点数为 15 时的概率，最后求出手上点数为 0 时的赢得游戏的概率。</p><p>那我们怎么求点数为 16 时赢得游戏的概率呢？</p><p>这里我们知道手上点数为 17 时赢得游戏的概率为 100%，所以 K ~ N 区间的赢得游戏的概率为 100%，超过 N 时赢得游戏概率为 0，那么手上点数为 16 时，赢得游戏的概率就是 手上点数为 17 ~ 17 + 10 - 1 的赢得游戏的概率和除以 W，即用一个表达式为 win[16] = sum(win[17] ~ win[26]) / W。</p><p>这里我们可以以 O(1) 的时间复杂度计算 sum(win[i + 1] ~ win[i + W - 1])。<br>我们用一个sumProb = sum(win[17] ~ win[26])<br>然后每次计算<br>win[i] = sumProb / W<br>sumProb = sumProb + win[i] - win[i + W]</p><p>这个题目如果用简单的dp会超时，需要从后向前dp，进行优化，考虑差分。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> new21Game(<span class="hljs-built_in">int</span> N, <span class="hljs-built_in">int</span> K, <span class="hljs-built_in">int</span> W) &#123;    vector&lt;<span class="hljs-built_in">double</span>&gt; res(K+W+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    res[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=K;i&lt;=N;i++)    &#123;        res[i]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">double</span> tmp=N-K+<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=K<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)    &#123;        res[i]=tmp/W;        tmp=tmp-res[i + W] + res[i];    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>];&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>概率dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>概率dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>808. 分汤</title>
    <link href="/2020/10/06/%E7%AE%97%E6%B3%95/808.%20%E5%88%86%E6%B1%A4/"/>
    <url>/2020/10/06/%E7%AE%97%E6%B3%95/808.%20%E5%88%86%E6%B1%A4/</url>
    
    <content type="html"><![CDATA[<p>即使将 N 除以 25 之后，仍然没法在短时间内得到答案，因此我们需要尝试一些别的思路。可以发现，分配操作有 (4, 0)，(3, 1)，(2, 2) 和 (1, 3) 四种，那么在一次分配中，汤 A 平均会少 (4 + 3 + 2 + 1) / 4 = 2.5 份，汤 B 平均会少 (0 + 1 + 2 + 3) / 4 = 1.5 份。因此在 N 非常大的时候，A 会有很大的概率比 B 先分配完，所有概率应该非常接近 1。事实上，当 N &gt;= 500 <em> 25 时，所求概率已经大于 0.999999 了（可以通过上面的动态规划方法求出），它和 1 的误差（无论是绝对误差还是相对误差）都小于 10^-6。因此在 N &gt;= 500 </em> 25 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> soupServings(<span class="hljs-built_in">int</span> N) &#123;    N=N/<span class="hljs-number">25</span>+(N%<span class="hljs-number">25</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(N&gt;=<span class="hljs-number">500</span>*<span class="hljs-number">25</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">1</span>);    vector&lt;vector&lt;<span class="hljs-built_in">double</span>&gt; &gt; res(N+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">double</span>&gt;(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)    &#123;        res[<span class="hljs-number">0</span>][i]=<span class="hljs-number">1.0</span>;    &#125;    res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0.5</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=N;j++)        &#123;            <span class="hljs-built_in">double</span> tmp=res[(i<span class="hljs-number">-4</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(i<span class="hljs-number">-4</span>)][j]+res[(i<span class="hljs-number">-3</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(i<span class="hljs-number">-3</span>)][(j<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(j<span class="hljs-number">-1</span>)];            <span class="hljs-built_in">double</span> tmp1=res[(i<span class="hljs-number">-2</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(i<span class="hljs-number">-2</span>)][(j<span class="hljs-number">-2</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(j<span class="hljs-number">-2</span>)]+res[(i<span class="hljs-number">-1</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(i<span class="hljs-number">-1</span>)][(j<span class="hljs-number">-3</span>)&lt;<span class="hljs-number">0</span>?<span class="hljs-number">0</span>:(j<span class="hljs-number">-3</span>)];            res[i][j]=<span class="hljs-number">0.25</span>*(tmp+tmp1);        &#125;    &#125;    <span class="hljs-keyword">return</span> res[N][N];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>概率dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>概率dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>957. N 天后的牢房</title>
    <link href="/2020/10/06/%E7%AE%97%E6%B3%95/957.N%20%E5%A4%A9%E5%90%8E%E7%9A%84%E7%89%A2%E6%88%BF/"/>
    <url>/2020/10/06/%E7%AE%97%E6%B3%95/957.N%20%E5%A4%A9%E5%90%8E%E7%9A%84%E7%89%A2%E6%88%BF/</url>
    
    <content type="html"><![CDATA[<p>为啥14总是一个循环呢？</p><p>首先，经过一次变化之后，0位和7位的数字都会固定是0，不再改变<br>？？？？？？？?<br>|<br>0 ？？？？？？0</p><p>其次，第n次的1357位的值决定了n+1次2468位的值，而n+1次的2468位的值又决定了n+2次1357位的值。<br>因此可以得出，第n次的1357位的值可以决定n+2次1357位的值，并且，第n次的2468位的值可以决定n+2次2468位的值。</p><p>下面先考虑2468位的情况。<br>因为，8位的值是固定的，所以，只需要考虑246位的值。<br>按2^3=8的情况考虑，246的值可能的情况最多只有8种。<br>然而，仔细观察后会发现，如果第n次的246位的值是001，那么n+2次246位的值也是001，所以001的情况下，246位的值保持不变，所以循环次数为1。<br>如果246位值是其他的情况，那么他们会经历7次循环，因为每次循环需要变换两次，所以，总共需要的变化次数就是14。<br>(1)111 -&gt; (2)010 -&gt; (3)110 -&gt; (4)000 -&gt; (5)011 -&gt; (6)100 -&gt; (7)101 -&gt; (8)111</p><p>因为1357位和2468位的地位相同，情况一样，同理，考虑1357位。<br>100的情况下，135的值保持不变，其他情况下，7次循环，14次变化。<br>(0)111 -&gt; (1)010 -&gt; (2)011 -&gt; (3)000 -&gt; (4)110 -&gt; (5)001 -&gt; (6)101 -&gt; (7)111</p><p>但是，注意，我们没有考虑到在每次变换中间，375位和246位的值。<br>其实在中间位置时，它们也同样处于一个循环B中。<br>还是先考虑246位，最好的情况就是，由246位初始决定的A循环，和由1357位的初始值决定的B循环，两个循环恰好互补，也就是下面的情况：<br>（我们用A，B分别表示两个循环，A1表示第一个循环中的第一次，B1表示第二个循环中的第一次）<br>(初始情况：A1)111 -&gt; (第一次变化：B1)011 -&gt; (第二次变化：A2)010 -&gt; (第三次变化：B2)100 -&gt; (第四次变化：A3)110 -&gt; (第五次变化：B3)101 -&gt; (第六次变化：A4)000 -&gt; (第七次变化：B4)111 -&gt; (第八次变化：A5)011 -&gt; (第九次变化：B5)010 -&gt; (第十次变化：A6)100 -&gt; (第十一次变化：B6)110 -&gt; (第十二次变化：A7)101 -&gt; (第十三次变化：B7)000 -&gt; (第十四次变化：A8)111<br>这样，在第8次变化前，246位的值已经完成了一次循环。<br>因为，A循环由246位初始决定，B循环由1357位的初始值决定，所以其实在上述情况下，1357位的值也是固定的。</p><p>因此，<br>当1357位固定为0100并且2468位固定为0010时，即情况为{0,0,1,0,0,1,0,0}时，循环次数为1。<br>当1357位和2468位出现最佳情况时，循环次数为7，有一下其中情况：<br>1: {0, 1, 1, 1, 1, 1, 1, 0}<br>2: {0, 0, 1, 1, 1, 1, 0, 0}<br>3: {0, 0, 0, 1, 1, 0, 0, 0}<br>4: {0, 1, 0, 0, 0, 0, 1, 0}<br>5: {0, 1, 0, 1, 1, 0, 1, 0}<br>6: {0, 1, 1, 0, 0, 1, 1, 0}<br>7: {0, 0, 0, 0, 0, 0, 0, 0}<br>其他情况下，循环次数为14。<br><pre><code class="hljs angelscript">vector&lt;<span class="hljs-built_in">int</span>&gt; prisonAfterNDays(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; cells, <span class="hljs-built_in">int</span> N) &#123;    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> cells;    N=N%<span class="hljs-number">14</span>;    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)<span class="hljs-comment">//当N为0的时候需要特别注意。</span>        N=<span class="hljs-number">14</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; res(<span class="hljs-number">8</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">int</span> flag=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">6</span>;j++)        &#123;            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)            &#123;                <span class="hljs-keyword">if</span>(cells[j<span class="hljs-number">-1</span>]==cells[j+<span class="hljs-number">1</span>])                &#123;                    res[j]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>                    res[j]=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-keyword">if</span>(res[j<span class="hljs-number">-1</span>]==res[j+<span class="hljs-number">1</span>])                &#123;                    cells[j]=<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>                    cells[j]=<span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)        &#123;            res[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;            res[<span class="hljs-number">7</span>]=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            cells[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;            cells[<span class="hljs-number">7</span>]=<span class="hljs-number">0</span>;        &#125;        flag=-flag;    &#125;    <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> cells;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> res;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>状压dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>auto和decltype之间的区别</title>
    <link href="/2020/08/13/C++/auto%E5%92%8Cdecltype%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/08/13/C++/auto%E5%92%8Cdecltype%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="auto与decltype区别："><a href="#auto与decltype区别：" class="headerlink" title="auto与decltype区别："></a>auto与decltype区别：</h1><h3 id="1-auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。"><a href="#1-auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。" class="headerlink" title="1 auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。"></a>1 auto类型说明符用编译器计算变量的初始值来推算其类型，decltype虽然也让编译器分析表达式得到它的类型，但是并不计算表达式的值。</h3><h3 id="2-编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。"><a href="#2-编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。" class="headerlink" title="2 编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。"></a>2 编译器推算出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。比如，auto一般会忽略顶层const，而把底层const保留下来。decltype会把顶层const保留下来。</h3><h3 id="3-decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。"><a href="#3-decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。" class="headerlink" title="3 decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。"></a>3 decltype使用一个不加括号的变量，得到的结果就是该变量的类型，如果加上一层或多层括号，则编译器将腿短得到引用类型。</h3><p><a href="https://blog.csdn.net/qq_14982047/article/details/50615422">关于详细的顶层const和底层const可以参考</a></p><p><a href="https://blog.csdn.net/qq_14982047/article/details/50628075">详细的例子参考</a></p><p><a href="https://my.oschina.net/u/3863980/blog/1843956">关于decltype和函数指针迷惑,函数指针参考</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉东变换</title>
    <link href="/2020/08/04/test/"/>
    <url>/2020/08/04/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>医学图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拉东变换</title>
    <link href="/2020/08/03/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E6%8B%89%E4%B8%9C%E5%8F%98%E6%8D%A2/"/>
    <url>/2020/08/03/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E6%8B%89%E4%B8%9C%E5%8F%98%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>x射线在穿过人体传播的时候，它的衰减是这样的</p><p>$I=I_0 e^{-ux}$</p><p><img src="/images/拉东变换1.png" alt="衰减系数原理"></p><p><img src="/images/拉东变换2.png" alt="直线方程"></p><p><img src="/images/拉东变换5.png" alt="拉东公式"></p><p><img src="/images/拉东变换3.png" alt="傅里叶卷积定理"></p><p><img src="/images/拉东变换4.png" alt="拉东逆变换"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>医学图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>attention机制</title>
    <link href="/2020/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/attention%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/07/31/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/attention%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="attention机制"><a href="#attention机制" class="headerlink" title="attention机制"></a>attention机制</h1><p>这篇文章讲的很详细<br><a href="https://www.cnblogs.com/ydcode/p/11038064.html#encoder-decoder-%E6%A1%86%E6%9E%B6">attention机制</a></p><p>这篇文章的例子讲的可以<br><a href="https://blog.csdn.net/xiewenbo/article/details/79382785">attention机制</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>医学图像相关内容</title>
    <link href="/2020/07/29/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <url>/2020/07/29/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="ASTRA-Toolbox"><a href="#ASTRA-Toolbox" class="headerlink" title="ASTRA Toolbox"></a>ASTRA Toolbox</h1><p>一个python的库，包含很多的医学图像的算法，比如fbp，sart，生成投影数据等问题。</p><p>还可以进行gpu加速，可以学习学习。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>医学图像</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>memset赋值问题</title>
    <link href="/2020/07/29/C++/memset%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/29/C++/memset%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在memset的赋值问题中，是按字节赋值的，如果是menset(array,1,n*sizeof(int));<br>结果不是每个int变成1，而是变成很大的数，它是将int的每一个字节赋值为1，因此最好只在赋值为0的时候使用。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状压dp</title>
    <link href="/2020/07/29/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8Bdp/"/>
    <url>/2020/07/29/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%8A%B6%E5%8E%8Bdp/</url>
    
    <content type="html"><![CDATA[<h1 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h1><p>状态压缩动态规划，就是我们俗称的状压DP，是利用计算机二进制的性质来描述状态的一种DP方式。</p><p>很多棋盘问题都运用到了状压，同时，状压也很经常和BFS及DP连用。</p><p>状压dp其实就是将状态压缩成2进制来保存 其特征就是看起来有点像搜索，每个格子的状态只有1或0 ，是另一类非常典型的动态规划</p><p>举个例子：有一个大小为n*n的农田，我们可以在任意处种田，现在来描述一下某一行的某种状态：</p><p>设n = 9；</p><p>有二进制数 100011011（九位），每一位表示该农田是否被占用，1表示用了，0表示没用，这样一种状态就被我们表示出来了。这表示的是一中状态，表示的是在这个状态下每个东西的情况。如果要用数组来表示，必须用很多空间表示这一个状态的集合。而在现实因为每个东西状态只有01 所以我们用一个数来表示这种集合状态。</p><h1 id="leetcode-464-我能赢吗"><a href="#leetcode-464-我能赢吗" class="headerlink" title="leetcode 464. 我能赢吗"></a>leetcode 464. 我能赢吗</h1><p>采用状压dp来压缩状态。<br>对于每次回溯来说，如果本次(第一个人)选择数字i达到了desiredTotal，说明当前状态下能赢，即返回true，又或者下一次(另一个人)输了，那么说明本次选择必赢。</p><p>用dp数组索引表示所选整数的累加和减1，而这个累加和又能体现整数元素选取的情况。dp数组的索引对应整数累加和状态，该整数累加和状态对应组合状态；dp数组元素的值表示整数组合状态对应的结果，为true表示该组合状态已存在并且能赢，直接返回；为false表示该组合状态已存在并且输了，直接返回；为空表示还没出现这种整数组合状态，是一个新状态，需要进行递归计算。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">bool</span> canIWin(<span class="hljs-built_in">int</span> maxChoosableInteger, <span class="hljs-built_in">int</span> desiredTotal) &#123;        <span class="hljs-keyword">if</span>(maxChoosableInteger&gt;=desiredTotal)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>((maxChoosableInteger+<span class="hljs-number">1</span>)*maxChoosableInteger/<span class="hljs-number">2</span>&lt;desiredTotal)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-built_in">int</span> *dp=new <span class="hljs-built_in">int</span>[<span class="hljs-number">1</span>&lt;&lt;(maxChoosableInteger)];<span class="hljs-comment">//减法优先级更高</span>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;(maxChoosableInteger);i++)            dp[i]=<span class="hljs-number">-1</span>;        <span class="hljs-built_in">bool</span> res= dfs(maxChoosableInteger,desiredTotal,dp,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-built_in">bool</span> dfs(<span class="hljs-built_in">int</span> maxChoosableInteger,<span class="hljs-built_in">int</span> desiredTotal,<span class="hljs-built_in">int</span> *p,<span class="hljs-built_in">int</span> state)    &#123;        <span class="hljs-keyword">if</span>(p[state]!=<span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> p[state];        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=maxChoosableInteger;i++)        &#123;            <span class="hljs-built_in">int</span> s=<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>((s&amp;state)==<span class="hljs-number">0</span>)<span class="hljs-comment">//位运算的优先级很低</span>            &#123;                <span class="hljs-keyword">if</span>(desiredTotal-i&lt;=<span class="hljs-number">0</span>||!dfs(maxChoosableInteger,desiredTotal-i,p,s|state))                &#123;                    p[state]=<span class="hljs-number">1</span>;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        p[state]=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h1 id="526-优美的排列"><a href="#526-优美的排列" class="headerlink" title="526. 优美的排列"></a>526. 优美的排列</h1><p>这个题目使用两个数字来记录。第一个是代表哪些数字已经被使用，状态压缩记录，另一个代表的是这是第几个数字。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> countArrangement(<span class="hljs-built_in">int</span> N) &#123;    <span class="hljs-built_in">int</span> *dp=new <span class="hljs-built_in">int</span>[<span class="hljs-number">1</span>&lt;&lt;N];    <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-number">1</span>&lt;&lt;N);i++)        dp[i]=<span class="hljs-number">-1</span>;    res=dfs(N,dp,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);    delete []dp;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">int</span> N,<span class="hljs-built_in">int</span> *dp,<span class="hljs-built_in">int</span> state,<span class="hljs-built_in">int</span> p)&#123;    <span class="hljs-keyword">if</span>(dp[state]!=<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> dp[state];    <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=N;i++)    &#123;        <span class="hljs-built_in">int</span> s=<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>((s&amp;state)==<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span>((i%p==<span class="hljs-number">0</span>||p%i==<span class="hljs-number">0</span>))            &#123;                <span class="hljs-keyword">if</span>(p==N)                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;                tmp+=dfs(N,dp,state|s,p+<span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-comment">// cout&lt;&lt;tmp&lt;&lt;endl;</span>    <span class="hljs-keyword">return</span> tmp;&#125;</code></pre><h1 id="935-骑士拨号器"><a href="#935-骑士拨号器" class="headerlink" title="935. 骑士拨号器"></a>935. 骑士拨号器</h1><p>这道题目看起来不像是状压dp，就是让上一个情况递推到下一个，然后同时记录中间的结果。<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-built_in">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">5005</span>];<span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> C=pow(<span class="hljs-number">10</span>,<span class="hljs-number">9</span>)+<span class="hljs-number">7</span>;    <span class="hljs-built_in">int</span> knightDialer(<span class="hljs-built_in">int</span> N)     &#123;        vector&lt;<span class="hljs-built_in">int</span>&gt; t(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>);        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; b(<span class="hljs-number">10</span>,t);        b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;        b[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">6</span>;b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">8</span>;        b[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">7</span>;b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">9</span>;        b[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">4</span>;b[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">8</span>;        b[<span class="hljs-number">4</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>;b[<span class="hljs-number">4</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">9</span>;b[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;        b[<span class="hljs-number">6</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;b[<span class="hljs-number">6</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">7</span>;b[<span class="hljs-number">6</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;        b[<span class="hljs-number">7</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;b[<span class="hljs-number">7</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">6</span>;        b[<span class="hljs-number">8</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span>;b[<span class="hljs-number">8</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;        b[<span class="hljs-number">9</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">2</span>;b[<span class="hljs-number">9</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>;        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)        &#123;            res=(fun(i,N<span class="hljs-number">-1</span>,b)+res)%C;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-built_in">int</span> fun(<span class="hljs-built_in">int</span> i,<span class="hljs-built_in">int</span> N,vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; &amp;b)    &#123;        <span class="hljs-keyword">if</span>(a[i][N]!=<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> a[i][N];        <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-built_in">int</span> tmp1=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> t=<span class="hljs-number">0</span>;t&lt;<span class="hljs-number">3</span>;t++)        &#123;            <span class="hljs-built_in">int</span> tmp=b[i][t];            <span class="hljs-keyword">if</span>(tmp!=<span class="hljs-number">-1</span>)                tmp1=(fun(tmp,N<span class="hljs-number">-1</span>,b)%C+tmp1%C)%C;        &#125;        a[i][N]=tmp1;        <span class="hljs-keyword">return</span> tmp1%C;    &#125;&#125;;</code></pre></p><h1 id><a href="#" class="headerlink" title=" "></a> </h1><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> a[<span class="hljs-number">8</span>][<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>];    <span class="hljs-built_in">int</span> maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats)     &#123;        <span class="hljs-built_in">int</span> len=seats.size();        <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">0</span>||seats[<span class="hljs-number">0</span>].size()&lt;=<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> len1=seats[<span class="hljs-number">0</span>].size();        vector&lt;<span class="hljs-built_in">int</span>&gt; t(len1,<span class="hljs-number">-1</span>);        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; tt(len,t);<span class="hljs-comment">//这一行，以及上一行的状态</span>        dfs(<span class="hljs-number">0</span>,dp,<span class="hljs-number">0</span>，<span class="hljs-number">0</span>)<span class="hljs-comment">//第几行，这一行的状态，由于只会往上和左右扩散，所以可以从一个方向走。</span>        <span class="hljs-keyword">return</span> res;     &#125;    <span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">int</span> len,vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; dp,<span class="hljs-built_in">int</span> state，<span class="hljs-built_in">int</span> state1)    &#123;        <span class="hljs-keyword">if</span>(dp[len][state][state1]!=<span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> dp[len][state][state1];        <span class="hljs-built_in">int</span> tmp=<span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> rr=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        &#123;            <span class="hljs-built_in">int</span> s1=state;            <span class="hljs-built_in">int</span> s2=state1;            tmp=<span class="hljs-number">1</span>&lt;&lt;i;            <span class="hljs-keyword">if</span>((i&amp;state)==<span class="hljs-number">0</span>)            &#123;                s1=s1|tmp;                <span class="hljs-keyword">if</span>(i<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)                &#123;                    s1=s1|(<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>);                    s2=s2|(<span class="hljs-number">1</span>&lt;&lt;i<span class="hljs-number">-1</span>);                &#125;                <span class="hljs-keyword">if</span>(i&lt;=len1)                &#123;                    s1=s1|(<span class="hljs-number">1</span>&lt;&lt;i+<span class="hljs-number">1</span>);                    s2=s2|(<span class="hljs-number">1</span>&lt;&lt;i+<span class="hljs-number">1</span>);                &#125;                rr=max(rr,dfs(len,dp,s1,s2));            &#125;        &#125;        dp[len][s1][s2]=rr;        <span class="hljs-keyword">return</span> rr;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>状压dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>状压dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形dp</title>
    <link href="/2020/07/28/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2020/07/28/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1><h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h1><p>这里就是对于每棵树判断两种情况，是选择自己作为深度，祖宗节点作为根节点穿过最长，还是就是自己作为根节点穿过最长呢。<br>于是只需要求子节点的最长的节点长度，然后最后把节点长度减一就可以了。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> dfs(TreeNode* root)    &#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>ptr)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> l=dfs(root-&gt;left);        <span class="hljs-built_in">int</span> r=dfs(root-&gt;right);        res=max(res,l+r+<span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> max(l,r)+<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">int</span> diameterOfBinaryTree(TreeNode* root)     &#123;        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">null</span>ptr)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> a=dfs(root);        <span class="hljs-keyword">return</span> res<span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre><h1 id="LeetCode-337-House-Robber-III-medium"><a href="#LeetCode-337-House-Robber-III-medium" class="headerlink" title="LeetCode 337. House Robber III (medium)"></a>LeetCode 337. House Robber III (medium)</h1><p>这个在打家劫舍系列里面，动态规划里面，这里就不重复写了。</p><h1 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h1><p>这个题目的思路主要是就是我们在每个经过的路径肯定有一个最高的节点。如果自己这个节点就是最高的节点。那么就是比较结果和左子树加右子树加节点的值。这个地方要注意 一个节点的情况实际上是已经包含的了。</p><p>接下来就是两个节点的情况。<br>左子树或者右子树，取大于0 的最大值。然后加上节点值返回。</p><p>一开始我不理解三个节点的情况，两个节点的情况，一个节点的情况的区别，有可能还有负数，我比较混乱，所以就写得很繁琐，都列举出来了。</p><p>较繁琐代码，可以参考。击败97%<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs ocaml"><span class="hljs-keyword">class</span> <span class="hljs-type">Solution</span> &#123;<br>public:<br>    <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> maxval=-<span class="hljs-number">0x7fffffff</span>-<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> dfs(<span class="hljs-type">TreeNode</span>* root)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(root==nullptr)<br>        &#123;<br>            return <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span>&gt;maxval)<br>            maxval=root-&gt;<span class="hljs-keyword">val</span>;<br>        <span class="hljs-built_in">int</span> <span class="hljs-type">L</span>=dfs(root-&gt;left);<br>        <span class="hljs-built_in">int</span> <span class="hljs-type">R</span>=dfs(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-type">L</span>&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">R</span>&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                res=max(res,root-&gt;<span class="hljs-keyword">val</span>);<br>                return root-&gt;<span class="hljs-keyword">val</span>&gt;<span class="hljs-number">0</span>?root-&gt;<span class="hljs-keyword">val</span>:<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                res= max(res,<span class="hljs-type">R</span>+max(<span class="hljs-number">0</span>,root-&gt;<span class="hljs-keyword">val</span>));<br>                return <span class="hljs-type">R</span>+root-&gt;<span class="hljs-keyword">val</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-type">R</span>+root-&gt;<span class="hljs-keyword">val</span>:<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">R</span>&lt;<span class="hljs-number">0</span>)<br>            &#123;<br>                res= max(res,<span class="hljs-type">L</span>+max(<span class="hljs-number">0</span>,root-&gt;<span class="hljs-keyword">val</span>));<br>                return <span class="hljs-type">L</span>+root-&gt;<span class="hljs-keyword">val</span>&gt;<span class="hljs-number">0</span>?<span class="hljs-type">L</span>+root-&gt;<span class="hljs-keyword">val</span>:<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-keyword">val</span>&gt;=<span class="hljs-number">0</span>||root-&gt;<span class="hljs-keyword">val</span>+<span class="hljs-type">L</span>&gt;<span class="hljs-number">0</span>||root-&gt;<span class="hljs-keyword">val</span>+<span class="hljs-type">R</span>&gt;<span class="hljs-number">0</span>)<br>                    res=max(res,<span class="hljs-type">L</span>+<span class="hljs-type">R</span>+root-&gt;<span class="hljs-keyword">val</span>);<br>                <span class="hljs-keyword">else</span><br>                    res=max(res,max(<span class="hljs-type">L</span>,<span class="hljs-type">R</span>));<br>                <span class="hljs-built_in">int</span> tmp=max(<span class="hljs-type">R</span>,<span class="hljs-type">L</span>)+root-&gt;<span class="hljs-keyword">val</span>;<br>                return tmp&gt;<span class="hljs-number">0</span>?tmp:<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;</code></pre></p><pre><code>&amp;#125;&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; maxPathSum(&lt;span class=&quot;hljs-type&quot;&gt;TreeNode&lt;/span&gt;* root) &amp;#123;    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; a=dfs(root);    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(maxval&amp;lt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)        return maxval;    return res;&amp;#125;</code></pre><p>&#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><p>简化代码。<br><pre><code class="hljs arduino"><span class="hljs-keyword">int</span> res=<span class="hljs-number">-0x7fffffff</span><span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">int</span> L=dfs(root-&gt;left);    <span class="hljs-keyword">int</span> R=dfs(root-&gt;right);    <span class="hljs-keyword">int</span> l=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,L);    <span class="hljs-keyword">int</span> r=<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>,R);    res=<span class="hljs-built_in">max</span>(res,r+l+root-&gt;val);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l,r)+root-&gt;val;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;    dfs(root);    <span class="hljs-keyword">return</span> res;&#125;</code></pre></p><p>代码差不多只是稍微简化了一点点。也是97%</p><h1 id="LeetCode-1245-Tree-Diameter"><a href="#LeetCode-1245-Tree-Diameter" class="headerlink" title="LeetCode 1245. Tree Diameter"></a>LeetCode 1245. Tree Diameter</h1><p>这道题是被锁住的。</p><p>题目描述<br>给定一棵无向树，返回它的直径：树中最长路径的 边 的数量。</p><p>树用一个数组给出，数组为 edges[i] = [u, v]，每个元素代表一条双向边连接结点 u 和 v。每个结点的编号为 {0, 1, …, edges.length}。</p><p>样例</p><p>输入：edges = [[0,1],[0,2]]<br>输出：2<br>解释：<br>这棵树上最长的路径是 1 - 0 - 2，边数为 2。</p><p>输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]]<br>输出：4<br>解释：<br>这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。<br>限制<br>0 &lt;= edges.length &lt; 10^4<br>edges[i][0] != edges[i][1]<br>0 &lt;= edges[i][j] &lt;= edges.length<br>edges 会形成一棵无向树。</p><p>遇到树的题目，多数要考虑到使用dfs或者bfs来解题。本题也不例外，从任意一点开始dfs整棵树，对于任意当前节点，它能组成的最大边长应该是从自身出发的所有路径中最长两条路径长度的和。因此，在每一步dfs中，我们需要记录下当前节点最长两条路径的长度，并求出和sum。同时返回最长的一条边的长度给上层dfs。全部dfs结束后，找到最大的sum即是结果。</p><p>之前我比较纠结的一点是为什么为什么走过来不会走回去，后来才发现，因为保证了不会走回头路，又是无环图所以一定不会走回去，最后写起来就和二叉树有点像。<br>每次判断以当前节点为中间节点的路径和最长路径的大小。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>; <span class="hljs-comment">// 返回结果</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> treeDiameter(<span class="hljs-built_in">int</span>[][] edges) &#123;    <span class="hljs-comment">// 利用边的信息构建出树的结构，即每个节点能和哪些节点相连接</span>    List&lt;Integer&gt;[] tree = new List[edges.length+<span class="hljs-number">1</span>];    <span class="hljs-comment">// 初始化</span>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;tree.length;i++)&#123;        tree[i] = new ArrayList&lt;&gt;();    &#125;    <span class="hljs-comment">// 构建树</span>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span>[] edge : edges)&#123;        tree[edge[<span class="hljs-number">0</span>]].add(edge[<span class="hljs-number">1</span>]);        tree[edge[<span class="hljs-number">1</span>]].add(edge[<span class="hljs-number">0</span>]);    &#125;    dfs(tree, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// 开始dfs</span>    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-comment">// tree为树的结构图</span><span class="hljs-comment">// current为当前节点</span><span class="hljs-comment">// previous为前一个节点</span><span class="hljs-comment">// 返回值为：以当前节点为起点的一条最大路径长度</span><span class="hljs-built_in">int</span> dfs(List[] tree, <span class="hljs-built_in">int</span> current, <span class="hljs-built_in">int</span> previous)&#123;    <span class="hljs-comment">// 查看当前节点能与哪些节点连接</span>    List&lt;Integer&gt; list = tree[current];    <span class="hljs-built_in">int</span> max1=<span class="hljs-number">0</span>; <span class="hljs-comment">// 以当前节点为起点的一条最大路径长度</span>    <span class="hljs-built_in">int</span> max2=<span class="hljs-number">0</span>; <span class="hljs-comment">// 以当前节点为起点的一条次大路径长度</span>    <span class="hljs-comment">// 循环所有与当前节点相连的点</span>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> next : list)&#123;        <span class="hljs-comment">// 防止走回头路</span>        <span class="hljs-keyword">if</span>(next != previous)&#123;            <span class="hljs-comment">// dfs得到下一个节点一条路径的最大长度</span>            <span class="hljs-comment">// 加一之后为当前节点一条路径的长度</span>            <span class="hljs-built_in">int</span> max = dfs(tree, next, current)+<span class="hljs-number">1</span>;            <span class="hljs-comment">// 比较当路径长度与之前得到的max1，max2，并更新最大值</span>            <span class="hljs-keyword">if</span>(max&gt;=max1)&#123;                max2=max1;                max1=max;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(max&gt;=max2)&#123;                max2=max;            &#125;            <span class="hljs-comment">// max1+max2得到当前节点最大边长,与返回结果比较，更新最大值</span>            res=Math.max(res, max1+max2);        &#125;    &#125;    <span class="hljs-comment">// 返回当前节点一条路径的最大长度</span>    <span class="hljs-keyword">return</span> max1;&#125;</code></pre><h1 id="LeetCode-333-Largest-BST-Subtree-最大的二分搜索子树"><a href="#LeetCode-333-Largest-BST-Subtree-最大的二分搜索子树" class="headerlink" title="[LeetCode] 333. Largest BST Subtree 最大的二分搜索子树"></a>[LeetCode] 333. Largest BST Subtree 最大的二分搜索子树</h1><p>Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it.</p><p>Note:<br>A subtree must include all of its descendants.</p><p>Example:</p><p>Input: [10,5,15,1,8,null,7]</p><p>   10<br>   / \<br>  5  15<br> / \   \<br>1   8   7</p><p>Output: 3<br>Explanation: The Largest BST Subtree in this case is the highlighted one.<br>             The return value is the subtree’s size, which is 3.<br>Follow up:<br>Can you figure out ways to solve it with O(n) time complexity?</p><p>Hint:</p><p>You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity.</p><p>找最大的二叉搜索子树<br>首先肯定是需要子树的范围, 因为我们要判断当前结点为根的树是否为二叉搜索树就要满足当前结点大于左子树的最大值, 小于右子树的最小值. 再次我们还需要知道子树是否为二叉搜索树以及其二叉搜索树的大小. 有了这些信息我们就可以判断以当前结点为根的二叉树是否为二叉搜索树了. 但是这题很容易写的比较复杂.<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-built_in">int</span>&gt; DFS(TreeNode* root, <span class="hljs-built_in">int</span>&amp; ans)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;<span class="hljs-number">0</span>, INT_MAX, INT_MIN&#125;;<br>        <span class="hljs-built_in">auto</span> left=DFS(root-&gt;left, ans), right=DFS(root-&gt;right, ans);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; left[<span class="hljs-number">2</span>] &amp;&amp; root-&gt;val &lt; right[<span class="hljs-number">1</span>])<br>        &#123;<br>            <span class="hljs-built_in">int</span> Min =min(root-&gt;val, left[<span class="hljs-number">1</span>]), Max =max(root-&gt;val, right[<span class="hljs-number">2</span>]);<br>            ans = max(ans, left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;left[<span class="hljs-number">0</span>] +right[<span class="hljs-number">0</span>] +<span class="hljs-number">1</span>, Min , Max&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-built_in">int</span>&gt;&#123;<span class="hljs-number">0</span>, INT_MIN, INT_MAX&#125;;<br>    &#125;</code></pre></p><pre><code>&lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; largestBSTSubtree(TreeNode* root) &amp;#123;    &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;    DFS(root, ans);    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ans;&amp;#125;</code></pre><p>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>树形dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>树形dp</tag>
      
      <tag>邻接矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2020/07/27/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/Dicom%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <url>/2020/07/27/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/Dicom%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="图像转CT值"><a href="#图像转CT值" class="headerlink" title="图像转CT值"></a>图像转CT值</h1><p>CT值的单位是Hounsfield，简称为Hu，范围是-1024-3071。用于衡量人体组织对X射线的吸收率，设定水的吸收率为0Hu。</p><p>　在DICOM图像读取的过程中，我们会发现图像的像素值有可能不是这个范围，通常是0-4096，这是我们常见到的像素值或者灰度值，这就需要我们在图像像素值（灰度值）转换为CT值。</p><p>首先，需要读取两个DICOM Tag信息，（0028|1052）：rescale intercept和（0028|1053）：rescale slope.</p><p>　　然后通过公式：</p><p>　　　　Hu = pixel * slope + intercept</p><p>　　计算得到CT值。</p><h1 id="衰减系数相关"><a href="#衰减系数相关" class="headerlink" title="衰减系数相关"></a>衰减系数相关</h1><p>此外，临床上常用的X射线能量范围在80-140KeV左右，也比较固定。因此，三个因素中的2个固定了，剩下的一个就是物质密度。由此可见，医学CT通常是通过物质密度来对物质进行区分的。现在来看看典型值：在临床X射线能量范围内，水的线性衰减系数为0.2cm-1，肌肉为0.2~0.21cm-1，脂肪为0.18cm-1左右，空气在0左右，骨头在0.3~0.4cm-1左右。记这些值比较麻烦，远不如记100,200这种整数来得容易。观察这些值可以发现，这些值都在水附近，所以临床上通常使用某物质与水之间的相对值来衡量物质的衰减能力，即</p><p>（物质衰减能力-水衰减能力）/（水衰减能力-空气衰减能力）*1000，</p><p>其中水衰减能力在0.2左右，空气为0左右。为了纪念第一个发明CT机的科学家Housfield，我们将这个相对值的单位记为HU。而这个相对值即为CT值。这样一来，可以得出：空气的CT值为-1000HU左右，水是0HU，脂肪是-100HU左右，肌肉是50HU左右，骨头则是500~1000HU左右。这些值就好记多了。所以，结论是：1：在医学上，由于X射线能量比较固定，有效原子序数也比较固定，CT值就基本上刻画的是不同组织的密度差异性。2：如何测量？这是CT图像重建的范畴了。X射线扫描得到投影图像，根据投影图像反演出人体每点的线性衰减系数，带入上述公式，计算得到每一个点的CT值。（注意，上述所有的值都是一些粗略的近似，实际情况则需要实际考察。例如不同部位所使用的X射线能量不同等等。为了易于理解，上述表述也不尽严谨，欢迎讨论~）</p><h1 id="转Hu值"><a href="#转Hu值" class="headerlink" title="转Hu值"></a>转Hu值</h1><p>B. Window-leveling 算法: W/L 是专门为 CT 设计的。原理很简单：CT 图像里不同组织的密度 (用 Hounsfield 单位) 是在固定的值域， 与具体设备和成像软件没有关系。因此，要看头颅时， 我们只需将头颅的值域转换到 0-255 就行了。</p><p>CT W/L 不讲头颅值域的 min 和 max, 而说 max - min (即 window_width) 和 (max+min)/2 (即 window_center)。</p><p>我们还可以用原来的公式，只是 min 和 max 的算法不一样。</p><p>// 先算图像的最大和最小值<br>min = (2<em>window_center - window_width)/2.0 + 0.5;<br>max = (2</em>window_center + window_width)/2.0 + 0.5;<br>for (i = 0; i &lt; nNumPixels; i++)<br>   disp_pixel_val = (pixel_val - min)*255.0/(double)(max - min);</p><p>请注意，CT 图像必须先转换成 Hounsfield 值再做 window-level。 这个转换包括将多余高位 bits 变成 0 (clipping), 和用 recale slope 和 rescale intercept 来做单位转换。</p><p>HU = pixel_val*rescale_slope + rescale_intercept</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间dp</title>
    <link href="/2020/07/27/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/"/>
    <url>/2020/07/27/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4dp/</url>
    
    <content type="html"><![CDATA[<p>区间dp是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态f(i,j)表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j) = max{f(i,k) + f(k+1, j) + cost}, cost 为将这两组元素合并起来的代价。</p><p>区间 DP 的特点：</p><p>合并：即将两个或多个部分进行整合，当然也可以反过来；<br>特征：能将问题分解为能两两合并的形式；<br>求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。<br>一般用二维数组表示区间<br>区间问题只需要考虑 区间头和区间尾</p><h1 id="87-扰乱字符串"><a href="#87-扰乱字符串" class="headerlink" title="87. 扰乱字符串"></a>87. 扰乱字符串</h1><p>给定一个字符串 s1，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p><p>下图是字符串 s1 = “great” 的一种可能的表示形式。</p><pre><code>great</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p><p>例如，如果我们挑选非叶节点 “gr” ，交换它的两个子节点，将会产生扰乱字符串 “rgeat” 。</p><pre><code>rgeat</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t<br>我们将 “rgeat” 称作 “great” 的一个扰乱字符串。</p><p>同样地，如果我们继续交换节点 “eat” 和 “at” 的子节点，将会产生另一个新的扰乱字符串 “rgtae” 。</p><pre><code>rgtae</code></pre><p>   /    \<br>  rg    tae<br> / \    /  \<br>r   g  ta  e<br>       / \<br>      t   a<br>我们将 “rgtae” 称作 “great” 的一个扰乱字符串。</p><p>给出两个长度相等的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串。</p><p>dp[i][j][k][h] 表示 T[k..h]T[k..h] 是否由 S[i..j]S[i..j] 变来。由于变换必须长度是一样的，因此这边有个关系 j - i = h - kj−i=h−k ，可以把四维数组降成三维。dp[i][j][len]dp[i][j][len] 表示从字符串 SS 中 ii 开始长度为 lenlen 的字符串是否能变换为从字符串 TT 中 jj 开始长度为 lenlen 的字符串</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">bool</span> isScramble(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)     &#123;        <span class="hljs-built_in">int</span> len1=s1.size();        <span class="hljs-built_in">int</span> len2=s2.size();        <span class="hljs-keyword">if</span>(len1!=len2)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        vector&lt;vector&lt;vector&lt;<span class="hljs-built_in">bool</span>&gt;&gt;&gt; res(len1+<span class="hljs-number">1</span>,vector&lt;vector&lt;<span class="hljs-built_in">bool</span>&gt; &gt;(len1+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">bool</span>&gt;(len1+<span class="hljs-number">1</span>,<span class="hljs-literal">false</span>)));        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;len1;j++)            &#123;                res[i][j][<span class="hljs-number">1</span>]=s1[i]==s2[j];            &#125;        &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=len1;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=len1-i;j++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=<span class="hljs-number">0</span>;k&lt;=len1-i;k++)                &#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> r=<span class="hljs-number">1</span>;r&lt;i;r++)                    &#123;                        <span class="hljs-keyword">if</span>(res[j][k][r]&amp;&amp;res[j+r][k+r][i-r])                        &#123;                            res[j][k][i]=<span class="hljs-literal">true</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                        <span class="hljs-keyword">if</span>(res[j][k+i-r][r]&amp;&amp;res[j+r][k][i-r])                        &#123;                            res[j][k][i]=<span class="hljs-literal">true</span>;                            <span class="hljs-keyword">break</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][len1];    &#125;&#125;;</code></pre><h1 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h1><p>DP思路是这样的，就先别管前面是怎么戳的，你只要管这个区间最后一个被戳破的是哪个气球<br>这最后一个被戳爆的气球就是 k<br> <br>注意！！！！！<br>k是这个区间   最后一个   被戳爆的气球！！！！！</p><p>假设我们戳i到j的气球，注意不包括i，j，那么假设最后破的气球为k<br>total<br>=<br>dp[i][k]<br>+<br>val[i] <em> val[k] </em> val[j]<br>+<br>dp[k][j]<br> <br>注：val[i] 表示 i 位置气球的数字<br>然后 (i,k) 和 (k,j) 也都是开区间</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> maxCoins(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;    <span class="hljs-built_in">int</span> len=nums.size();    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; res(len+<span class="hljs-number">2</span>,vector&lt;<span class="hljs-built_in">int</span>&gt; (len+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>));    vector&lt;<span class="hljs-built_in">int</span>&gt; s(len+<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);    s[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    s[len+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    &#123;        s[i+<span class="hljs-number">1</span>]=nums[i];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">3</span>;i&lt;=len+<span class="hljs-number">2</span>;i++)<span class="hljs-comment">//作为长度</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;=len+<span class="hljs-number">2</span>-i;j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> k=j+<span class="hljs-number">1</span>;k&lt;j+i<span class="hljs-number">-1</span>;k++)            &#123;                res[j][j+i<span class="hljs-number">-1</span>]=max(res[j][k]+res[k][j+i<span class="hljs-number">-1</span>]+s[j+i<span class="hljs-number">-1</span>]*s[j]*s[k],res[j][j+i<span class="hljs-number">-1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][len+<span class="hljs-number">1</span>];</code></pre><h1 id="546-移除盒子"><a href="#546-移除盒子" class="headerlink" title="546. 移除盒子"></a>546. 移除盒子</h1><p>这个题目挺难的，用的是区间dp加回溯法，讲道理不太会，下次看这个专题还是有必要重新做。</p><p>例如 [9, 5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]，对于一个区间，我判断这个区间的第一个连续色块，9，它后面与他相同的色块位置在6和11位置，那么对于9这个色块的处理有3种方法：<br>1、自己直接干掉，消除他后面的，获得1+[5, 3, 5, 3, 3, 9, 8, 8, 5, 3, 9]分<br>2、留着，先把他到他后面第一个9的区间，即[5, 3, 5, 3, 3]干掉，然后再处理9+[9, 8, 8, 5, 3, 9]<br>3、留着，但是跳过他后面第一个9的区间，即把[5, 3, 5, 3, 3, 9, 8, 8, 5, 3]都干掉之后，再去处理9+[9]<br>那么可以看出来状态转移方程了，next[i]表示后面第一个与boxes[i]相等的位置，presame表示前面有几个数字与当前第一个位置的数字相等：<br>dp(presame, i, j) = max(max[dp(0, i+1, nexti-1) + dp(presame+1, nexti, j) for every nexti in next[i]], (presame+1)^2 + dp(0, i+1, j)<br>注意这里的presame会和当前的第一个位置数字一起去当做整体去处理。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> removeBoxes(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; boxes) &#123;    <span class="hljs-built_in">int</span> n=boxes.size();    vector&lt;vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&gt; dp(n,vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;(n,vector&lt;<span class="hljs-built_in">int</span>&gt;(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)));    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,dp,boxes);&#125;<span class="hljs-built_in">int</span> dfs(<span class="hljs-built_in">int</span> l,<span class="hljs-built_in">int</span> r,<span class="hljs-built_in">int</span> k,vector&lt;vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&gt;&amp; dp,vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; boxes)&#123;    <span class="hljs-keyword">if</span>(r&lt;l)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(dp[l][r][k]!=<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> dp[l][r][k];    <span class="hljs-keyword">while</span>(r&gt;l&amp;&amp;boxes[r]==boxes[r<span class="hljs-number">-1</span>])    &#123;        k++;        r--;    &#125;    dp[l][r][k]=dfs(l,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,dp,boxes)+(k+<span class="hljs-number">1</span>)*(k+<span class="hljs-number">1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=l;i&lt;r;i++)    &#123;        <span class="hljs-keyword">if</span>(boxes[r]==boxes[i])        &#123;            dp[l][r][k]=max(dp[l][r][k],dfs(l,i,k+<span class="hljs-number">1</span>,dp,boxes)+dfs(i+<span class="hljs-number">1</span>,r<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,dp,boxes));        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[l][r][k];&#125;</code></pre><h1 id="877-石子游戏"><a href="#877-石子游戏" class="headerlink" title="877. 石子游戏"></a>877. 石子游戏</h1><p>这道题我们采用dp[i][j]来判断先手赢的数目，每次有两种选择选最前面的或者最后面的。然后需要减去下一次先手的结果，因为下一次先手是另外一个人的回合了。<br>大于0就是true.<br><pre><code class="hljs matlab">bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;    int len=piles.<span class="hljs-built_in">size</span>();    int sum=<span class="hljs-number">0</span>;    vector&lt;vector&lt;int&gt; &gt; res(len+<span class="hljs-number">1</span>,vector&lt;int&gt; (len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));    <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">i</span>&lt;len;<span class="hljs-built_in">i</span>++)    &#123;        res[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">i</span>]=piles[<span class="hljs-built_in">i</span>];    &#125;    <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span>=<span class="hljs-number">2</span>;<span class="hljs-built_in">i</span>&lt;=len;<span class="hljs-built_in">i</span>++)    &#123;        <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">j</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">j</span>+<span class="hljs-built_in">i</span>&lt;=len;<span class="hljs-built_in">j</span>++)        &#123;            res[<span class="hljs-built_in">j</span>][<span class="hljs-built_in">j</span>+<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>]=<span class="hljs-built_in">max</span>(piles[<span class="hljs-built_in">j</span>]-res[<span class="hljs-built_in">j</span>+<span class="hljs-number">1</span>][<span class="hljs-built_in">j</span>+<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>],piles[<span class="hljs-built_in">j</span>+<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>]-res[<span class="hljs-built_in">j</span>][<span class="hljs-built_in">j</span>+<span class="hljs-built_in">i</span><span class="hljs-number">-2</span>]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>]&gt;<span class="hljs-number">0</span>;&#125;</code></pre></p><h1 id="1000-合并石头的最低成本"><a href="#1000-合并石头的最低成本" class="headerlink" title="1000. 合并石头的最低成本"></a>1000. 合并石头的最低成本</h1><p>这个题目四个循环包括的是区间长度从2到n，然后每个res[j][j+i-1][k]每个区间合并成k团的结果，可以考虑把前面合成k-1团，后面认成一团。<br>最后求出每个区间合并成一团的结果。<br>最后求出的值就是结果。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> mergeStones(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; stones, <span class="hljs-built_in">int</span> K) &#123;    <span class="hljs-built_in">int</span> len=stones.size();    <span class="hljs-keyword">if</span>(!(len%(K<span class="hljs-number">-1</span>)==<span class="hljs-number">1</span>||K==<span class="hljs-number">2</span>))        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    vector&lt;vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt; &gt; &gt; res(len+<span class="hljs-number">1</span>,vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; (len+<span class="hljs-number">1</span>,vector&lt;<span class="hljs-built_in">int</span>&gt; (len+<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span>)));    vector&lt;<span class="hljs-built_in">int</span>&gt; sum(len+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)    &#123;        sum[i]=sum[i<span class="hljs-number">-1</span>]+stones[i<span class="hljs-number">-1</span>];        res[i<span class="hljs-number">-1</span>][i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">2</span>;i&lt;=len;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j+i&lt;=len;j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> t=<span class="hljs-number">2</span>;t&lt;=K;t++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> r=j;r&lt;=j+i<span class="hljs-number">-1</span>;r++)                &#123;                    res[j][j+i<span class="hljs-number">-1</span>][t]=min(res[j][j+i<span class="hljs-number">-1</span>][t],res[j][r][t<span class="hljs-number">-1</span>]+res[r+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);                &#125;            &#125;            res[j][j+i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=min(res[j][j+i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>],sum[j+i]-sum[j]+res[j][j+i<span class="hljs-number">-1</span>][K]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>][len<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>区间dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
      <tag>区间dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵动态规划</title>
    <link href="/2020/07/22/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%9F%A9%E9%98%B5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/07/22/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%9F%A9%E9%98%B5%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵动态规划的思路"><a href="#矩阵动态规划的思路" class="headerlink" title="矩阵动态规划的思路"></a>矩阵动态规划的思路</h2><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法都是用  dp(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 dp(i, j)dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积。</p><p>那么如何计算 dpdp 中的每个元素值呢？对于每个位置 (i, j)(i,j)，检查在矩阵中该位置的值：</p><p>如果该位置的值是 00，则 dp(i, j) = 0dp(i,j)=0，因为当前位置不可能在由 11 组成的正方形中；</p><p>如果该位置的值是 11，则 dp(i, j)dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dpdp 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 11，状态转移方程如下：</p><p>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1<br>dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</p><p>很巧妙的方法</p><ol><li>统计全为 1 的正方形子矩阵<br>给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。</li></ol><p>示例 1：</p><p>输入：matrix =<br>[<br>  [0,1,1,1],<br>  [1,1,1,1],<br>  [0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> countSquares(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt;&amp; matrix)     &#123;        <span class="hljs-built_in">int</span> len=matrix.size();        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        vector&lt;<span class="hljs-built_in">int</span>&gt; t(matrix[<span class="hljs-number">0</span>].size()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">int</span> num=<span class="hljs-number">0</span>;        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res1(len+<span class="hljs-number">1</span>,t);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].size();j++)            &#123;                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">1</span>)                &#123;                    <span class="hljs-built_in">int</span> r=min(res1[i][j+<span class="hljs-number">1</span>],min(res1[i][j],res1[i+<span class="hljs-number">1</span>][j]))+<span class="hljs-number">1</span>;                    res1[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=r;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    res1[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;                &#125;                num+=res1[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>];                <span class="hljs-comment">// cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;;</span>            &#125;            <span class="hljs-comment">// cout&lt;&lt;endl;</span>        &#125;        <span class="hljs-keyword">return</span> num;    &#125;&#125;;</code></pre><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a>221. 最大正方形</h2><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><p>输入: </p><p>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0</p><p>输出: 4</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix)     &#123;        <span class="hljs-built_in">int</span> len=matrix.size();        <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">0</span>||matrix[<span class="hljs-number">0</span>].size()&lt;=<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-built_in">int</span> maxsize=<span class="hljs-number">0</span>;        vector&lt;<span class="hljs-built_in">int</span>&gt; t(matrix[<span class="hljs-number">0</span>].size()+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res(len+<span class="hljs-number">1</span>,t);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[<span class="hljs-number">0</span>].size();j++)            &#123;                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-string">&#x27;1&#x27;</span>)                    res[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=min(min(res[i][j+<span class="hljs-number">1</span>],res[i+<span class="hljs-number">1</span>][j]),res[i][j])+<span class="hljs-number">1</span>;                <span class="hljs-keyword">else</span>                    res[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;                <span class="hljs-comment">//cout&lt;&lt;res[i+1][j+1]&lt;&lt;&quot; &quot;;</span>                maxsize=max(maxsize,res[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);            &#125;            <span class="hljs-comment">//cout&lt;&lt;endl;</span>        &#125;        <span class="hljs-keyword">return</span> maxsize*maxsize;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法稳定性</title>
    <link href="/2020/07/21/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    <url>/2020/07/21/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>堆排序、快速排序、希尔排序、直接选择排序是不稳定的排序算法，而基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。<br>首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。<br>其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就 是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。<br>回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。</p><p>(1)冒泡排序<br>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。</p><p>(2)选择排序<br>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么 交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><p>(3)插入排序<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。</p><p>(4)快速排序<br>快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p><p>(5)归并排序<br>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个元素(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><p>(6)基数排序<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p><p>(7)希尔排序(shell)<br>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p><p>(8)堆排序<br>我们知道堆的结构是节点i的孩子为2<em>i和2</em>i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。<br>综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序基数排序相关题目</title>
    <link href="/2020/07/21/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/07/21/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E6%A1%B6%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="164-最大间距桶排序"><a href="#164-最大间距桶排序" class="headerlink" title="164. 最大间距桶排序"></a>164. 最大间距桶排序</h2><p>第一种方法采用的是桶排序，方法很巧妙。<br>我们可以知道比较排序最好都是nlogn的，所以不能使用，使用桶排序让我们忽略桶中的顺序，只比较桶之间的大小就可以获得On的复杂度。</p><p>那么怎么得到呢，可以得到max,min 然后如果有n个，取一个比平均距离小的内容，为（max-min）/（n）+1,其实也可以加三加四都可以，只需要保证桶内的距离比平均距离小，插值一定在桶间取到就可以，如果每个每个桶的大小对平均距离向下取整，那么相差最大的两个值一定不会在桶中。所以我们只需要记录桶的最大值和最小值，然后比较桶之间的距离就行了。</p><pre><code class="hljs excel"><span class="hljs-built_in">int</span> maximumGap(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums) &#123;    <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=nums.size();    <span class="hljs-built_in">if</span>(<span class="hljs-built_in">len</span>&lt;<span class="hljs-number">2</span>)        return <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; maxnum(<span class="hljs-built_in">len</span>,-<span class="hljs-number">1</span>);    vector&lt;<span class="hljs-built_in">int</span>&gt; minnum(<span class="hljs-built_in">len</span>,-<span class="hljs-number">1</span>);    <span class="hljs-built_in">int</span> maxval=-<span class="hljs-number">1</span>,minval=nums[<span class="hljs-number">0</span>];    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;i++)    &#123;        <span class="hljs-built_in">if</span>(nums[i]&gt;maxval)            maxval=nums[i];        <span class="hljs-built_in">if</span>(nums[i]&lt;minval)            minval=nums[i];    &#125;    <span class="hljs-built_in">int</span> sizen=(maxval-minval)/(<span class="hljs-built_in">len</span>)+<span class="hljs-number">1</span>;    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;i++)    &#123;        <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>=(nums[i]-minval)/sizen;        <span class="hljs-built_in">if</span>(nums[i]&gt;maxnum[<span class="hljs-built_in">t</span>])            maxnum[<span class="hljs-built_in">t</span>]=nums[i];        <span class="hljs-built_in">if</span>(minnum[<span class="hljs-built_in">t</span>]==-<span class="hljs-number">1</span>||nums[i]&lt;minnum[<span class="hljs-built_in">t</span>])            minnum[<span class="hljs-built_in">t</span>]=nums[i];        // cout&lt;&lt;minnum[<span class="hljs-built_in">t</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;maxnum[<span class="hljs-built_in">t</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-built_in">t</span>&lt;&lt;endl;    &#125;    <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> tmp=-<span class="hljs-number">1</span>;    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;i++)    &#123;        <span class="hljs-built_in">if</span>(maxnum[i]==-<span class="hljs-number">1</span>)            continue;        <span class="hljs-built_in">if</span>(tmp==-<span class="hljs-number">1</span>)        &#123;            tmp=maxnum[i];            continue;        &#125;        <span class="hljs-built_in">if</span>(minnum[i]-tmp&gt;res)        &#123;            res=minnum[i]-tmp;            // cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;minnum[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;tmp&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;res&lt;&lt;endl;        &#125;        tmp=maxnum[i];    &#125;    return res;&#125;</code></pre><h2 id="164-最大间距基数排序"><a href="#164-最大间距基数排序" class="headerlink" title="164. 最大间距基数排序"></a>164. 最大间距基数排序</h2><p>基数排序这个是从低位到高位很适合，复杂度是d(n+k),d是位数，k是基数10.<br>这个以前不理解为啥低位到高位可行，其实原因是因为这样是稳定的，例如一个44，41，52.个位数排41，52，44排好，然后排个位就是41，44，52，为什么41一定在前面呢，就是因为，个位的时候已经在前面了，所以要保持稳定性，下次还是在前面。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> maximumGap(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums)     &#123;        <span class="hljs-built_in">int</span> len=nums.size();        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        vector&lt;<span class="hljs-built_in">int</span>&gt; t(len);        vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res(<span class="hljs-number">10</span>,t);        <span class="hljs-built_in">int</span> maxnum=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            maxnum=max(maxnum,nums[i]);        &#125;        <span class="hljs-built_in">int</span> e=<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(maxnum!=<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)                res[i].clear();            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)            &#123;                <span class="hljs-built_in">int</span> t=nums[i]/e%<span class="hljs-number">10</span>;                res[t].push_back(nums[i]);            &#125;            <span class="hljs-built_in">int</span> index=<span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)            &#123;                <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;res[i].size();j++)                &#123;                    nums[index]=res[i][j];                    index++;                &#125;            &#125;            maxnum/=<span class="hljs-number">10</span>;            e*=<span class="hljs-number">10</span>;        &#125;        <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)        &#123;            result=max(result,nums[i]-nums[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>排序</tag>
      
      <tag>桶排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中取INF</title>
    <link href="/2020/07/17/C++/C++%E4%B8%AD%E5%8F%96INF/"/>
    <url>/2020/07/17/C++/C++%E4%B8%AD%E5%8F%96INF/</url>
    
    <content type="html"><![CDATA[<p>int型是4个字bai节 一个字节8个位 0x7f7f7f7f 是十六进制du<br>也就是4个0x7f ,一个0x7f 转化为二进制就zhi是 01111111<br>因为是int型 第一个位是符号位dao ，因而在int 型中 0x7f7f7f7f也就是无穷大的意思<br>通过 #define 将 “INF” 转化为符号常量 代表 0x7f7f7f7f</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序基数排序和桶排序</title>
    <link href="/2020/07/13/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/07/13/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%92%8C%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>计数排序基数排序和桶排序</p><p>这三种方法我经常容易忘记，不太熟悉。总结一下。</p><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>原理很容易懂<br>就是排序元素的范围我们知道，那么就可以将其放到一个这么大的数组中，然后直接每次从数组中取数丢进排序数组中，这个不是一个比较排序的方法。<br>最坏时间复杂度为O(n+k),空间复杂度也为O(n+k)</p><p>空间复杂度容易理解，但是时间复杂度我一开始以为的是O(n),实际上这是不对的，因为需要考虑到n很小而k很大 n很大而k很小的情况，综合起来就是O(n+k).</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>假设:它使用了具有固定范围的“桶”。它假设每一个元素都会落在这些桶内。每一个桶的范围是固定的。如果桶的范围是1，则该算法就与计数排序很相似了，唯一的不同之处是，它存储的是元素本身而不是它们的计数。</p><p>算法：</p><p>假设有k个桶：B0, B1, … Bk-1</p><p>对于数组a中的每一个元素e：</p><pre><code>当e属于Bi时，将其插入Bi中</code></pre><p>对于B中的每一个桶b：</p><pre><code>sort b</code></pre><p>令finalarray = {}</p><p>对于B中的每一个桶b：</p><pre><code>finalarray = concat(finalarray, b)</code></pre><p>时间复杂度：O(n)，最坏情况O(n <em> n)或者O(n </em> logn)取决于其对桶使用的排序算法。最坏情况下所有元素都落入同一个桶内。</p><p>其时间复杂度还与桶的大小和范围有关。如果桶的大小和范围选择不当，可能使得所有元素都落入同一个桶中。如果元素均匀的分布在各个桶内，则时间复杂度就是O(n)</p><p>空间复杂度：O(n)</p><p>大体讲就是将数分到很多个桶中，每个桶中的排序复杂度很小，然后将数连起来。排序完成，最坏情况大家都在一个桶中效果就很差。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序的主要思路是,将所有待比较数值(注意,必须是正整数)统一为同样的数位长度,数位较短的数前面补零. 然后, 从最低位开始, 依次进行一次稳定排序(我们常用上一篇blog介绍的计数排序算法, 因为每个位可能的取值范围是固定的从0到9).这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列.</p><p>基数排序的时间复杂度是O(n*k)，其中n是排序元素的底，如是十进制就是10，k是数字位数。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包九讲</title>
    <link href="/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"/>
    <url>/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a>背包九讲</h1><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 N 件物品和一个容量为 V 的背包。放入第 i 件物品耗费的费用是 Ci<br>1，得到的<br>价值是 Wi。求解将哪些物品装入背包可使价值总和最大。<br>递推方程应该是<br><pre><code class="hljs markdown">res[<span class="hljs-string">i</span>][<span class="hljs-symbol">V</span>]=max(res[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">V-ci</span>]+wi,res[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">V</span>]);可以用滚动数组优化成O(V)空间这个空间优化的过程，应该逆序得到，顺序不可以。res[V]=max(res[V-ci],res[V]); V=V……1；</code></pre><br>还可以进行常数优化res[V]=max(res[V-ci],res[V]); </p><p>$a_1$</p><p>$V=V……max(V-\sum^{n}_{i+1}ci+1,ci)$</p><p>为什么是循环到i+1就可以停下来呢？<br>如果是ci较大，那么对于一维空间优化的情况下，表示的是res[i-1][V],对于继续向下循环是不会改变结果的。</p><p>如果是V-\sum^{n}_{i+1}ci+1较大，说明剩下的空间已经不够装ci了，自然也没必要再继续了。</p><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品<br>的费用是 Ci，价值是 Wi。求解：将哪些物品装入背包，可使这些物品的耗费的费用总<br>和不超过背包容量，且价值总和最大。</p><p>这个题目一看很容易认为是贪心问题，但是这个物品是不能分的所以不是贪心的，需要注意。<br><pre><code class="hljs markdown">这个我们考虑的就是还是某个物品选不选，但是是可以再次选它的。二维形式res[<span class="hljs-string">i</span>][<span class="hljs-symbol">V</span>]=max(res[<span class="hljs-string">i-1</span>][<span class="hljs-symbol">V</span>],res[<span class="hljs-string">i</span>][<span class="hljs-symbol">V-ci</span>]+wi);一维形式为res[V]=max(res[V],res[V-ci]+wi) v=1……V;</code></pre><br>在优化的情况下，体积大于V可以直接去掉。O(n)</p><p>另外对于任何的体积更大的，但是价值更低的，也可以优化掉。O(n^2)</p><p>还可以将体积相同的物品，都用其价值最大的代替。O(V+N)<a href="计数排序基数排序和桶排序">类似计数排序</a></p><p>for i……n<br>    if(store[V[i]]&lt;wi)<br>        store[V[i]]=wi<br>for i ……v<br>    把这些物品丢进去</p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有 N 种物品和一个容量为 V 的背包。第 i 种物品最多有 Mi 件可用，每件耗费的<br>空间是 Ci，价值是 Wi。求解将哪些物品装入背包可使这些物品的耗费的空间总和不超<br>过背包容量，且价值总和最大。</p><p>这个首先有两个朴素的想法</p><h3 id="01背包的想法"><a href="#01背包的想法" class="headerlink" title="01背包的想法"></a>01背包的想法</h3><p>这个想法是把M[i]个相同的物品看成很多个不同的物品，然后用01背包方法求解。</p><h3 id="完全背包的想法"><a href="#完全背包的想法" class="headerlink" title="完全背包的想法"></a>完全背包的想法</h3><p>这个方法就是对于任何一个物品，每次都有许多个选择，然后选取其中的k个<br>进行空间优化之后和01背包的思路相同。复杂度也相同<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> mutibackpack()<span class="hljs-comment">//类似完全背包的方法</span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;N; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;=M[i]; j++)        &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = C[i]*j; k &lt;=V; k++)            &#123;                res[k] =max(res[k], res[k-j*C[i]]+j*W[i]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[V];&#125;</code></pre></p><h3 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h3><p>二进制思想：</p><p>假设有 1000 个苹果，现在要取n个苹果，如何取？朴素的做法应该是将苹果一个一个拿出来，直到n个苹果被取出来。<br>再假设有 1000 个苹果和10只箱子，利用箱子进行某些预工作，然后如何快速的取出n个苹果呢？So..可以在每个箱子中放 2^i (i&lt;=0&lt;=n)个苹果，也就是 1、2、4、8、16、32、64、128、256、489（n减完之前的数之后不足 2^i，取最后剩余的数），相当于把十进制的数用二进制来表示，取任意n个苹果时，只要推出几只箱子就可以了。</p><p>再次分析：</p><p>只看上面是不好理解的，比如：7的二进制 7 = 111, 它可以分解成 001, 010, 100. 这三个数可以组合成任意小于等于 7 的数，而且每种组合都会得到不同的数。再比如，13 = 1101, 则分解为 0001, 0010, 0100, 0110. 前三个数字可以组合成 7 以内任意一个数，每个数再加上0110(= 6) 之后可以组合成任意一个大于等于 6 小于等于 13 的数，所以依然能组成任意小于等于 13 的数，很明显 6,7 会多重复 1 次，但对于求解背包问题是没有影响的，基于这种思想把一种多件物品转换为，多件一种物品，然后用01背包求解即可。</p><p>这个想法可以视为从以前我们对于某种物品取它的n数量，会考虑n-1数量的情况，现在我们不是间隔为1进行考虑，而是用二进制的方法来考虑<br><pre><code class="hljs dart"><span class="hljs-built_in">int</span> mutibackpack2()<span class="hljs-comment">//二进制优化</span>&#123;    <span class="hljs-built_in">int</span> ste = <span class="hljs-number">1</span>;    <span class="hljs-built_in">int</span> <span class="hljs-built_in">num</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)    &#123;        <span class="hljs-built_in">num</span> = M[i];        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">num</span>&gt;<span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">num</span>&gt;ste)                <span class="hljs-built_in">num</span> -= ste;            <span class="hljs-keyword">else</span>            &#123;                ste = <span class="hljs-built_in">num</span>;                <span class="hljs-built_in">num</span> -= ste;            &#125;            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = C[i] * ste; k &lt;= V; k++)            &#123;                res[k] = max(res[k], res[k - ste * C[i]] + ste * W[i]);            &#125;            ste *= <span class="hljs-number">2</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[V];&#125;</code></pre></p><h3 id="可行性问题"><a href="#可行性问题" class="headerlink" title="可行性问题"></a>可行性问题</h3><p>多重背包可行性问题指的是：每种有若干件的物品能否填满给定容量的背包，此时不考虑价值最大问题</p><p>F(i,j)表示使用前i个物品，填充容量为jjj的背包，第i个物品最多能够剩余多少个，如果无法填充容量为j的背包，则值为-1.</p><p>F[i-1][j]&gt;0<br>res[i][j]=M[i]</p><p>F[i][j-C[i]]&lt;=0 || j&lt;C[i]<br>res[i][j]=-1</p><p>其他<br>res[i][j]=res[i][j-C[i]]-1</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> mutibackpack3()<span class="hljs-comment">//res[i][j]表示前i中物品填满j大小的空间最大的剩余物品数量,进行了空间优化</span>&#123;    res[<span class="hljs-number">0</span>] = M[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++)    &#123;        res[V] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++)        &#123;            <span class="hljs-keyword">if</span> (res[j] &gt; <span class="hljs-number">0</span>)                res[j] = M[i];            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res[j - C[i]] &lt;= <span class="hljs-number">0</span> || j &lt; C[i])                res[j] = <span class="hljs-number">-1</span>;            <span class="hljs-keyword">else</span>                 res[j] = res[j - W[i]] - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> res[V];&#125;</code></pre><h3 id="单调队列求解"><a href="#单调队列求解" class="headerlink" title="单调队列求解"></a>单调队列求解</h3><p>这个比较难，暂时没写</p><h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><p>01 背包与完全背包的混合<br>考虑到 01 背包和完全背包中给出的伪代码只有一处不同，故如果只有两类物品：<br>一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程<br>时，根据物品的类别选用顺序或逆序的循环即可，复杂度是 O(V N)。</p><p>再加上多重背包<br>如果再加上最多可以取有限次的多重背包式的物品，那么利用单调队列，也可以给<br>出均摊 O(V N) 的解法。<br>但如果不考虑单调队列算法的话，用将每个这类物品分成 O(logMi) 个 01 背包的物<br>品的方法也已经很优了。<br>最清晰的写法是调用我们前面给出的三个过程。</p><h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><p>二维费用的背包问题是指：对于每件物品，具有两种不同的费用，选择这件物品必<br>须同时付出这两种费用。对于每种费用都有一个可付出的最大值（背包容量）。问怎样<br>选择物品可以得到最大的价值。<br>设第 i 件物品所需的两种费用分别为 Ci 和 Di。两种费用可付出的最大值（也即两<br>种背包容量）分别为 V 和 U。物品的价值为 Wi。</p><p>算法可以写成res[i][j][k]=max(res[i-1][j][k],res[i][j-ci][k-di]+2i)</p><p>有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取 U 件物品。<br>这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为 1，可以<br>付出的最大件数费用为 U。换句话说，设 F[v, u] 表示付出费用 v、最多选 u 件时可得<br>到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在<br>f[0 . . . V, 0 . . . U] 范围内寻找答案。</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。这些<br>物品被划分为 K 组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包<br>可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p>这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。<br>也就是说设 F[k, v] 表示前 k 组物品花费费用 v 能取得的最大权值</p><p>res[k][v]=max(res[k-1][v],res[k][v-c[i]]+wi),ci,wi 为组中的东西</p><h2 id="依赖背包"><a href="#依赖背包" class="headerlink" title="依赖背包"></a>依赖背包</h2><p>这个问题由 NOIP2006 中“金明的预算方案”一题扩展而来。遵从该题的提法，将<br>不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题<br>的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。<br>按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非<br>常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选<br>择两个附件……无法用状态转移方程来表示如此多的策略。事实上，设有 n 个附件，则<br>策略有 2<br>n + 1 个，为指数级。</p><p>考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主<br>件和它的附件集合实际上对应于依赖背包中的一个物品组，每个选择了主件又选择了若干个附<br>件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的<br>和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题<br>的策略一样多。</p><p>再考虑对每组内的物品应用完全背包中的优化。我们可以想到，对于第 k 个物品组中的<br>物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，可以对主件 k 的<br>“附件集合”先进行一次 01 背包，得到费用依次为 0. . .V − Ck 所有这些值时相应的最<br>大价值 Fk[0 . . . V − Ck]。那么，这个主件及它的附件集合相当于 V − Ck + 1 个物品的<br>物品组，其中费用为 v 的物品的价值为 Fk[v − Ck] + Wk，v 的取值范围是 Ck ≤ v ≤ V 。</p><p>也就是说，原来指数级的策略中，有很多策略都是冗余的，通过一次 01 背包后，<br>将主件 k 及其附件转化为 V − Ck + 1 个物品的物品组，就可以直接应用6的算法解决问<br>题了。</p><p>在树形依赖的背包问题中，我们将每颗子树作为一个泛化物品来看。同样，我们可以对每个主件的附件集合进行处理，合成一个新的泛化物品。即对每个主件的附件集合做一次01背包，得到res[j],j为0……v-wi,wi为第i个主件的空间，表示该附件集合在分配体积为j的情况下该附件总和的最优值。</p><h3 id="更一般的问题是："><a href="#更一般的问题是：" class="headerlink" title="更一般的问题是："></a>更一般的问题是：</h3><p>依赖关系以图论中“森林”3的形式给出。</p><p>也就是说，主件的附件<br>仍然可以具有自己的附件集合。限制只是每个物品最多只依赖于一个物品（只有一个主<br>件）且不出现循环依赖。<br>解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同<br>的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品<br>了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题<br>解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。<br>事实上，这是一种树形动态规划，其特点是，在用动态规划求每个父节点的属性之<br>前，需要对它的各个儿子的属性进行一次动态规划式的求值。这已经触及到了“泛化物<br>品”的思想。看完泛化物品后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物<br>品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。</p><h2 id="泛化物品"><a href="#泛化物品" class="headerlink" title="泛化物品"></a>泛化物品</h2><p>考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的<br>费用而变化。这就是泛化物品的概念。<br>更严格的定义之。在背包容量为 V 的背包问题中，泛化物品是一个定义域为 0 . . . V<br>中的整数的函数 h，当分配给它的费用为 v 时，能得到的价值就是 h(v)。<br>这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组 h[0 . . . V ]，给它<br>费用 v，可得到价值 h[v]。<br>一个费用为 c 价值为 w 的物品，如果它是 01 背包中的物品，那么把它看成泛化物<br>品，它就是除了 h(c) = w 外，其它函数值都为 0 的一个函数。如果它是完全背包中的<br>物品，那么它可以看成这样一个函数，仅当 v 被 c 整除时有 h(v) = w ·<br>v</p><p>c，其它函数值<br>均为 0。如果它是多重背包中重复次数最多为 m 的物品，那么它对应的泛化物品的函<br>数有 h(v) = w ·<br>v<br>c 仅当 v 被 c 整除且 v<br>c ≤ n，其它情况函数值均为 0。</p><p>一个物品组可以看作一个泛化物品 h。对于一个 0 . . . V 中的 v，若物品组中不存在<br>费用为 v 的物品，则 h(v) = 0，否则 h(v) 取值为所有费用为 v 的物品的最大价值。6中<br>每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。</p><h3 id="泛化物品的和"><a href="#泛化物品的和" class="headerlink" title="泛化物品的和"></a>泛化物品的和</h3><p>如果给定了两个泛化物品 h 和 l，要用一定的费用从这两个泛化物品中得到最大的<br>价值，这个问题怎么求呢？事实上，对于一个给定的费用 v，只需枚举将这个费用如何<br>分配给两个泛化物品就可以了。同样的，对于 0. . .V 中的每一个整数 v，可以求得费用<br>v 分配到 h 和 l 中的最大价值 f(v)。</p><p>f(v)=max(h(k)+l(v-k)) k=1……v</p><p>由泛化物品的定义可知：在一个背包问题中，若将两个泛化物品代以它们的和，不<br>影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过<br>程也就是求所有这些泛化物品之和的过程。若问题的和为 s，则答案就是 s(0 . . . V ) 中<br>的最大值。</p><h1 id="搜索还是DP"><a href="#搜索还是DP" class="headerlink" title="搜索还是DP?"></a>搜索还是DP?</h1><p>在看到一道背包问题时，应该用搜索还是动态规划呢？</p><p>首先，可以从数据范围中得到命题人意图的线索。如果一个背包问题可以用DP解，V一定不能很大，否则O(VN)的算法无法承受，而一般的搜索解法都是仅与N有关，与V无关的。所以，V很大时（例如上百万），命题人的意图就应该是考察搜索。另一方面，N较大时（例如上百），命题人的意图就很有可能是考察动态规划了。</p><p>另外，当想不出合适的动态规划算法时，就只能用搜索了。例如看到一个从未见过的背包中物品的限制条件，无法想出DP的方程，只好写搜索以谋求一定的分数了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包九讲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/"/>
    <url>/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="粉刷房子1"><a href="#粉刷房子1" class="headerlink" title="粉刷房子1"></a>粉刷房子1</h2><p>这个题目leetcode需要会员，题干如下。<br>假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的矩阵来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p><p>注意：</p><p>所有花费均为正整数。</p><p>示例：</p><p>输入: [[17,2,17],[16,16,5],[14,3,19]]<br>输出: 10<br>解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。<br>     最少花费: 2 + 5 + 3 = 10。</p><p>选取第i个房子涂不同颜色的最小值<br><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> minCostII(vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; costs) &#123;    <span class="hljs-built_in">int</span> n=costs.size();    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> a=costs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],b=costs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],c=costs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];    <span class="hljs-built_in">int</span> t1,t2,t3;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        t1=a;        t2=b;        t3=c;        a=min(b,c)+costs[i][<span class="hljs-number">0</span>];<span class="hljs-comment">//刷成红色的最大值</span>        b=min(t1,t3)+costs[i][<span class="hljs-number">1</span>];        c=min(t1,t2)+costs[i][<span class="hljs-number">2</span>];<span class="hljs-comment">//刷成蓝色</span>    &#125;    <span class="hljs-keyword">return</span> min((min(a,b)),c);&#125;</code></pre></p><h2 id="粉刷房子2"><a href="#粉刷房子2" class="headerlink" title="粉刷房子2"></a>粉刷房子2</h2><p>假如有一排房子，共 n 个，每个房子可以被粉刷成 k 种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。</p><p>当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x k 的矩阵来表示的。</p><p>例如，costs[0][0] 表示第 0 号房子粉刷成 0 号颜色的成本花费；costs[1][2] 表示第 1 号房子粉刷成 2 号颜色的成本花费，以此类推。请你计算出粉刷完所有房子最少的花费成本。</p><p>注意：</p><p>所有花费均为正整数。</p><p>示例：</p><p>输入: [[1,5,3],[2,9,4]]<br>输出: 5<br>解释: 将 0 号房子粉刷成 0 号颜色，1 号房子粉刷成 2 号颜色。最少花费: 1 + 4 = 5;<br>     或者将 0 号房子粉刷成 2 号颜色，1 号房子粉刷成 0 号颜色。最少花费: 3 + 2 = 5. </p><p>这个题目如果用正常的思路，那么应该是对每个位置的房子，选取不同的颜色k，然后取其颜色不为k最小值。O(n<em>k</em>k).</p><p>会导致超时，复杂度过高。</p><p>可以优化每次选上一个的最短花费和次短花费。如果颜色和最短花费不一样，则选最短花费，否则选次短花费。这个地方应该注意一点，我之前很迷惑如果最短和次短都是和它一个颜色怎么办呢，<br>后来才发现其实选的是在上一个位置颜色不同的最短花费和次短花费。这个地方比较巧妙，需要额外注意。</p><pre><code class="hljs matlab">public int minCostII(vector&lt;vector&lt;int&gt;&gt; costs,int k) &#123;    int n=costs.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||costs[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    auto res=costs;    int tmp1=<span class="hljs-number">0</span>,tmp2=<span class="hljs-number">1</span>;    int a1=<span class="hljs-number">-1</span>,a2=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">i</span>&lt;n;<span class="hljs-built_in">i</span>++)    &#123;        a1=<span class="hljs-number">-1</span>;        a2=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(int <span class="hljs-built_in">j</span>=<span class="hljs-number">0</span>;<span class="hljs-built_in">j</span>&lt;k;<span class="hljs-built_in">j</span>++)        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">j</span>==tmp1)            &#123;                res[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]=(<span class="hljs-built_in">i</span>==<span class="hljs-number">0</span>?costs[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]:res[<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>][tmp1]+costs[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]);            &#125;            <span class="hljs-keyword">else</span>            &#123;                res[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]=(<span class="hljs-built_in">i</span>==<span class="hljs-number">0</span>?costs[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]:res[<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>][tmp2]+costs[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]);            &#125;            <span class="hljs-keyword">if</span>(a2&lt;<span class="hljs-number">0</span>||res[<span class="hljs-built_in">i</span>][<span class="hljs-built_in">j</span>]&lt;res[<span class="hljs-built_in">i</span>][a2])            &#123;                a2=<span class="hljs-built_in">j</span>;                <span class="hljs-keyword">if</span>(a2&lt;<span class="hljs-number">0</span>||res[<span class="hljs-built_in">i</span>][a2]&lt;res[<span class="hljs-built_in">i</span>][a1])                &#123;                    swap(a2,a1);                &#125;            &#125;        &#125;        tmp1=a1;        tmp2=a2;    &#125;    <span class="hljs-keyword">return</span> res[n<span class="hljs-number">-1</span>][tmp1];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2020/07/13/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="打家劫舍1"><a href="#打家劫舍1" class="headerlink" title="打家劫舍1"></a>打家劫舍1</h2><p>递推公式为d0[i]=d1[i-1]+price,<br>d1[i]=max(d1[i-1],d0[i-1]);<br>可以进行空间优化<br><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> rob(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums)     &#123;        <span class="hljs-keyword">if</span>(nums.size()==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> a=nums[<span class="hljs-number">0</span>];        <span class="hljs-built_in">int</span> b=<span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> len=nums.size();        <span class="hljs-built_in">int</span> t;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)        &#123;            t=a;            a=b+nums[i];            b=max(b,t);        &#125;        <span class="hljs-keyword">return</span> max(a,b);    &#125;&#125;;</code></pre></p><h2 id="打家劫舍2"><a href="#打家劫舍2" class="headerlink" title="打家劫舍2"></a>打家劫舍2</h2><p>只需要保证最后一个和第一个不会被同时取到，注意这个不是约瑟夫问题那样可以循环的。所以只需要求两次然后考虑删除第一个和删除最后一个的情况。</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span><span class="hljs-function"></span>&#123;<span class="hljs-comment">//不能来回偷</span>    <span class="hljs-keyword">int</span> len=nums.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res1;    res1.assign(nums.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res2;    res2.assign(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>()<span class="hljs-number">-1</span>);    <span class="hljs-keyword">int</span> a=res2[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> b=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> t;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len<span class="hljs-number">-1</span>;i++)    &#123;        t=a;        a=b+res2[i];        b=<span class="hljs-built_in">max</span>(t,b);    &#125;    <span class="hljs-keyword">int</span> res=<span class="hljs-built_in">max</span>(a,b);    a=res1[<span class="hljs-number">0</span>];    b=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len<span class="hljs-number">-1</span>;i++)    &#123;        t=a;        a=b+res1[i];        b=<span class="hljs-built_in">max</span>(t,b);    &#125;    <span class="hljs-keyword">int</span> tt=<span class="hljs-built_in">max</span>(a,b);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res,tt);&#125;</code></pre><h2 id="打家劫舍3"><a href="#打家劫舍3" class="headerlink" title="打家劫舍3"></a>打家劫舍3</h2><p>这个结构是树形的，相比数组的要难一些，所以第一种方法就是考虑根节点偷和不偷的情况，然后返回之，我第一次做是用的递归返回的是偷和随便偷不偷，这样是不行的，应该要明确状态。</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp0</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)        <span class="hljs-keyword">return</span> res;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res1=dp0(root-&gt;left);    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res2=dp0(root-&gt;right);    res[<span class="hljs-number">0</span>]=root-&gt;val+res1[<span class="hljs-number">1</span>]+res2[<span class="hljs-number">1</span>];<span class="hljs-comment">//偷这个根节点的选项</span>    res[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(res1[<span class="hljs-number">0</span>],res1[<span class="hljs-number">1</span>])+<span class="hljs-built_in">max</span>(res2[<span class="hljs-number">0</span>],res2[<span class="hljs-number">1</span>]);<span class="hljs-comment">//不偷的选项</span>    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res=dp0(root);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(res[<span class="hljs-number">0</span>],res[<span class="hljs-number">1</span>]);&#125;</code></pre><p>事实上确实有一种考虑随便偷不偷的方法的。<br>在区分偷不偷的时候，我们事实上考虑的是偷目前节点加上随便偷不偷孙子节点，以及不偷目前节点，随便偷不偷儿子节点。为了防止超时，用哈希表把求得的信息存起来。<br><pre><code class="hljs coq">unordered_map&lt;TreeNode*,int&gt; m;int dp0(TreeNode* root,unordered_map&lt;TreeNode*,int&gt;&amp; m)&#123;    int value=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(root==nullptr)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(m.count(root))        <span class="hljs-keyword">return</span> m[root];    <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">left</span>!=nullptr)        value+=dp0(root-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">left</span>,m)+dp0(root-&gt;<span class="hljs-built_in">left</span>-&gt;<span class="hljs-built_in">right</span>,m);    <span class="hljs-keyword">if</span>(root-&gt;<span class="hljs-built_in">right</span>!=nullptr)        value+=dp0(root-&gt;<span class="hljs-built_in">right</span>-&gt;<span class="hljs-built_in">left</span>,m)+dp0(root-&gt;<span class="hljs-built_in">right</span>-&gt;<span class="hljs-built_in">right</span>,m);    int t=max(root-&gt;val+value,dp0(root-&gt;<span class="hljs-built_in">right</span>,m)+dp0(root-&gt;<span class="hljs-built_in">left</span>,m));    m[root]=t;    <span class="hljs-keyword">return</span> t;&#125;int rob(TreeNode* root) &#123;    <span class="hljs-keyword">if</span>(root==nullptr)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> dp0(root,m);&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>股票买卖问题</title>
    <link href="/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="股票买卖问题1"><a href="#股票买卖问题1" class="headerlink" title="股票买卖问题1"></a>股票买卖问题1</h2><p>当前的最大收益只依赖于之前的最小买入价格。只需要记住到目前为止的最小值，然后可以得到每个位置的收益。O(n)<br><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> len=prices.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">min</span>=prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(prices[i]&gt;<span class="hljs-built_in">min</span>)            &#123;                <span class="hljs-keyword">int</span> t=prices[i]-<span class="hljs-built_in">min</span>;                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">max</span>&lt;t)                    <span class="hljs-built_in">max</span>=t;            &#125;            <span class="hljs-keyword">else</span>            &#123;                <span class="hljs-built_in">min</span>=prices[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;    &#125;&#125;;</code></pre></p><h2 id="股票买卖问题2"><a href="#股票买卖问题2" class="headerlink" title="股票买卖问题2"></a>股票买卖问题2</h2><p>这个题目朴素的想法就是找到每个峰谷和峰顶，然后求差异获得利润。<br>但是由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices)     &#123;        <span class="hljs-built_in">int</span> res=<span class="hljs-number">0</span>;        <span class="hljs-built_in">int</span> len=prices.size();        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(prices[i]&gt;prices[i<span class="hljs-number">-1</span>])                res+=prices[i]-prices[i<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre><h2 id="股票买卖问题3"><a href="#股票买卖问题3" class="headerlink" title="股票买卖问题3"></a>股票买卖问题3</h2><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices) &#123;    <span class="hljs-built_in">int</span> len=prices.size();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; res1(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);    vector&lt;<span class="hljs-built_in">int</span>&gt; res2(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)        res2[i]=-prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        res2[<span class="hljs-number">0</span>]=max(res2[<span class="hljs-number">0</span>],-prices[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">2</span>;j++)        &#123;            res1[j]=max(res1[j],res2[j<span class="hljs-number">-1</span>]+prices[i]);            res2[j]=max(res1[j]-prices[i],res2[j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res1[<span class="hljs-number">2</span>];&#125;</code></pre><h2 id="股票买卖问题4"><a href="#股票买卖问题4" class="headerlink" title="股票买卖问题4"></a>股票买卖问题4</h2><p>买卖k次</p><p>当前处于第几天；<br>已经交易的次数；<br>手头是否持有股票；<br>即根据手头是否持有股票，我们定义两个二维数组来定义状态：</p><p>dp0[i][j]: 第i天结束，已有j次买卖，手头没有股票时的最大利润<br>dp1[i][j]: 第i天结束，已有j次买卖，手头有股票时的最大利润<br>因此，dp0[0][j]对于所有j都要初始化为0，而dp1[0][j]对于所有j都要初始化为-prices[i]。如果我们将dp0所有值都求出来了，那么很明显dp0[n-1][k]就是在最后一天结束时已进行k次交易且手头无股票时的最大收益，也即返回结果。 先看初始状态:</p><p>当i==0 &amp;&amp; j&gt;=0: dp0[0][j] = 0, dp1[0][j] = -prices[0];<br>当i&gt;0 &amp;&amp; j==0: dp0[i][0] = 0, dp1[i][0] = max(dp1[i-1][0], -prices[i]);<br>再来考虑状态转移方程，当i&gt;0且j&gt;0时有</p><p>dp0[i][j] = max(dp0[i-1][j], dp1[i-1][j-1] + prices[i]) # 保持 or 卖出<br>dp1[i][j] = max(dp1[i-1][j], dp0[i-1][j] - prices[i]) # 保持 or 买入<br>有了状态定义及转移方程，剩下就好办了。</p><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices) &#123;    <span class="hljs-built_in">int</span> k=<span class="hljs-number">2</span>;<span class="hljs-comment">//可以改变k值</span>    <span class="hljs-built_in">int</span> len=prices.size();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; a(k+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res1(len,a);<span class="hljs-comment">//没有股票在手中</span>    vector&lt;vector&lt;<span class="hljs-built_in">int</span>&gt;&gt; res2(len,a);<span class="hljs-comment">//有股票在手中</span>    <span class="hljs-built_in">int</span> min=prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)        res2[<span class="hljs-number">0</span>][i]=-prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        res2[i][<span class="hljs-number">0</span>]=max(res2[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],-prices[i]);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)        &#123;            res1[i][j]=max(res1[i<span class="hljs-number">-1</span>][j],res2[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+prices[i]);            res2[i][j]=max(res1[i<span class="hljs-number">-1</span>][j]-prices[i],res2[i<span class="hljs-number">-1</span>][j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res1[len<span class="hljs-number">-1</span>][k];&#125;</code></pre><p>但是这个效率不高，可以知道，当k&gt;2/n的时候。就是买卖无数次了。<br>并且可以进行空间优化。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> maxProfit(<span class="hljs-built_in">int</span> k, vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices) &#123;    <span class="hljs-built_in">int</span> len=prices.size();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>||k==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(k&gt;len/<span class="hljs-number">2</span>)    &#123;        <span class="hljs-built_in">int</span> result=<span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(prices[i]&gt;prices[i<span class="hljs-number">-1</span>])                result+=prices[i]-prices[i<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    vector&lt;<span class="hljs-built_in">int</span>&gt; res1(k+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    vector&lt;<span class="hljs-built_in">int</span>&gt; res2(k+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);    <span class="hljs-built_in">int</span> min=prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)        res2[i]=-prices[<span class="hljs-number">0</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        res2[<span class="hljs-number">0</span>]=max(res2[<span class="hljs-number">0</span>],-prices[i]);        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=k;j++)        &#123;            res1[j]=max(res1[j],res2[j<span class="hljs-number">-1</span>]+prices[i]);            res2[j]=max(res1[j]-prices[i],res2[j]);        &#125;    &#125;    <span class="hljs-keyword">return</span> res1[k];&#125;</code></pre></p><h2 id="股票买卖问题5"><a href="#股票买卖问题5" class="headerlink" title="股票买卖问题5"></a>股票买卖问题5</h2><p>这里需要注意的就是当不持股，不在冷冻期的可能就是，上一个是冷冻期，然后这一天啥也没干，还有可能就是直接就是上一天。<br><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices) &#123;    <span class="hljs-built_in">int</span> len=prices.size();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    vector&lt;<span class="hljs-built_in">int</span>&gt; res1(len,<span class="hljs-number">0</span>);<span class="hljs-comment">//不持股，不在冷冻期</span>    vector&lt;<span class="hljs-built_in">int</span>&gt; res2(len,<span class="hljs-number">0</span>);<span class="hljs-comment">//持股，不在冷冻期</span>    res2[<span class="hljs-number">0</span>]=-prices[<span class="hljs-number">0</span>];    vector&lt;<span class="hljs-built_in">int</span>&gt; res3(len,<span class="hljs-number">0</span>);<span class="hljs-comment">//不持股，在冷冻期</span>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        res1[i]=max(res1[i<span class="hljs-number">-1</span>],res3[i<span class="hljs-number">-1</span>]);        res2[i]=max(res1[i<span class="hljs-number">-1</span>]-prices[i],res2[i<span class="hljs-number">-1</span>]);        res3[i]=res2[i<span class="hljs-number">-1</span>]+prices[i];    &#125;    <span class="hljs-keyword">return</span> max(res3[len<span class="hljs-number">-1</span>],res1[len<span class="hljs-number">-1</span>]);&#125;优化空间    <span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices) &#123;    <span class="hljs-built_in">int</span> len=prices.size();    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> res1=<span class="hljs-number">0</span>;<span class="hljs-comment">//不持股，不在冷冻期</span>    <span class="hljs-built_in">int</span> res2=-prices[<span class="hljs-number">0</span>];<span class="hljs-comment">//持股，不在冷冻期</span>    <span class="hljs-built_in">int</span> res3=<span class="hljs-number">0</span>;<span class="hljs-comment">//不持股，在冷冻期</span>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)    &#123;        <span class="hljs-built_in">int</span> a=res1;        <span class="hljs-built_in">int</span> b=res2;        res1=max(a,res3);        res2=max(a-prices[i],b);        res3=b+prices[i];    &#125;    <span class="hljs-keyword">return</span> max(res3,res1);&#125;</code></pre></p><h2 id="股票买卖问题6"><a href="#股票买卖问题6" class="headerlink" title="股票买卖问题6"></a>股票买卖问题6</h2><p>也是和之前的类似，选取两个状态，持有股票，不持有股票，在卖出时还需要减去手续费。</p><pre><code class="hljs excel"><span class="hljs-built_in">int</span> maxProfit(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; prices, <span class="hljs-built_in">int</span> fee) &#123;    <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span>=prices.size();    <span class="hljs-built_in">int</span> res1=<span class="hljs-number">0</span>;    <span class="hljs-built_in">int</span> res2=-prices[<span class="hljs-number">0</span>];    <span class="hljs-built_in">int</span> <span class="hljs-built_in">t</span>;    for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;i++)    &#123;        <span class="hljs-built_in">t</span>=res1;        res1=<span class="hljs-built_in">max</span>(res1,res2+prices[i]-fee);        res2=<span class="hljs-built_in">max</span>(res2,<span class="hljs-built_in">t</span>-prices[i]);    &#125;    return res1;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划题型总结</title>
    <link href="/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>因为动态规划毕竟要满足：</p><p>阶段性<br>无后效性<br>子问题重叠性<br>因此，能够利用DP来解决的问题实际上是有限的，大部分题目都是针对现有的模型的一些变种，改改题目描述，或者加点限制条件。所以要想攻克DP题目，最根本的就是要充分理解几个常见的DP模型。而要充分理解常见经典DP模型，就需要通过大量的做题和总结，而且二者不可偏废。通过做题进行思考和量的积累，通过总结加深理解和融会贯通进而完成质的提升。</p><p>动态规划是求解一个最优化问题，而最核心的思想就是：</p><p>分而治之<br>想办法记录下中间的计算结果避免重复计算<br>解一道DP题目，先问自己几个问题：</p><p>我需要最少哪些数据，然后经过一些比较就能得出最终结果？<br>这些数据的求解是否可以用同样的方法分而治之？<br>过程中的运算结果如何保存复用？<br>当然以上内容看起来比较抽象，虽然它深刻地揭露了动态规划的本质，但是如果临场要去想明白这些问题，还是有些难度。如果只是针对比赛和面试，就像前面说的，DP题型是有限的。只要刷的题目足够多，总结出几个经典模型，剩下的都是些变种+优化而已。</p><p>一般来说，动态规划可以分成4个大类:</p><p>线性DP<br>数位dp<br>概率dp等<br>区间DP<br>树型DP<br>背包<br>线性DP就是阶段非常线性直观的模型，比如：最长（上升|下降）序列，最长公共子序列(LCS)等，也有一些简单的递推，甚至都算不上是经典模型。</p><h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><h2 id="最长上升序列"><a href="#最长上升序列" class="headerlink" title="最长上升序列"></a>最长上升序列</h2><p>最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。<br>相关题目比如：</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a>，裸题，但是要击败100%的话，需要单调队列优化。</p><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a>，这道题还是hard。之前的最长上升序列是一维的，这道题是二维的上升序列，满足Ax&lt;Bx且Ay&lt;By，才可以构成上升序列。那么我们可以根据x进行排序，然后对y求解最长上升子序列。但是这里有个地方需要注意，因为x必须要严格升序，排序之后可能存在(1,1) (1,2) (1,3) (2,4)这样的序列，如果对y进行求解上升序列，会得到4，但是实际应该只是2。为了避免这个问题，在排序时，如果x相等，则y按照降序排列，就可以规避这个问题。</p><p><a href="https://www.luogu.com.cn/problem/P1091">合唱队形</a>，这道题是要求一个形如1 3 4 7 9 8 6 5 2这样的子序列。先上升再下降，最后求最长的长度。其实解决办法也很简单，先从左到右求出所有的最长上升序列asc[i]，再从右到左求出所有的最长上升序列reverseAcc[i]，最大值就是max(asc[i]+reverseAcc[i])。对算法要能够灵活运用。</p><h2 id="LCS-最长公共子序列"><a href="#LCS-最长公共子序列" class="headerlink" title="LCS 最长公共子序列"></a><a href="1143.最长公共子序列">LCS 最长公共子序列</a></h2><p>最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。<br>求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有:</p><p>f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]<br>f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]<br>这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。<br>相关题目：</p><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. Longest Common Subsequence</a>：这道题就是裸的LCS</p><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583. Delete Operation for Two Strings</a>：两个字符串要删除成一样的，所以先找出最长公共序列，然后剩下的都删了。</p><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">718. Maximum Length of Repeated Subarray</a>：这道题其实本质上不是LCS，它是寻找最长子数组，而不是子序列（子数组要求连续）。需要搞清它们的区别。找子数组就更简单了，因为必须连续，所以f[i][j] = f[i-1][j-1]+1 : 0 ? S[i]==T[j]。通过倒序枚举能够把空间优化为O(N)。</p><p><a href="https://leetcode-cn.com/problems/shortest-common-supersequence/">1092. Shortest Common Supersequence</a>：这道题是hard，实际上也不算很hard。其实就是找到最长公共子序列，然后，对于A字符串，把除了LCS以外的字符插入到对应的位置；对于B字符串也做同样的操作。这道题大家需要掌握一个新姿势，就是除了求最长公共子序列有多长，还要会打印最长公共子序列（follow up：打印所有可能的最长公共子序列）。同时，要把剩余的字符插入到对应的位置其实可以想办法把原字符串按照LCS切分成k+1段，比如对于字符串A abcxdef，其lcs为bde，那么我们可以把原字符串切成4段 a bcx d ef，同样对于B字符串，也能切成4段，然后对应插入构成新字符串即可，需要注意的就是，从第1段开始，第一个字符是lcs字符，所以只插一次。</p><h2 id="股票买卖问题"><a href="#股票买卖问题" class="headerlink" title="股票买卖问题"></a><a href="股票买卖问题">股票买卖问题</a></h2><ol><li><p>Best Time to Buy and Sell Stock：当前的最大收益只依赖于之前的最小买入价格。因此只需要一个变量保存截至目前的最低价即可，每次更新最大收益。</p></li><li><p>Best Time to Buy and Sell Stock II：由于可以进行多次交易，那么只要明天比今天价格高就有得赚，就可以进行交易。不需要去找波峰波谷，因为day2-day1+day3-day2 == day3-day1。</p></li></ol><p>可以买卖两次股票<br>三个状态，已经买卖2次，持有 不持有股票，第k天为结束天</p><p>可以买卖k次股票<br>三个状态，已经买卖k次，持有 不持有股票，第k天为结束天</p><p>卖出股票之后有冷冻期<br>选择三个状态，持有股票，不持有股票，处于冷冻期</p><p>卖出股票之后有手续费<br>选择两个状态，持有股票，不持有股票</p><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="打家劫舍">打家劫舍</a></h2><h2 id="粉刷房子"><a href="#粉刷房子" class="headerlink" title="粉刷房子"></a><a href="粉刷房子">粉刷房子</a></h2><h2 id="背包九讲"><a href="#背包九讲" class="headerlink" title="背包九讲"></a><a href="背包九讲">背包九讲</a></h2><h2 id="图形问题"><a href="#图形问题" class="headerlink" title="图形问题"></a><a href="矩阵动态规划">图形问题</a></h2><h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a><a href="区间dp">区间dp</a></h1><h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a><a href="树形dp">树形dp</a></h1>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1143. 最长公共子序列</title>
    <link href="/2020/07/12/%E7%AE%97%E6%B3%95/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/12/%E7%AE%97%E6%B3%95/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>最长公共子序列也是线性DP中的一种比较常见的模型。说它是一种“模型”其实有点拔高了，其实它就是一类比较常见的题目。很多题目都是在LCS的基础上进行简单的扩展，或者仅仅就是换一个说法而已。<br>求两个数组的最长公共子序列，最直观地做法就是：设f[i][j]表示S[..i]和T[..j]的最长公共子序列，则有:</p><p>f[i][j] = f[i-1][j-1] + 1 …… S[i]==T[j]<br>f[i][j] = max(f[i-1][j], f[i][j-1]) …… S[i]≠T[j]<br>这个转移方程也非常好理解，时间复杂度是N^2，空间复杂度也是N^2。不过仔细观察你可以发现，当我们计算第i行时只与i-1和i行有关。因此我们可以利用01滚动来优化空间复杂度为2N。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:<span class="hljs-comment">//使用了2N的空间的动态优化</span>    <span class="hljs-built_in">int</span> longestCommonSubsequence(<span class="hljs-built_in">string</span> text1, <span class="hljs-built_in">string</span> text2)     &#123;        <span class="hljs-built_in">int</span> len1=text1.size();        <span class="hljs-built_in">int</span> len2=text2.size();        vector&lt;<span class="hljs-built_in">int</span>&gt; a1(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        vector&lt;<span class="hljs-built_in">int</span>&gt; a2(len2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);        <span class="hljs-built_in">int</span> flag=<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len1;i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">0</span>;j&lt;len2;j++)            &#123;                <span class="hljs-keyword">if</span>(text1[i]==text2[j])                &#123;                    <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">2</span>)                        a2[j+<span class="hljs-number">1</span>]=a1[j]+<span class="hljs-number">1</span>;                    <span class="hljs-keyword">else</span>                        a1[j+<span class="hljs-number">1</span>]=a2[j]+<span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">2</span>)                        a2[j+<span class="hljs-number">1</span>]=max(a2[j],a1[j+<span class="hljs-number">1</span>]);                    <span class="hljs-keyword">else</span>                        a1[j+<span class="hljs-number">1</span>]=max(a2[j+<span class="hljs-number">1</span>],a1[j]);                &#125;            &#125;            flag=-flag;        &#125;        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">2</span>)            <span class="hljs-keyword">return</span> a1[len2];        <span class="hljs-keyword">else</span>            <span class="hljs-keyword">return</span> a2[len2];    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300. 最长上升子序列</title>
    <link href="/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <url>/2020/07/12/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/300.%20%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="最长上升序列"><a href="#最长上升序列" class="headerlink" title="最长上升序列"></a>最长上升序列</h2><p>最长上升序列是一个非常经典的线性模型。说它是个模型，是因为它是一类题的代表，很多题目都只是换个说法，或者要求在这基础上进一步优化而已。最长上升序列最基础的转移方程就是f[i] = max{f[j]}+1 (a[i] &gt; a[j]),f[i]表示一定要以a[i]结尾的序列，最长长度是多少。很显然就是在前面找到一个最大的f[j]同时满足a[j]&lt;a[i]。因此是N^2的时间复杂度和N的空间复杂度。这种方法是最朴素直观的，一定要理解。它非常简单，因此很少有题目直接能够这么做。大部分相关题目需要进一步优化，也就是有名的单调队列优化，能够把复杂度优化到nlogn。</p><p>说单调队列优化之前必须明白一个贪心策略。因为要求的是最长上升序列，那么很显然长度为k的上升序列的最大值（最后一个数）越小越好，这样后面的数才有更大的概率比它大。如果我们记录下来不同长度的上升序列的最后一个数能达到的最小值，那么对于后续每个数t，它要么能放到某个长度为y的序列之后，组成长度为y+1的上升序列，要么放到某个长度为x的序列后面，把长度为x+1的序列的最大值替换成t。同时我们可以发现，如果x&lt;y，那么长度为x序列的最后一个数一定比长度为y的序列最后一个数小。因此这个上升序列我们可以用一个数组来维护（所谓的单调队列），数组下标就代表序列长度。opt[i]=t表示长度为i的上升序列最后一个数最小是t。那么当我们在面对后续某个数x时，可以对单调队列opt进行二分，把它插到对应的位置。因此总体复杂度就是NlogN。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// int lengthOfLIS(vector&lt;int&gt;&amp; nums) </span>    <span class="hljs-comment">// &#123;//dp，不用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i])</span>    <span class="hljs-comment">//     int len=nums.size();</span>    <span class="hljs-comment">//     if(len==0)</span>    <span class="hljs-comment">//         return 0;</span>    <span class="hljs-comment">//     vector&lt;int&gt; res(len,0);</span>    <span class="hljs-comment">//     res[0]=1;</span>    <span class="hljs-comment">//     int result=1;</span>    <span class="hljs-comment">//     for(int i=1;i&lt;len;i++)</span>    <span class="hljs-comment">//     &#123;</span>    <span class="hljs-comment">//         int maxnum=1;</span>    <span class="hljs-comment">//         for(int j=0;j&lt;i;j++)</span>    <span class="hljs-comment">//         &#123;</span>    <span class="hljs-comment">//             if(res[j]+1&gt;maxnum&amp;&amp;nums[j]&lt;nums[i])</span>    <span class="hljs-comment">//                 maxnum=res[j]+1;  </span>    <span class="hljs-comment">//         &#125;</span>    <span class="hljs-comment">//         res[i]=maxnum;</span>    <span class="hljs-comment">//         if(res[i]&gt;result)</span>    <span class="hljs-comment">//             result=res[i];</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">//     return result;</span>    <span class="hljs-comment">// &#125;</span>        <span class="hljs-built_in">int</span> lengthOfLIS(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; nums)     &#123;<span class="hljs-comment">//dp，用单调队列,递推方程res[i]=max(res[j])+1 (nums[j]&lt;nums[i])</span>        <span class="hljs-built_in">int</span> len=nums.size();        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        vector&lt;<span class="hljs-built_in">int</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)        &#123;            <span class="hljs-keyword">if</span>(res.size()==<span class="hljs-number">0</span>||res[res.size()<span class="hljs-number">-1</span>]&lt;nums[i])                res.push_back(nums[i]);            <span class="hljs-keyword">else</span> <span class="hljs-comment">//if(res[res.size()-1]&lt;nums[i])</span>            &#123;                <span class="hljs-built_in">int</span> p=BinSearch(res,nums[i]);                res[p]=nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> res.size();    &#125;    <span class="hljs-built_in">int</span> BinSearch(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; a,<span class="hljs-built_in">int</span> b)    &#123;        <span class="hljs-built_in">int</span> len=a.size();        <span class="hljs-built_in">int</span> l=<span class="hljs-number">0</span>,r=len<span class="hljs-number">-1</span>;        <span class="hljs-built_in">int</span> mid=l+(r-l)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">while</span>(a[mid]!=b)        &#123;            <span class="hljs-keyword">if</span>(r==l)                <span class="hljs-keyword">return</span> r;            <span class="hljs-keyword">if</span>(a[mid]&lt;b)            &#123;                l=mid+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>             &#123;                r=mid;            &#125;            mid=mid=l+(r-l)/<span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> mid;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>dp</category>
      
      <category>线性dp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性dp</tag>
      
      <tag>动态规划</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>65. 有效数字</title>
    <link href="/2020/07/03/%E7%AE%97%E6%B3%95/%5BLeetCode%5D%2065.%20%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/"/>
    <url>/2020/07/03/%E7%AE%97%E6%B3%95/%5BLeetCode%5D%2065.%20%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>题目使用有穷自动机来解决，画出DFA就可以很好的解决。<br><a href="https://www.cnblogs.com/powercai/p/10930883.html">有穷自动机可见</a></p><h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h1><p>100%内存<br>100%速度<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">bool</span> isNumber(<span class="hljs-built_in">string</span> s)<br>    &#123;<br>        <span class="hljs-built_in">int</span> sta;<br>        <span class="hljs-keyword">if</span>(s.size()&lt;=<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(isdigit(s[<span class="hljs-number">0</span>]))<br>            sta=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>            sta=<span class="hljs-number">4</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27; &#x27;</span>)<br>            sta=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;-&#x27;</span>||s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>            sta=<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;s.size();i++)<br>        &#123;<br>            <span class="hljs-keyword">switch</span>(sta)<br>            &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                        sta=<span class="hljs-number">4</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                        sta=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;-&#x27;</span>||s[i]==<span class="hljs-string">&#x27;+&#x27;</span>)<br>                        sta=<span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                        sta=<span class="hljs-number">5</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;e&#x27;</span>)<br>                        sta=<span class="hljs-number">7</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                        sta=<span class="hljs-number">6</span>;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;.&#x27;</span>)<br>                        sta=<span class="hljs-number">4</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">5</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">5</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;e&#x27;</span>)<br>                        sta=<span class="hljs-number">7</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                        sta=<span class="hljs-number">6</span>;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>                    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                        sta=<span class="hljs-number">6</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>                    <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;+&#x27;</span>||s[i]==<span class="hljs-string">&#x27;-&#x27;</span>)<br>                        sta=<span class="hljs-number">8</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">9</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">9</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>                    <span class="hljs-keyword">if</span>(isdigit(s[i]))<br>                        sta=<span class="hljs-number">9</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                        sta=<span class="hljs-number">6</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;sta;<br>        <span class="hljs-keyword">if</span>(sta==<span class="hljs-number">2</span>||sta==<span class="hljs-number">5</span>||sta==<span class="hljs-number">9</span>||sta==<span class="hljs-number">6</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre></p><pre><code>&amp;#125;</code></pre><p>&#125;;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>自动机理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leettcode</tag>
      
      <tag>有穷自动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证集和测试集的区别</title>
    <link href="/2020/07/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%AA%8C%E8%AF%81%E9%9B%86%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/07/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E9%AA%8C%E8%AF%81%E9%9B%86%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="验证集和测试集"><a href="#验证集和测试集" class="headerlink" title="验证集和测试集"></a>验证集和测试集</h2><div class="table-container"><table><thead><tr><th>类别</th><th>验证集</th><th>测试集</th></tr></thead><tbody><tr><td>是否被训练到</td><td>否</td><td>否</td></tr><tr><td>作用</td><td>用于调整超参数</td><td>用于验证泛化能力</td></tr><tr><td>使用次数</td><td>多次使用，以不断调参</td><td>仅仅一次使用</td></tr><tr><td>缺陷</td><td>模型在一次次重新手动调参并继续训练后所逼近的验证集，可能只代表一部分非训练集，导致最终训练好的模型泛化性能不够</td><td>测试集为了具有泛化代表性，往往数据量比较大，测试一轮要很久，所以往往只取测试集的其中一小部分作为训练过程中的验证集</td></tr><tr><td>互相转化</td><td>验证集具有足够泛化性（一般来说，如果验证集足够大到包括大部分非训练集时，也等于具有足够泛化性了）</td><td>验证集具有足够泛化性时，测试集就没有存在的必要了</td></tr><tr><td>类比</td><td>校内答辩（如果校内答辩比多校联合答辩还有泛化性说服力，那么就没有必要再搞个多校联合答辩了）</td><td>多校联合答辩</td></tr></tbody></table></div><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p>说到底：<br>验证集是一定需要的；<br>如果验证集具有足够泛化代表性，是不需要再整出什么测试集的；<br>整个测试集往往就是为了在验证集只是非训练集一个小子集的情况下，好奇一下那个靠训练集（训练）和验证集（调参）多次接力训练出来的模型是不是具有了泛化性能，因而加试一下图个确定。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>验证机和测试机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>166. 分数到小数</title>
    <link href="/2020/06/12/%E7%AE%97%E6%B3%95/166.%20%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/"/>
    <url>/2020/06/12/%E7%AE%97%E6%B3%95/166.%20%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="166-分数到小数"><a href="#166-分数到小数" class="headerlink" title="166. 分数到小数"></a>166. 分数到小数</h2><p>这道题我认为需要注意的有几个地方</p><p>第一个地方在于除法如何计算，这里我选择的方法是当被除数相同的时候认为是循环小数。</p><p>第二个地方在于结果可能有负数，负数的求模和正数有所不同，需要注意。负数求模是a-(a/b)*b的，有个时候因此会有正负的区分。</p><p>第三个地方在于数字溢出的问题，a=-2147483648, b=-1,a*b是会溢出的，因为会先转成一个整形的数，因此需要转一下long.</p><p>第四个地方是在判断两个数是否是同号的时候最好采用异或的方法，而不要采用相乘符号的方法，这样会导致溢出，还有一个我以前没注意的地方就是<br>异或等位运算的优先级是要低于等于符号的，因此最好加上括号。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numerator, <span class="hljs-keyword">int</span> denominator)</span> </span>&#123;        <span class="hljs-keyword">long</span> a1=<span class="hljs-keyword">long</span>(numerator)%denominator;        <span class="hljs-keyword">long</span> a2=<span class="hljs-keyword">long</span>(numerator)/denominator;        <span class="hljs-keyword">if</span>(a1==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> to_string(a2);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> quo=<span class="hljs-built_in">abs</span>(a2);            <span class="hljs-built_in">string</span> res=<span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">if</span>((numerator^denominator)&lt;<span class="hljs-number">0</span>)                &#123;                    res=res+<span class="hljs-string">&quot;-&quot;</span>;                    i++;                &#125;            res=res+to_string(quo)+<span class="hljs-string">&quot;.&quot;</span>;            i+=to_string(quo).<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;            <span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">map</span>;            numerator=<span class="hljs-built_in">abs</span>(a1);            <span class="hljs-keyword">while</span>(numerator!=<span class="hljs-number">0</span>)            &#123;                numerator=<span class="hljs-built_in">abs</span>(numerator);                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">find</span>(numerator)==<span class="hljs-built_in">map</span>.<span class="hljs-built_in">end</span>())                &#123;                    <span class="hljs-built_in">map</span>[numerator]=i;                    i++;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-built_in">string</span> tmp=res.substr(<span class="hljs-built_in">map</span>[numerator]+<span class="hljs-number">2</span>);                    <span class="hljs-built_in">string</span> tmp1=res.substr(<span class="hljs-number">0</span>,<span class="hljs-built_in">map</span>[numerator]+<span class="hljs-number">2</span>);                    res=tmp1+<span class="hljs-string">&quot;(&quot;</span>+tmp+<span class="hljs-string">&quot;)&quot;</span>;                    <span class="hljs-keyword">return</span> res;                &#125;                <span class="hljs-keyword">long</span>  ttt=numerator;                ttt*=<span class="hljs-number">10</span>;                <span class="hljs-keyword">long</span>  a=<span class="hljs-built_in">abs</span>(ttt/denominator);                <span class="hljs-keyword">long</span>  b=<span class="hljs-built_in">abs</span>(ttt%denominator);                res=res+to_string(a);                numerator=b;            &#125;            <span class="hljs-keyword">return</span> res;        &#125;    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>除法</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式学习"><a href="#设计模式学习" class="headerlink" title="设计模式学习"></a>设计模式学习</h1><p>[toc]</p><h3 id="设计模式和原则"><a href="#设计模式和原则" class="headerlink" title="设计模式和原则"></a>设计模式和原则</h3><h4 id="单一职责的原则"><a href="#单一职责的原则" class="headerlink" title="单一职责的原则"></a>单一职责的原则</h4><p>简单的说就是软件模块应该只有一个被修改的理由。例如Spring中，我们需要有dao 层和service层，而不是把它放在一起，这样后面数据库增加字段，或者业务逻辑<br>更改的时候就不需要修改很多东西，更容易维护。</p><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>就是在一个模块完成的之后，就不要去改变它，最好是通过继承和多态来增加功能。所以开闭就是，对外的拓展开放，对外的修改闭合。</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>简单的说就是尽量不要重写父类的方法，最好是只新增功能，子类可以拓展父类的功能，但是不能改变</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p>例如几维鸟虽然生物学上是鸟，但是不会飞，如果在计算飞行的一些行为的时候，设计成继承鸟类，最后会出现错误，因此最好仔细考虑他们的继承关系，去除继承关系。</p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。</p><p>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p><p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><p>在实际编程中只要遵循以下4点，就能在项目中满足这个规则。<br>每个类尽量提供接口或抽象类，或者两者都具备。<br>变量的声明类型尽量是接口或者是抽象类。<br>任何类都不应该从具体类派生。<br>使用继承时尽量遵循里氏替换原则。</p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>计算机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ART算法实现与理解</title>
    <link href="/2020/06/03/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/ART%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
    <url>/2020/06/03/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/ART%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>这两个图显示了算法的原理，整体的几何意义也较为容易理解</p><p><img src="/images/ART1.png" alt><br><img src="/images/ART2.png" alt><br><pre><code class="hljs apache"><span class="hljs-attribute">import</span> numpy as np<span class="hljs-attribute">def</span> ART_My( A, b, X<span class="hljs-number">0</span>, e<span class="hljs-number">0</span>):    <span class="hljs-attribute">e</span>=e<span class="hljs-number">0</span>+<span class="hljs-number">1</span>    <span class="hljs-attribute">i</span>=<span class="hljs-number">0</span>    <span class="hljs-attribute">while</span>(e&gt;e<span class="hljs-number">0</span>):        <span class="hljs-attribute">tmp</span>=((A[i]@X<span class="hljs-number">0</span>-b[i])/(np.linalg.norm(A[i]))*(A[i].T/np.linalg.norm(A[i])))        <span class="hljs-attribute">X</span>=X<span class="hljs-number">0</span>-np.reshape(tmp,(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))        <span class="hljs-attribute">e</span>=np.linalg.norm(X-X<span class="hljs-number">0</span>)        <span class="hljs-attribute">X0</span>=X        <span class="hljs-attribute">i</span>=(i+<span class="hljs-number">1</span>)%np.shape(A)[<span class="hljs-number">0</span>]    <span class="hljs-attribute">print</span>(e)    <span class="hljs-attribute">return</span> X<span class="hljs-number">0</span><span class="hljs-attribute">if</span> __name__==<span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-attribute">A</span>=np.array([[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]])    <span class="hljs-attribute">b</span>=np.array([[<span class="hljs-number">1</span>],[<span class="hljs-number">1</span>]])    <span class="hljs-attribute">e0</span>=<span class="hljs-number">0</span>.<span class="hljs-number">000001</span>    <span class="hljs-attribute">X0</span>=np.array([[<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>]])    <span class="hljs-attribute">X</span>=ART_My(A,b,X<span class="hljs-number">0</span>,e<span class="hljs-number">0</span>)    <span class="hljs-attribute">print</span>((X))    </code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ART</tag>
      
      <tag>医学图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数间隔和几何间隔</title>
    <link href="/2020/05/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94%E5%92%8C%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94/"/>
    <url>/2020/05/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%87%BD%E6%95%B0%E9%97%B4%E9%9A%94%E5%92%8C%E5%87%A0%E4%BD%95%E9%97%B4%E9%9A%94/</url>
    
    <content type="html"><![CDATA[<p>对同一个超平面，通过比例缩放w和b，函数间隔也会同比例变化。也就是说，对于一个成功划分正负实例的超平面（不一定最优），该平面固定，但是通过缩放w和b，可以使其function margin取任何正值。而我们的目标是找到具有最大margin的超平面。显然通过最大化函数间隔没有意义，因为任何成功划分训练实例的超平面都可以使函数间隔无限大。我们注意到，对一个超平面，函数间隔与∥w∥的比值保持不变，也就是说几何间隔与超平面关联。所以，我们目标是最大化几何间隔，而且我们可以令函数间隔为1，然后最小化∥w∥达到最大化几何间隔目的。</p><p>SVM是通过超平面将样本分为两类。在超平面wx+b确定的情况下，||wx+b||可以相对地表示点距离超平面的远近。对于两类分类问题，如果wx+b&gt;0，可视为在平面上方<br>，则的类别被判定为1；否则判定为-1。所以样本点与超平面之间的函数间隔定义为y(wx+b),但是该定义存在问题：即w和x同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。w是法向量，所以，需要将w的大小固定,使得函数间隔固定。这时的间隔也就是几何间隔 。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SVM</tag>
      
      <tag>函数间隔和几何间隔</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大端和小端</title>
    <link href="/2020/05/20/C++/%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/"/>
    <url>/2020/05/20/C++/%E5%A4%A7%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<p>字节存储顺序主要分为大端序（Big-endian）和小端序（Little-endian），区别如下<br>Big-endian：高位字节存入低地址，低位字节存入高地址<br>Little-endian：低位字节存入低地址，高位字节存入高地址<br>一般来说，x86系列CPU都是Little-endian字节序，PowerPC通常是Big-endian字节序。</p><p>因为网络协议也都是采用Big-endian方式传输数据的，所以有时也把Big-endian方式称为网络字节序</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>218. 天际线问题</title>
    <link href="/2020/05/20/%E7%AE%97%E6%B3%95/218.%20%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2020/05/20/%E7%AE%97%E6%B3%95/218.%20%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题的求解方法一"><a href="#问题的求解方法一" class="headerlink" title="问题的求解方法一"></a>问题的求解方法一</h2><p>其实我们在题目标签看到了Line Sweep，[ 线扫描或扫描线 ] ，扫描线可以想象成一条向右扫过平面的竖直线，也是一个算法，一般是玩图形学的。</p><p>接着上面的步骤，可以通过扫描线算法将两个关键点集合进行合并。</p><p>如下图，扫描线从两个集合的起始点，同时向右移动，接触到第一个关键点，则判断这一个关键点是不是满足天际线的，如果是，则将这个关键点添加到“父”集合中；如果不是，则继续同时移动到下一个关键点。</p><p>但如何判断是否是属于“父”集合中的关键点呢？可以创建两个集合（“子”）的目前高度，然后多方角度找到满足关键点的条件。</p><p>扫描线移到[2 10]关键点时，10要大于rpre的，可以满足；</p><p>扫描线移到[3 15]关键点时，lpre此时目前的高度为10，而15要大于10的，可以满足；</p><p>扫描线移到[7 10]关键点时，rpre大于lpre可以满足，反之就不满足；</p><p>接着有一个集合已经遍历完了，剩下的集合的关键点肯定是满足的，因为没有其它的集合可以阻挡到这个集合，所以直接就是满足。</p><p>这个求解方法中的归并的写法比我以前写的要简洁一些，值得学习。<br>这个问题的求解方法的重点在于合并两个点，<br>合并过程中首先选择一个集合的小的，然后判断其与当前另外一个集合的当前值的关于，如果大于则一定可以加进去，因为这个值和自身高度同样也不同<br>如果小于等于并且自身当前高度要大于另外一个集合的当前值，则可以加，否则就被盖住实际是看不到的。</p><p>在相等的情况下，我们应该考虑到相同X的位置的最高位置的不能和和此时的当前的最大位置相同，如果相同实际上是形成了一条直线，是看不到的。</p><pre><code class="hljs pgsql"><span class="hljs-keyword">class</span> Solution &#123;    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; getSkyline(<span class="hljs-type">int</span>[][] buildings)     &#123;        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();        <span class="hljs-keyword">if</span>(buildings.length==<span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> res;        <span class="hljs-keyword">return</span> divide(buildings,<span class="hljs-number">0</span>,buildings.length<span class="hljs-number">-1</span>);    &#125;    <span class="hljs-built_in">public</span> List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; divide(<span class="hljs-type">int</span> [][]buildings,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)    &#123;        List&lt;<span class="hljs-type">Integer</span>&gt; list=<span class="hljs-built_in">new</span> ArrayList&lt;<span class="hljs-type">Integer</span>&gt;();        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res=<span class="hljs-built_in">new</span> ArrayList&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt;();        <span class="hljs-keyword">if</span>(r==l)        &#123;            res.<span class="hljs-keyword">add</span>(Arrays.asList(buildings[l][<span class="hljs-number">0</span>],buildings[l][<span class="hljs-number">2</span>]));            res.<span class="hljs-keyword">add</span>(Arrays.asList(buildings[l][<span class="hljs-number">1</span>],<span class="hljs-number">0</span>));            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-type">int</span> a=l+(r-l)/<span class="hljs-number">2</span>;        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res1=divide(buildings,l,a);        List&lt;List&lt;<span class="hljs-type">Integer</span>&gt;&gt; res2=divide(buildings,a+<span class="hljs-number">1</span>,r);        <span class="hljs-type">int</span> l1=<span class="hljs-number">0</span>;        <span class="hljs-type">int</span> r1=<span class="hljs-number">0</span>;        <span class="hljs-type">int</span> lh=<span class="hljs-number">0</span>,rh=<span class="hljs-number">0</span>;        <span class="hljs-type">int</span> leftX, leftY, rightX, rightY;        <span class="hljs-keyword">while</span>(l1&lt;res1.size()||r1&lt;res2.size())        &#123;            <span class="hljs-keyword">if</span>(l1&gt;=res1.size())                res.<span class="hljs-keyword">add</span>(res2.<span class="hljs-keyword">get</span>(r1++));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1&gt;=res2.size())                res.<span class="hljs-keyword">add</span>(res1.<span class="hljs-keyword">get</span>(l1++));            <span class="hljs-keyword">else</span>            &#123;                leftX = res1.<span class="hljs-keyword">get</span>(l1).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>); // 不会出现<span class="hljs-keyword">null</span>，可以直接用<span class="hljs-type">int</span>类型                leftY = res1.<span class="hljs-keyword">get</span>(l1).<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);                rightX = res2.<span class="hljs-keyword">get</span>(r1).<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);                rightY = res2.<span class="hljs-keyword">get</span>(r1).<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);                <span class="hljs-keyword">if</span>(leftX&gt;rightX)//每次选择一个较小的                &#123;                    <span class="hljs-keyword">if</span>(rightY&gt;lh)                        res.<span class="hljs-keyword">add</span>(res2.<span class="hljs-keyword">get</span>(r1));                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rh&gt;lh)                    &#123;                        res.<span class="hljs-keyword">add</span>(Arrays.asList(rightX,lh));                    &#125;                    rh=rightY;                    r1++;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftX&lt;rightX)                &#123;                    <span class="hljs-keyword">if</span>(leftY&gt;rh)                        res.<span class="hljs-keyword">add</span>(res1.<span class="hljs-keyword">get</span>(l1));                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lh&gt;rh)                        res.<span class="hljs-keyword">add</span>(Arrays.asList(leftX,rh));                    lh=leftY;                    l1++;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    <span class="hljs-type">int</span> h=Math.max(lh,rh);                    <span class="hljs-keyword">if</span>(leftY&gt;=rightY&amp;&amp;leftY!=h)                    &#123;                        res.<span class="hljs-keyword">add</span>(res1.<span class="hljs-keyword">get</span>(l1));                    &#125;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(leftY&lt;=rightY&amp;&amp;rightY!=h)//只要不汇聚到最高点就没问题                    &#123;                        res.<span class="hljs-keyword">add</span>(res2.<span class="hljs-keyword">get</span>(r1));                    &#125;                    lh=leftY;                    rh=rightY;                    l1++;                    r1++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><p>这个方法是扫面线算法，方法较为巧妙，左上和右上节点分别设置为负数和正数，从左加入右先队列，从右边删除出，<br>然后每次和最大的节点进行比较，不同就加入节点。<br>这里的java的容器的比较器的写法是o2-o1，大于0就是顺序，否则逆序。</p><pre><code class="hljs livescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span>    public List&lt;List&lt;Integer&gt;&gt; getSkyline(int[][] buildings)     &#123;        List&lt;List&lt;Integer&gt;&gt; res=<span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();        <span class="hljs-built_in">Set</span>&lt;Pair&lt;Integer,Integer&gt;&gt; pairs=<span class="hljs-keyword">new</span> TreeSet&lt;&gt;<span class="hljs-function"><span class="hljs-params">((o1,o2)-&gt;!o1.getKey().equals(o2.getKey())?o1.getKey()-o2.getKey():o1.getValue()-o2.getValue())</span>;</span><span class="hljs-function">        <span class="hljs-title">for</span><span class="hljs-params">(int[] bu:buildings)</span></span><span class="hljs-function">        &#123;</span><span class="hljs-function">            <span class="hljs-title">pairs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Pair&lt;&gt;(bu[<span class="hljs-number">0</span>],-bu[<span class="hljs-number">2</span>]))</span>;</span><span class="hljs-function">            <span class="hljs-title">pairs</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Pair&lt;&gt;(bu[<span class="hljs-number">1</span>],bu[<span class="hljs-number">2</span>]))</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">        <span class="hljs-title">PriorityQueue</span>&lt;<span class="hljs-title">Integer</span>&gt; <span class="hljs-title">queue</span>=<span class="hljs-title">new</span> <span class="hljs-title">PriorityQueue</span>&lt;&gt;<span class="hljs-params">((o1,o2)-&gt;o2-o1)</span>;</span><span class="hljs-function">            <span class="hljs-title">int</span> <span class="hljs-title">prev</span> = 0;</span><span class="hljs-function">    // 遍历</span><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-params">(Pair&lt;Integer, Integer&gt; pair : pairs)</span> &#123;</span><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(pair.getValue() &lt; <span class="hljs-number">0</span>)</span> </span><span class="hljs-function">            <span class="hljs-title">queue</span>.<span class="hljs-title">offer</span><span class="hljs-params">(-pair.getValue())</span>; // 左端点 高度入堆</span><span class="hljs-function">        <span class="hljs-title">else</span> </span><span class="hljs-function">            <span class="hljs-title">queue</span>.<span class="hljs-title">remove</span><span class="hljs-params">(pair.getValue())</span>; // 右端点 高度出堆</span><span class="hljs-function">        <span class="hljs-title">Integer</span> <span class="hljs-title">cur</span> = <span class="hljs-title">queue</span>.<span class="hljs-title">peek</span><span class="hljs-params">()</span> == <span class="hljs-title">null</span> ? 0 : <span class="hljs-title">queue</span>.<span class="hljs-title">peek</span><span class="hljs-params">()</span>; // 获取最大堆的当前顶点，当<span class="hljs-title">null</span>时置为0</span><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(prev != cur)</span> </span><span class="hljs-function">        &#123;</span><span class="hljs-function">            <span class="hljs-title">res</span>.<span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;() </span></span><span class="hljs-function"><span class="hljs-params">            &#123;</span></span><span class="hljs-function"><span class="hljs-params">                &#123;</span></span><span class="hljs-function"><span class="hljs-params">                add(pair.getKey());</span></span><span class="hljs-function"><span class="hljs-params">                add(cur);</span></span><span class="hljs-function"><span class="hljs-params">            &#125;&#125;)</span>;</span><span class="hljs-function">            <span class="hljs-title">prev</span> = <span class="hljs-title">cur</span>;</span><span class="hljs-function">        &#125;</span><span class="hljs-function">    &#125;</span><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">res</span>;</span><span class="hljs-function">    &#125;</span><span class="hljs-function">   </span><span class="hljs-function">&#125;</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>图论</category>
      
      <category>扫描线算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>扫描线算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为啥那么C++pop不返回值</title>
    <link href="/2020/05/20/C++/%E4%B8%BA%E4%BB%80%E4%B9%88C++pop%E4%B8%8D%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <url>/2020/05/20/C++/%E4%B8%BA%E4%BB%80%E4%B9%88C++pop%E4%B8%8D%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h3 id="书上的解释"><a href="#书上的解释" class="headerlink" title="书上的解释"></a>书上的解释</h3><p>也就是说，为什么先用top（），然后用pop（）来访问和删除站定的元素，而不是把它们合并一个返回类型T的成员函数。</p><p>这种设计有很好的理由。如果pop（）返回栈顶元素，则必须按值返回，而不是按引用返回。按引用返回是不可行的，因为元素</p><p>在栈中已经不存在，必须在按引用返回之前现将其存储到某个地方。如果选用动态内存，除非动态内存最终被删除，否则将导致内存泄露。</p><p>按照数值返回效率很差，因为它包含对类型T的复制构造函数的调用。让pop（）返回数值将会导致潜在的内存问题或效率很低下，</p><p>因此最好让它什么数值也不返回，而是通过使用top（）来得到栈顶的数值。</p><p>从异常上看<br>这么使用</p><p>Stack stack;</p><p>stack.push(object);</p><p>Object obj=stack.pop() ;</p><p>当我们执行Object obj=stack.pop() 时，Object的构造函数被调用，而这里是可以反生异常的，</p><p>假设这时候发生异常，丢生的栈顶元素就回不去了。</p><p>而在java中pop（）是有返回值的<br>源码是这么写的<br>    int i = size();<br>    Object object = peek();<br>    removeElementAt(i - 1);<br>    return (E)object;</p><pre><code>实质上java进行对象赋值的时候是进行引用的。但是C++是进行一个复制构造函数的调用，</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>pop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>145. 二叉树的后序遍历</title>
    <link href="/2020/05/19/%E7%AE%97%E6%B3%95/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2020/05/19/%E7%AE%97%E6%B3%95/145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>后序遍历的麻烦之处在于不知道现在自己是父节点的左节点还是右节点，只有知道才能决定下一步是访问右节点还是根节点，不知道的情况下就不清楚下一步应该访问弹出的栈元素的本身还是它的右节点。<br>而前序遍历和中序遍历是总是只需要弹出栈中的元素，然后访问其右节点即可或者先访问自己再访问其右节点。</p><p>所以方法有三种：</p><h3 id="开始的话，也是不停的往左子树走，然后直到为-null-，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶"><a href="#开始的话，也是不停的往左子树走，然后直到为-null-，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶" class="headerlink" title="开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶"></a>开始的话，也是不停的往左子树走，然后直到为 null ，然后如果集合中没有栈顶元素，并且右子树不为空，那么我们就访问栈顶元素的右节点，并把栈顶</h3><h3 id="元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。"><a href="#元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。" class="headerlink" title="元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。"></a>元素加入集合中，如果集合中有，那么直接访问栈顶元素即可。</h3><pre><code class="hljs lasso">class Solution &#123;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root)     &#123;        <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">Integer</span>&gt;();        <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt;();        <span class="hljs-built_in">Set</span>&lt;TreeNode&gt; <span class="hljs-built_in">set</span>=<span class="hljs-literal">new</span> HashSet&lt;TreeNode&gt;();        TreeNode treenode=root;        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty()||treenode!=<span class="hljs-built_in">null</span>)        &#123;            <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-built_in">null</span>)            &#123;                <span class="hljs-built_in">stack</span>.push(treenode);                treenode=treenode.left;                   &#125;               <span class="hljs-keyword">else</span>            &#123;                TreeNode tmp=<span class="hljs-built_in">stack</span>.peek();                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">set</span>.contains(tmp)&amp;&amp;tmp.right!=<span class="hljs-built_in">null</span>)                &#123;                    treenode=tmp.right;                    <span class="hljs-built_in">set</span>.add(tmp);                &#125;                <span class="hljs-keyword">else</span>                &#123;                    res.add(tmp.val);                    <span class="hljs-built_in">stack</span>.pop();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h3 id="如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了"><a href="#如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了" class="headerlink" title="如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了"></a>如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了</h3><pre><code class="hljs routeros">class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root)     &#123;        List&lt;Integer&gt; <span class="hljs-attribute">res</span>=new ArrayList&lt;Integer&gt;();        Stack&lt;TreeNode&gt; <span class="hljs-attribute">stack</span>=new Stack&lt;TreeNode&gt;();        TreeNode <span class="hljs-attribute">treenode</span>=root;        TreeNode <span class="hljs-attribute">last</span>=<span class="hljs-literal">null</span>;        <span class="hljs-keyword">while</span>(!stack.isEmpty()||treenode!=<span class="hljs-literal">null</span>)        &#123;            <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-literal">null</span>)            &#123;                stack.push(treenode);                <span class="hljs-attribute">treenode</span>=treenode.left;                   &#125;               <span class="hljs-keyword">else</span>            &#123;                TreeNode <span class="hljs-attribute">tmp</span>=stack.peek();                <span class="hljs-keyword">if</span>(tmp.right!=<span class="hljs-literal">null</span>&amp;&amp;tmp.right!=last)                &#123;                    <span class="hljs-attribute">treenode</span>=tmp.right;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    res.<span class="hljs-builtin-name">add</span>(tmp.val);                    <span class="hljs-attribute">last</span>=tmp;                    stack.pop();                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><h3 id="只需要把每个节点-push-两次，然后判断当前-pop-节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。"><a href="#只需要把每个节点-push-两次，然后判断当前-pop-节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。" class="headerlink" title="只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。"></a>只需要把每个节点 push 两次，然后判断当前 pop 节点和栈顶节点是否相同。相同的话，就意味着是从左子树到的根节点。</h3><h3 id="不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到-list-中。这个方法比较巧妙"><a href="#不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到-list-中。这个方法比较巧妙" class="headerlink" title="不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙"></a>不同的话，就意味着是从右子树到的根节点，此时就可以把节点加入到 list 中。这个方法比较巧妙</h3><pre><code class="hljs lasso">    <span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">list</span> = <span class="hljs-literal">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">if</span> (root == <span class="hljs-built_in">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;    &#125;    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;&gt;();    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-built_in">stack</span>.push(root);    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">stack</span>.isEmpty()) &#123;        TreeNode cur = <span class="hljs-built_in">stack</span>.pop();        <span class="hljs-keyword">if</span> (cur == <span class="hljs-built_in">null</span>) &#123;            continue;        &#125;        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">stack</span>.isEmpty() &amp;&amp; cur == <span class="hljs-built_in">stack</span>.peek()) &#123;            <span class="hljs-built_in">stack</span>.push(cur.right);            <span class="hljs-built_in">stack</span>.push(cur.right);            <span class="hljs-built_in">stack</span>.push(cur.left);            <span class="hljs-built_in">stack</span>.push(cur.left);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">list</span>.add(cur.val);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;&#125;</code></pre><h3 id="可以转换成一个逆的前序遍历来实现"><a href="#可以转换成一个逆的前序遍历来实现" class="headerlink" title="可以转换成一个逆的前序遍历来实现"></a>可以转换成一个逆的前序遍历来实现</h3><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; postorderTraversal(TreeNode root) &#123;    <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Integer</span>&gt; res=<span class="hljs-literal">new</span> ArrayList&lt;<span class="hljs-built_in">Integer</span>&gt;();    <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt; <span class="hljs-built_in">stack</span>=<span class="hljs-literal">new</span> <span class="hljs-built_in">Stack</span>&lt;TreeNode&gt;();    TreeNode treenode=root;    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.isEmpty()||treenode!=<span class="hljs-built_in">null</span>)    &#123;        <span class="hljs-keyword">if</span>(treenode!=<span class="hljs-built_in">null</span>)        &#123;            res.add(treenode.val);            <span class="hljs-built_in">stack</span>.add(treenode);            treenode=treenode.right;         &#125;           <span class="hljs-keyword">else</span>        &#123;            treenode=<span class="hljs-built_in">stack</span>.pop().left;        &#125;    &#125;    Collections.reverse(res);    <span class="hljs-keyword">return</span> res;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>树</category>
      
      <category>后序遍历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>232. 用栈实现队列</title>
    <link href="/2020/05/19/%E7%AE%97%E6%B3%95/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2020/05/19/%E7%AE%97%E6%B3%95/232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>双栈实现队列，思路较为简单</p><p>···<br>class MyQueue {<br>    private Stack<Integer> stack1;<br>    private Stack<Integer> stack2;<br>    /<em>* Initialize your data structure here. </em>/<br>    public MyQueue() {<br>        stack1=new Stack<Integer>();<br>        stack2=new Stack<Integer>();<br>    }</Integer></Integer></Integer></Integer></p><pre><code>/** Push element x to the back of queue. */public void push(int x) &#123;    stack1.push(x);&#125;/** Removes the element from in front of queue and returns that element. */public int pop() &#123;    if(stack2.isEmpty())    &#123;        StackMove(stack1,stack2);    &#125;    int res=stack2.peek();    stack2.pop();    return res;&#125;/** Get the front element. */public int peek() &#123;    if(stack2.isEmpty())    &#123;        StackMove(stack1,stack2);    &#125;    int res=stack2.peek();    return res;&#125;/** Returns whether the queue is empty. */public boolean empty() &#123;    return stack1.isEmpty()&amp;&amp;stack2.isEmpty();&#125;public void StackMove(Stack&lt;Integer&gt; stack1,Stack&lt;Integer&gt; stack2)&#123;    if(stack2.isEmpty())    &#123;         while(!stack1.isEmpty())        &#123;            int a=stack1.peek();            stack2.push(a);            stack1.pop();        &#125;    &#125;&#125;</code></pre><p>}</p><p>/**</p><ul><li>Your MyQueue object will be instantiated and called as such:</li><li>MyQueue obj = new MyQueue();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.peek();</li><li>boolean param_4 = obj.empty();<br>*/<br>···</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>225. 用队列实现栈</title>
    <link href="/2020/05/19/%E7%AE%97%E6%B3%95/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2020/05/19/%E7%AE%97%E6%B3%95/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h3 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h3><p>主要是栈的pop操作比较困难，这个可以通过栈的循环出队入队来实现，复杂度为O(N)。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;&lt;/span&gt;<br>    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; quene=<span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br>    <span class="hljs-keyword">private</span>    <span class="hljs-keyword">int</span> mytop=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/<em>* Initialize your data structure here. </em>/</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyStack</span><span class="hljs-params">()</span> &lt;/span&gt;&#123;<br>    &#125;</span></span></code></pre></p><pre><code>&lt;span class=&quot;hljs-comment&quot;&gt;/** Push element x onto stack. */&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;    quene.offer(x);    mytop=x;&amp;#125;&lt;span class=&quot;hljs-comment&quot;&gt;/** Removes the element on top of the stack and returns that element. */&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;i&amp;lt;quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;;i++)    &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=quene.poll();        quene.offer(a);        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(i==quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()&lt;span class=&quot;hljs-number&quot;&gt;-2&lt;/span&gt;)            mytop=a;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; quene.poll();&amp;#125;&lt;span class=&quot;hljs-comment&quot;&gt;/** Get the top element. */&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!quene.isEmpty())    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; mytop;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&amp;#125;&lt;span class=&quot;hljs-comment&quot;&gt;/** Returns whether the stack is empty. */&lt;/span&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(quene.&lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;()==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&amp;#125;</code></pre><p>&#125;</p><p><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack obj = new MyStack();</span><br><span class="hljs-comment"> * obj.push(x);</span><br><span class="hljs-comment"> * int param_2 = obj.pop();</span><br><span class="hljs-comment"> * int param_3 = obj.top();</span><br><span class="hljs-comment"> * boolean param_4 = obj.empty();</span><br><span class="hljs-comment"> */</span>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux短横线的区别</title>
    <link href="/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%9F%AD%E6%A8%AA%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%9F%AD%E6%A8%AA%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="linux短横线的区别"><a href="#linux短横线的区别" class="headerlink" title="linux短横线的区别"></a>linux短横线的区别</h2><pre><code class="hljs properties"><span class="hljs-attr">rm</span> <span class="hljs-string">-vf ***</span><span class="hljs-attr">tar</span> <span class="hljs-string">-xzvf  ***.tar.gz</span><span class="hljs-attr">gcc</span> <span class="hljs-string">--version</span><span class="hljs-attr">rm</span> <span class="hljs-string">--help</span></code></pre><p>　　从上面命令我们可以看出，绝大数命令有以下的规则：</p><p>　　①　参数前单杠的表明后面的参数是字符形式；</p><p>　　②　参数前双杠的则表明后面的参数是单词形式</p><pre><code class="hljs css"><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">xzvf</span>  ***<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-xzvf</span> ***<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span></code></pre><p>两种命令行都是行的通的，并且功能都是解压软件包，那它们到底有什么不同呢，实际上这就涉及两种Linux风格，System V和BSD。它们对应关系如下：</p><p>　　①　参数前有横的是System V风格。</p><p>　　②　参数前没有横的是BSD风格。</p><p>　　System V和BSD两种风格的区别主要是：</p><p>　　系统启动过程中 kernel 最后一步调用的是 init 程序，init 程序的执行有两种风格，即 System V 和 BSD。</p><p>　　System V 风格中 init 调用 /etc/inittab，BSD 风格调用 /etc/rc，它们的目的相同，都是根据 runlevel 执行一系列的程序。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>224. 基本计算器</title>
    <link href="/2020/05/18/%E7%AE%97%E6%B3%95/224.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <url>/2020/05/18/%E7%AE%97%E6%B3%95/224.%20%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="方法1和方法二："><a href="#方法1和方法二：" class="headerlink" title="方法1和方法二："></a>方法1和方法二：</h2><p>只有加减的话，相当于去掉括号，去掉括号的过程就是，把数字和字符串弹出，然后计算的过程，这个方法比较麻烦，应该可以采用字符串反向便利的方式进行计算，这样计算表达式就要方便很多，从左到右算就可以，如果还有乘除之类的话，那么在过程中应该还要判断字符的优先级，然后进行计算,还有一个需要注意的就是，数字可能有很多位。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs pgsql">方法一：<br><span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-built_in">public</span> <span class="hljs-type">int</span> calculate(String s)<br>    &#123;<br>        Stack &lt;<span class="hljs-type">Integer</span>&gt; op1=<span class="hljs-built_in">new</span> Stack &lt;<span class="hljs-type">Integer</span>&gt;();//数字栈<br>        Stack&lt;<span class="hljs-type">Character</span>&gt; op2=<span class="hljs-built_in">new</span> Stack&lt;<span class="hljs-type">Character</span>&gt;();//字符栈<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;//正在记录数字<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)<br>        &#123;<br>            <span class="hljs-type">Character</span> ch=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>&amp;&amp;!<span class="hljs-type">Character</span>.isDigit(ch))<br>            &#123;<br>                op1.push(t);<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(t);<br>                flag=<span class="hljs-number">1</span>;<br>                t=<span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-type">Character</span>.isDigit(ch))<br>            &#123;<br>                flag=<span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> num=(<span class="hljs-type">int</span>)(ch-<span class="hljs-string">&#x27;0&#x27;</span>);<br>                t=t*<span class="hljs-number">10</span>+num;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;-&#x27;</span>)||ch.equals(<span class="hljs-string">&#x27;+&#x27;</span>)||ch.equals(<span class="hljs-string">&#x27;(&#x27;</span>))<br>            &#123;<br>                op2.push(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;)&#x27;</span>))<br>            &#123;<br>                op1.push(CalFormula(op1,op2));<br>            &#125;</code></pre></p><pre><code>    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)    &amp;#123;        op1.push(t);        &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(t);        flag=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;        t=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; CalFormula(op1,op2);&amp;#125;&lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; CalFormula(Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op1 , Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op2)&amp;#123;    Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt; op3=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack &amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt;&amp;gt;();//数字栈    Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt; op4=&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt; Stack&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt;&amp;gt;();//字符栈    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;!op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;))    &amp;#123;                    op3.push(op1.peek());                    op1.pop();                    op4.push(op2.peek());                    op2.pop();                    // &lt;span class=&quot;hljs-keyword&quot;&gt;System&lt;/span&gt;.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(op2.peek());    &amp;#125;                op3.push(op1.peek());                op1.pop();                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(!op2.isEmpty()&amp;amp;&amp;amp;op2.peek().equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;(&amp;#x27;&lt;/span&gt;))                    op2.pop();                &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op4.isEmpty())                &amp;#123;                    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; a=op3.peek();                    op3.pop();                    &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; b=op3.peek();                    op3.pop();                    &lt;span class=&quot;hljs-type&quot;&gt;char&lt;/span&gt; c=op4.peek();                    op4.pop();                    op3.push(cal(c,a,b));                &amp;#125;                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op3.peek();&amp;#125;&lt;span class=&quot;hljs-built_in&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-type&quot;&gt;int&lt;/span&gt; cal(&lt;span class=&quot;hljs-type&quot;&gt;Character&lt;/span&gt; ch,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num,&lt;span class=&quot;hljs-type&quot;&gt;Integer&lt;/span&gt; num1)&amp;#123;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(ch.equals(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;-&amp;#x27;&lt;/span&gt;))    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num-num1;    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;     &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; num+num1;&amp;#125;</code></pre><p>&#125;<br>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p><pre><code class="hljs reasonml">方法<span class="hljs-number">2</span>：<span class="hljs-keyword">class</span> Solution &#123;    public <span class="hljs-built_in">int</span> calculate(String s)     &#123;        Stack &lt;Integer&gt; op1=<span class="hljs-keyword">new</span> Stack &lt;Integer&gt;<span class="hljs-literal">()</span>;<span class="hljs-comment">//数字栈</span>        Stack&lt;Character&gt; op2=<span class="hljs-keyword">new</span> Stack&lt;Character&gt;<span class="hljs-literal">()</span>;<span class="hljs-comment">//字符栈</span>        Integer t=<span class="hljs-number">0</span>;        StringBuffer nu=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuffer(<span class="hljs-string">&quot;&quot;</span>)</span>;        <span class="hljs-built_in">int</span> flag=<span class="hljs-number">1</span>;<span class="hljs-comment">//正在记录数字</span>        StringBuffer a=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuffer(<span class="hljs-params">s</span>)</span>;        String str=a.reverse<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;str.length<span class="hljs-literal">()</span>;i++)        &#123;            Character ch=str.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>;            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>&amp;&amp;!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">Digit(<span class="hljs-params">ch</span>)</span>)            &#123;                t=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">nu</span>.<span class="hljs-params">reverse</span>()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);                op1.push(t);                flag=<span class="hljs-number">1</span>;                nu=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuffer(<span class="hljs-string">&quot;&quot;</span>)</span>;            &#125;            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Character</span>.</span></span>is<span class="hljs-constructor">Digit(<span class="hljs-params">ch</span>)</span>)            &#123;                nu.append(ch);                flag=<span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-character">&#x27;-&#x27;</span>)<span class="hljs-pattern-match"><span class="hljs-operator">||</span>ch.equals(&#x27;+&#x27;)<span class="hljs-operator">||</span>ch.equals(&#x27;)&#x27;))</span><span class="hljs-pattern-match">            &#123;</span><span class="hljs-pattern-match">                op2.push(ch);</span><span class="hljs-pattern-match">            &#125;</span><span class="hljs-pattern-match">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(&#x27;(&#x27;))</span><span class="hljs-pattern-match">            &#123;</span><span class="hljs-pattern-match">                <span class="hljs-constructor">CalFormula(<span class="hljs-params">op1</span>,<span class="hljs-params">op2</span>)</span>;</span><span class="hljs-pattern-match">            &#125;</span><span class="hljs-pattern-match"></span><span class="hljs-pattern-match">        &#125;</span><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(flag<span class="hljs-operator">==</span>0)</span><span class="hljs-pattern-match">        &#123;</span><span class="hljs-pattern-match">                t=<span class="hljs-constructor">Integer</span>.parse<span class="hljs-constructor">Int(<span class="hljs-params">nu</span>.<span class="hljs-params">reverse</span>()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);</span><span class="hljs-pattern-match">                op1.push(t);</span><span class="hljs-pattern-match">        &#125;</span><span class="hljs-pattern-match">        return <span class="hljs-constructor">CalFormula(<span class="hljs-params">op1</span>,<span class="hljs-params">op2</span>)</span>;</span><span class="hljs-pattern-match">    &#125;</span><span class="hljs-pattern-match">    public <span class="hljs-built_in">int</span> <span class="hljs-constructor">CalFormula(Stack &lt;Integer&gt; <span class="hljs-params">op1</span> , Stack&lt;Character&gt; <span class="hljs-params">op2</span>)</span></span><span class="hljs-pattern-match">    &#123;</span><span class="hljs-pattern-match">        <span class="hljs-constructor">Stack</span> &lt;<span class="hljs-constructor">Integer</span>&gt; op3=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Stack</span> &lt;<span class="hljs-constructor">Integer</span>&gt;();<span class="hljs-operator">/</span><span class="hljs-operator">/</span>数字栈</span><span class="hljs-pattern-match">        <span class="hljs-constructor">Stack</span>&lt;<span class="hljs-constructor">Character</span>&gt; op4=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Stack</span>&lt;<span class="hljs-constructor">Character</span>&gt;();<span class="hljs-operator">/</span><span class="hljs-operator">/</span>字符栈</span><span class="hljs-pattern-match">        <span class="hljs-keyword">while</span>(!op2.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator">&amp;&amp;</span>!op2.peek().equals(&#x27;)&#x27;))</span><span class="hljs-pattern-match">        &#123;</span><span class="hljs-pattern-match">            <span class="hljs-built_in">int</span> a=op1.peek();</span><span class="hljs-pattern-match">            op1.pop();</span><span class="hljs-pattern-match">            <span class="hljs-built_in">int</span> b=op1.peek();</span><span class="hljs-pattern-match">            op1.pop();</span><span class="hljs-pattern-match">            <span class="hljs-constructor">Character</span> c=op2.peek();</span><span class="hljs-pattern-match">            op2.pop();</span><span class="hljs-pattern-match">            op1.push(cal(c,a,b));</span><span class="hljs-pattern-match">        &#125;</span><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(!op2.is<span class="hljs-constructor">Empty()</span><span class="hljs-operator">&amp;&amp;</span>op2.peek().equals(&#x27;)&#x27;))</span><span class="hljs-pattern-match">            op2.pop();</span><span class="hljs-pattern-match">        return op1.peek();</span><span class="hljs-pattern-match">    &#125;</span><span class="hljs-pattern-match">    public <span class="hljs-built_in">int</span> cal(<span class="hljs-constructor">Character</span> ch,<span class="hljs-constructor">Integer</span> num,<span class="hljs-constructor">Integer</span> num1)</span><span class="hljs-pattern-match">    &#123;</span><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span>(ch.equals(&#x27;-&#x27;))</span><span class="hljs-pattern-match">        return num-num1;</span><span class="hljs-pattern-match">        <span class="hljs-keyword">else</span> </span><span class="hljs-pattern-match">        return num+num1;</span><span class="hljs-pattern-match">    &#125;</span><span class="hljs-pattern-match">&#125;</span></code></pre><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p>采用一种双栈的方法，<br>解法一经过了一个中间过程，先转为了后缀表达式然后进行求值。我们其实可以直接利用两个栈，边遍历边进行的，这个方法是我当时上课学的方法。从 这里 把过程贴到下边，和解法一其实有些类似的。</p><p>使用两个栈，stack0 用于存储操作数，stack1 用于存储操作符<br>从左往右扫描，遇到操作数入栈 stack0<br>遇到操作符时，如果当前优先级低于或等于栈顶操作符优先级，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符，进行计算，将结果并压入stack0，继续与栈顶操作符的比较优先级。<br>如果遇到操作符高于栈顶操作符优先级，则直接入栈 stack1<br>遇到左括号，直接入栈 stack1。<br>遇到右括号，则从 stack0 弹出两个元素，从 stack1 弹出一个操作符进行计算，并将结果加入到 stack0 中，重复这步直到遇到左括号<br>和解法一一样，因为我们只有加法和减法，所以这个流程可以简化一下。</p><p>第 3 条改成「遇到操作符时，则从 stack0 弹出两个元素进行计算，并压入stack0，直到栈空或者遇到左括号，最后将当前操作符压入 stack1 」处。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;&lt;/span&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">String</span> s)&lt;/span&gt; &lt;/span&gt;<br><span class="hljs-function">    </span>&#123;<br>        Stack &lt;Integer&gt; op1=<span class="hljs-keyword">new</span> Stack &lt;Integer&gt;();<span class="hljs-comment">//数字栈</span><br>        Stack&lt;Character&gt; op2=<span class="hljs-keyword">new</span> Stack&lt;Character&gt;();<span class="hljs-comment">//字符栈</span><br>        HashMap&lt;Character,Integer&gt; <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> HashMap&lt;Character,Integer&gt;();<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;+&#x27;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;-&#x27;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-number">-1</span>);<br>        Integer t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> flag=<span class="hljs-number">1</span>;<br>        Character ch;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)<br>        &#123;<br>             ch=s.charAt(i);<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>&amp;&amp;!Character.isDigit(ch))<br>            &#123;<br>                op1.push(t);<br>                t=<span class="hljs-number">0</span>;<br>                flag=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(Character.isDigit(ch))<br>            &#123;<br>                flag=<span class="hljs-number">0</span>;<br>                t=t*<span class="hljs-number">10</span>+(<span class="hljs-keyword">int</span>)(ch-<span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;-&#x27;</span>)||ch.equals(<span class="hljs-string">&#x27;+&#x27;</span>))<br>            &#123;<br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(!op2.isEmpty()&amp;&amp;!(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(op2.<span class="hljs-built_in">peek</span>())&lt;<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(ch)))<br>                &#123;<br>                    <span class="hljs-keyword">int</span> a=op1.<span class="hljs-built_in">peek</span>();<br>                    op1.pop();<br>                    <span class="hljs-keyword">int</span> b=op1.<span class="hljs-built_in">peek</span>();<br>                    op1.pop();<br>                    Character c=op2.<span class="hljs-built_in">peek</span>();<br>                    op2.pop();<br>                    op1.push(cal(c,b,a));<br>                &#125;<br>                op2.push(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;(&#x27;</span>))<br>            &#123;<br>                flag=<span class="hljs-number">1</span>;<br>                op2.push(ch);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;)&#x27;</span>))<br>            &#123;<br>                flag=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(!op2.isEmpty()&amp;&amp;!op2.<span class="hljs-built_in">peek</span>().equals(<span class="hljs-string">&#x27;(&#x27;</span>))<br>                &#123;<br>                    <span class="hljs-keyword">int</span> a=op1.<span class="hljs-built_in">peek</span>();<br>                    op1.pop();<br>                    <span class="hljs-keyword">int</span> b=op1.<span class="hljs-built_in">peek</span>();<br>                    op1.pop();<br>                    Character c=op2.<span class="hljs-built_in">peek</span>();<br>                    op2.pop();<br>                    op1.push(cal(c,b,a));<br>                &#125;<br>                op2.pop();<br>            &#125;</span></span></span></code></pre></p><pre><code>    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(flag==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)    &amp;#123;        op1.push(t);    &amp;#125;     &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!op2.isEmpty())    &amp;#123;        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; a=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;();        op1.pop();        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b=op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;();        op1.pop();        Character c=op2.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;();        op2.pop();        op1.push(cal(c,b,a));    &amp;#125;    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; op1.&lt;span class=&quot;hljs-built_in&quot;&gt;peek&lt;/span&gt;();&amp;#125;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;cal&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Character ch,Integer num,Integer num1)&lt;/span&gt;&lt;/span&gt;</code></pre><p><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(ch.equals(<span class="hljs-string">&#x27;-&#x27;</span>))<br>        <span class="hljs-keyword">return</span> num-num1;<br>        <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> num+num1;<br>    &#125;<br>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>算法</category>
      
      <category>计算器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>Leetcode</tag>
      
      <tag>java</tag>
      
      <tag>表达式计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统计学习方法-第九章EM算法及其推广</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h2 id="第九章EM算法及其推广"><a href="#第九章EM算法及其推广" class="headerlink" title="第九章EM算法及其推广"></a>第九章EM算法及其推广</h2><pre><code class="hljs routeros">9.1import numpy as npy=[1,1,0,1,0,0,1,0,1,1]<span class="hljs-attribute">pai</span>=0.46<span class="hljs-attribute">p</span>=0.55<span class="hljs-attribute">q</span>=0.67<span class="hljs-attribute">theta</span>=2<span class="hljs-keyword">while</span>(theta&gt;0.0001):    u_next=[]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  range(len(y)):        <span class="hljs-attribute">a</span>=pai*(p**y[i])*((1-p)**(1-y[i]))        b=(1-pai)*(q**y[i])*((1-q)**(1-y[i]))        u_next.append(a/(a+b))    <span class="hljs-attribute">pai_next</span>=0    <span class="hljs-attribute">p_next</span>=0    <span class="hljs-attribute">q_next</span>=0    <span class="hljs-attribute">tmp</span>=0    <span class="hljs-attribute">pai_next</span>=np.mean(u_next)    p_next = sum(np.multiply(u_next,y))/sum(u_next)    tmp=[1-u_next[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(y))]    q_next = sum(np.multiply(tmp,y))/sum(tmp)    <span class="hljs-builtin-name">print</span>(pai_next)    <span class="hljs-builtin-name">print</span>(p_next)    <span class="hljs-builtin-name">print</span>(q_next)    <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&quot;\n&quot;</span>)    <span class="hljs-attribute">theta</span>=abs(pai_next-pai)+abs(p_next-p)+abs(q_next-q)    <span class="hljs-attribute">pai</span>=pai_next    <span class="hljs-attribute">p</span>=p_next    <span class="hljs-attribute">q</span>=q_next</code></pre><p>求得<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript"><span class="hljs-number">0.461862835113919</span><br><span class="hljs-number">0.5345950037850112</span><br><span class="hljs-number">0.6561346417857326</span></code></pre></p><p><span class="hljs-number">0.46186283511391907</span><br><span class="hljs-number">0.5345950037850112</span><br><span class="hljs-number">0.6561346417857326</span>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>统计学习方法，作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络初始化与xavier初始化</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Exavier%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8Exavier%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27919794">xavier初始化</a> </p><p><a href="https://blog.csdn.net/manong_wxd/article/details/78734725">深度学习初始化总结</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>初始化，xavier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的范数</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%8C%83%E6%95%B0/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%8C%83%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>关于矩阵的范数的一些总结</p><p>一范数，二范数，闵可夫斯基范数这些都比较常见，一般不用多说</p><h2 id="核范数"><a href="#核范数" class="headerlink" title="核范数"></a>核范数</h2><p>代表矩阵的奇异值之和，是用来约束低秩的一种范数，代表rank(w)的凸近似。</p><script type="math/tex; mode=display">||X||_*=\sum_{i}^{}\sigma_i(x)</script><h2 id="F范数"><a href="#F范数" class="headerlink" title="F范数"></a>F范数</h2><p>即为就是对应元素的平方和再开方。<br>f范数实际上就是衡量这个矩阵和对应的零矩阵的距离，</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>范数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/pinard/p/10825264.html">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵求导</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在hexo博客中写数学公式</title>
    <link href="/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="这个网站值得借鉴"><a href="#这个网站值得借鉴" class="headerlink" title="这个网站值得借鉴"></a><a href="https://blog.csdn.net/Aoman_Hao/article/details/81381507">这个网站值得借鉴</a></h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像的k空间</title>
    <link href="/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E5%9B%BE%E5%83%8F%E7%9A%84k%E7%A9%BA%E9%97%B4/"/>
    <url>/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/%E5%9B%BE%E5%83%8F%E7%9A%84k%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>关于图像的k空间到底是什么意思呢，总的来说就算傅里叶域变换后的一种图，不能让人感性的感受到图，但是经过傅里叶反变换，总是能够变回原来的图像<br>具体可见下面两篇博客<br><a href="https://wenku.baidu.com/view/9664b875a300a6c30c229f73.html">k空间</a><br><a href="https://chunshan.github.io/MRI-QA/k-space/what-is-k-space.html">k空间</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理，k空间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵的TV最小化</title>
    <link href="/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/TV%E6%9C%80%E5%B0%8F%E5%8C%96/"/>
    <url>/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/TV%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="在一个图像处理问题中如何有效的去除图像的噪声"><a href="#在一个图像处理问题中如何有效的去除图像的噪声" class="headerlink" title="在一个图像处理问题中如何有效的去除图像的噪声"></a>在一个图像处理问题中如何有效的去除图像的噪声</h2><p>可以求解这样一个问题<br>最小化图像的TV,TV即为梯度图像的一范数，当然需要加上正则化项，如果不加的化，全黑图才是最优的一个解，加上正则化之后可以获得图像的分块光滑图像，事实证明，效果很好。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>医学图像</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
      <tag>TV最小化</tag>
      
      <tag>医学图像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>softmax和SVM损失函数</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax%E5%92%8CSVM%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/softmax%E5%92%8CSVM%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="softmax可以参考"><a href="#softmax可以参考" class="headerlink" title="softmax可以参考"></a>softmax可以参考</h2><p><a href="https://blog.csdn.net/Hai0bin1Wang2/article/details/100901006">softmax可以参考</a></p><p><a href="https://blog.csdn.net/weixin_38278334/article/details/83002748">softmax可以参考</a><br><pre><code class="hljs stan">主要要理解熵的原理，以及交叉熵。以及<span class="hljs-built_in">softmax</span>的正则化的内容</code></pre></p><h2 id="SVM损失函数可以参考"><a href="#SVM损失函数可以参考" class="headerlink" title="SVM损失函数可以参考"></a>SVM损失函数可以参考</h2><p><a href="https://www.cnblogs.com/hoey-ge/p/5587383.html">SVM损失函数可以参考</a><br><pre><code class="hljs plain">主要是要比正确分类的类别多出一个边界出来</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>softmax</tag>
      
      <tag>SVM损失</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy中矩阵与向量的加法</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/numpy%E7%9F%A9%E9%98%B5%E5%8A%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在Numpy中，矩阵与向量相加时，矩阵的每一行与向量相加，即要求矩阵的列数与向量的维数相等。<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np</code></pre></p><p>x = np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</p><h1 id="array-1-2-3"><a href="#array-1-2-3" class="headerlink" title="array([[1, 2, 3],"></a><span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],</h1><h1 id="4-5-6"><a href="#4-5-6" class="headerlink" title="[4, 5, 6]])"></a>[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])</h1><p>y = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</p><h1 id="array-1-2"><a href="#array-1-2" class="headerlink" title="array([1, 2])"></a><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])</h1><p>z = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</p><h1 id="array-1-2-3-1"><a href="#array-1-2-3-1" class="headerlink" title="array([1, 2, 3])"></a><span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</h1><h1 id="x-y-会报错"><a href="#x-y-会报错" class="headerlink" title="x + y 会报错"></a>x + y 会报错</h1><p>x + z</p><h1 id="array-2-4-6"><a href="#array-2-4-6" class="headerlink" title="array([[2, 4, 6],"></a><span class="hljs-built_in">array</span>([[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>],</h1><h1 id="5-7-9"><a href="#5-7-9" class="headerlink" title="[5, 7, 9]])"></a>[<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]])</h1><p>&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>矩阵加法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab并行</title>
    <link href="/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/matlab%E5%B9%B6%E8%A1%8C/"/>
    <url>/2020/05/18/%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F/matlab%E5%B9%B6%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="parfor-matlab用法"><a href="#parfor-matlab用法" class="headerlink" title="parfor matlab用法"></a>parfor matlab用法</h2><pre><code class="hljs angelscript">matlab会弄出几个虚拟的小pc，一个算i=<span class="hljs-number">1</span>:<span class="hljs-number">30</span>部分循环,一个算i=<span class="hljs-number">50</span>:<span class="hljs-number">80</span>部分循环,再来一个算i=<span class="hljs-number">90</span>:<span class="hljs-number">120</span>部分循环，当然数字是我瞎编的，我是想说matlab将一个大循环分成小块，然后这些小块并行计算，最后再合在一起。这样，有一个问题，因为普通的循环是从i=<span class="hljs-number">1</span>算到i=<span class="hljs-number">100</span>，一个接一个算，如果下一次循环要依赖上一次循环怎么办？如果出现这种情况，那就不能用matlab的parfor了。用parfor的前提条件就是，循环的每次迭代独立，不相互依赖。举个简单的例子，计算<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3.</span>..+<span class="hljs-number">100</span>就可以用parfor，但是如果计算斐波那契数列的前<span class="hljs-number">100</span>个数字，那就不能用parfor了。</code></pre>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>matlab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>matlab</tag>
      
      <tag>并行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>makedown数学公式写法</title>
    <link href="/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/makedown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%86%99%E6%B3%95/"/>
    <url>/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/makedown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="此网站可以查看公式写法"><a href="#此网站可以查看公式写法" class="headerlink" title="此网站可以查看公式写法"></a><a href="https://www.zybuluo.com/codeep/note/163962#10%E5%A6%82%E4%BD%95%E8%BE%93%E5%85%A5%E7%B4%AF%E5%8A%A0%E7%B4%AF%E4%B9%98%E8%BF%90%E7%AE%97">此网站可以查看公式写法</a></h2>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>makedown</tag>
      
      <tag>数学公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda 安装 pytorch</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/conda%20%E5%AE%89%E8%A3%85%20pytorch/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/conda%20%E5%AE%89%E8%A3%85%20pytorch/</url>
    
    <content type="html"><![CDATA[<p>关于conda安装pytorch的一些问题的总结</p><h2 id="使用conda安装pytorch较为简单"><a href="#使用conda安装pytorch较为简单" class="headerlink" title="使用conda安装pytorch较为简单"></a>使用conda安装pytorch较为简单</h2><h3 id="在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是"><a href="#在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是" class="headerlink" title="在pytorch官网选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是"></a>在<a href="https://pytorch.org/">pytorch官网</a>选择自己需要的版本，以及是否带gpu的，我的由于是没有gpu的，所以是</h3><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> pytorch torchvision cpuonly -c pytorch</code></pre><h1 id="但是下载的速度会很慢，而且会出现httperror-这时可以考虑更换源，选择国内的镜像源，例如清华的镜像"><a href="#但是下载的速度会很慢，而且会出现httperror-这时可以考虑更换源，选择国内的镜像源，例如清华的镜像" class="headerlink" title="但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像"></a>但是下载的速度会很慢，而且会出现httperror,这时可以考虑更换源，选择国内的镜像源，例如清华的镜像</h1><h3 id="更换镜像"><a href="#更换镜像" class="headerlink" title="更换镜像"></a>更换镜像</h3><pre><code class="hljs bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --<span class="hljs-built_in">set</span> show_channel_urls yesconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><pre><code class="hljs bash">import torch</code></pre><p>成功后代表安装成功</p><p>更多信息: <a href="https://thesakura.github.io">我的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>conda</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用github+hexo部署博客</title>
    <link href="/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2020/05/18/%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/github+hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/189fd945f38f">可见这篇博客</a></p><p>更多信息: <a href="https://thesakura.github.io">我的博客</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像生成</title>
    <link href="/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/cs231%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/"/>
    <url>/2020/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/cs231%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>可以参考这个博客<br><a href="https://blog.csdn.net/poulang5786/article/details/80766498">图像生成cs231</a></p><p>同时这个人还总结了cs231的很多内容，可以都参考一下</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs231</tag>
      
      <tag>图像生成</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
